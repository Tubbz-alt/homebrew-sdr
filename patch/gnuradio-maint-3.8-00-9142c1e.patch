diff -uNr gnuradio-3.8.0.0/.clang-tidy gnuradio-maint-3.8/.clang-tidy
--- gnuradio-3.8.0.0/.clang-tidy	1970-01-01 07:00:00.000000000 +0700
+++ gnuradio-maint-3.8/.clang-tidy	2020-01-05 09:47:33.000000000 +0700
@@ -0,0 +1,10 @@
+---
+Checks:          '-*,misc-throw-by-value-catch-by-reference,misc-static-assert,readability-container-size-empty'
+# Not in here: modernize-use-emplace, since that basically broke all things it touched
+WarningsAsErrors: ''
+HeaderFilterRegex: '\.(cc|c|cpp|h|hpp)$'
+AnalyzeTemporaryDtors: false
+FormatStyle:     file
+CheckOptions:
+...
+
diff -uNr gnuradio-3.8.0.0/CMakeLists.txt gnuradio-maint-3.8/CMakeLists.txt
--- gnuradio-3.8.0.0/CMakeLists.txt	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/CMakeLists.txt	2020-01-05 09:47:33.000000000 +0700
@@ -46,6 +46,9 @@
 SET(CMAKE_BUILD_TYPE ${CMAKE_BUILD_TYPE} CACHE STRING "")
 message(STATUS "Build type set to ${CMAKE_BUILD_TYPE}.")
 
+include(GrComponent)
+GR_REGISTER_COMPONENT("testing-support" ENABLE_TESTING)
+
 # Set the version information here
 SET(VERSION_MAJOR 3)
 SET(VERSION_API   8)
@@ -357,7 +360,6 @@
 # Enable python component
 ########################################################################
 include(GrPython)
-find_package(PythonLibs ${GR_PYTHON_MIN_VERSION})
 GR_PYTHON_CHECK_MODULE("six - python 2 and 3 compatibility library" six "True" SIX_FOUND)
 find_package(SWIG)
 
@@ -377,10 +379,6 @@
     SIX_FOUND
 )
 
-GR_REGISTER_COMPONENT("testing-support" ENABLE_TESTING
-    Boost_FOUND
-)
-
 if(${CMAKE_BUILD_TYPE} STREQUAL "Coverage")
   include(CodeCoverage)
   setup_target_for_coverage(coverage "ctest || exit 0" coverage)
diff -uNr gnuradio-3.8.0.0/README.md gnuradio-maint-3.8/README.md
--- gnuradio-3.8.0.0/README.md	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/README.md	2020-01-05 09:47:33.000000000 +0700
@@ -4,7 +4,7 @@
 
 [![Build](https://shield.lwan.ws/img/p5UKbS/weekly_runner)](https://ci.gnuradio.org/buildbot/#/)
 ![Version](https://img.shields.io/github/tag/gnuradio/gnuradio.svg)
-[![AUR](https://img.shields.io/aur/license/yaourt.svg)](https://github.com/gnuradio/gnuradio/blob/master/COPYING) 
+[![AUR](https://img.shields.io/github/license/gnuradio/gnuradio)](https://github.com/gnuradio/gnuradio/blob/master/COPYING)
 [![Docs](https://img.shields.io/badge/docs-doxygen-orange.svg)](https://www.gnuradio.org/doc/doxygen/)
 [![Packaging status](https://repology.org/badge/tiny-repos/gnuradio.svg)](https://repology.org/project/gnuradio/badges)
 
@@ -26,104 +26,41 @@
 the mailing list and post your new questions there.
 
 
-## How to Build GNU Radio
+## How to Install GNU Radio
+
+### Prebuilt Binaries
+
+The recommended way to install GNU Radio on most platforms is using available binary package distributions. 
+
+The following command is for Debian, Ubuntu, and derivatives. It will install Release 3.7 with Python2. 
+
+    sudo apt install gnuradio
+
+For other operating systems, see [Installing from Binaries](https://wiki.gnuradio.org/index.php/InstallingGR#From_Binaries)
 
 ### PyBOMBS
-PyBOMBS (Python Build Overlay Managed Bundle System) is the recommended 
-method for building and installing GNU Radio. Please see 
-https://github.com/gnuradio/pybombs for detailed instructions. Abbreviated 
-instructions are duplicated below.
-
-1. Install PyBOMBS:
-    ```
-    $ [sudo] pip install PyBOMBS
-    ```
-    or
-    ```
-    $ git clone https://github.com/gnuradio/pybombs.git
-    $ cd pybombs
-    $ sudo python setup.py install
-    ```
-
-2. Add PyBOMBS recipes:
-    ```
-    $ pybombs recipes add gr-recipes git+https://github.com/gnuradio/gr-recipes.git  
-    $ pybombs recipes add gr-etcetera git+https://github.com/gnuradio/gr-etcetera.git
-    ```
-
-3. Configure an installation prefix:
-    ```
-    $ pybombs prefix init ~/prefix/default/
-    ```
-
-4. Install GNU Radio:
-    ```
-    $ pybombs install gnuradio
-    ```
-
-5. Run GNU Radio Companion from your new prefix:
-    ```
-    $ source ~/prefix/default/setup_env.sh
-    $ gnuradio-companion
-    ```
-    or execute it without changing the current environment
-    ```
-    $ pybombs run gnuradio-companion
-    ```
-
-### Manual Source Build
-Complete build instructions are detailed in the 
-[GNU Radio Build Guide](https://www.gnuradio.org/doc/doxygen/build_guide.html). 
-Abbreviated instructions are duplicated below.
-
-1. Ensure that you have satisfied the external dependencies, see 
-[GNU Radio Dependencies](https://www.gnuradio.org/doc/doxygen/build_guide.html).
-
-2. Checkout the latest code:
-    ```
-    $ git clone --recursive https://github.com/gnuradio/gnuradio.git
-    ```
-
-3. Build with CMake:
-    ```
-    $ cd gnuradio
-    $ mkdir build
-    $ cd build
-    $ cmake [OPTIONS] ../
-    $ make
-    $ make test
-    $ sudo make install
-    ```
-    Useful `[OPTIONS]` include setting the install prefix 
-    `-DCMAKE_INSTALL_PREFIX=<directory to install to>` and the build type 
-    `-DCMAKE_BUILD_TYPE=<type>`. Currently, GNU Radio has a `"Debug"` type 
-    that builds with `-g -O2` which is useful for debugging the software, 
-    and a `"Release"` type that builds with `-O3`, which is the default.
-
-
-### PyBOMBS with support of python 3.x
-PyBOMBS currently builds GNU Radio with support of python 2.7, so to make it work with python 3.x, instructions are given below.
-
-1. Change the PYTHONPATH line in setup_env.sh, to just 3.x paths.
-
-
-2.  Find the PyBOMBS recipe "gnuradio.lwr" in .pybombs directory, check this for reference
-    ```
-    https://github.com/gnuradio/gr-recipes/blob/master/gnuradio.lwr
-    ```
-
-
-3. Change the "gitbranch" to "master".
-
-
-4. In gnuradio.lwr recipe file, add "-DENABLE_CTRLPORT_THRIFT=OFF" in "config_opt".
-
-
-5. Clear out your prior GR PyBOMBS build(s) and tell PyBOMBS to install via this recipe.
-    ```
-    pybombs install gnuradio
-    ```
 
+PyBOMBS is good at building GNU Radio, UHD, and various Out of Tree (OOT) modules from source and then installing into a specified user directory rather than in the system files. PyBOMBS detects the user's Operating System and loads all of the prerequisites in the first stage of the build.
+
+For a quick start, open a terminal window and enter the following commands. This will install Release 3.8 with Python3.
+
+    sudo -H pip3 install PyBOMBS
+    pybombs auto-config
+    pybombs recipes add-defaults
+    pybombs prefix init ~/gnuradio -R gnuradio-default
+
+<b>Wait</b>. The terminal will show the progress.
+
+To run GNU Radio Companion, enter:
+
+        pybombs run gnuradio-companion
+
+Complete PyBOMBS instructions are in the [PyBOMBS README](https://github.com/gnuradio/pybombs#pybombs).
+
+### From Source
+
+Complete instructions for building Gnuradio from source code are detailed in 
+[Installing GR From Source](https://wiki.gnuradio.org/index.php/InstallingGR#From_Source). 
 
 ## Legal Matters
 
diff -uNr gnuradio-3.8.0.0/cmake/Modules/FindCodec2.cmake gnuradio-maint-3.8/cmake/Modules/FindCodec2.cmake
--- gnuradio-3.8.0.0/cmake/Modules/FindCodec2.cmake	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/cmake/Modules/FindCodec2.cmake	2020-01-05 09:47:33.000000000 +0700
@@ -61,6 +61,18 @@
   else()
     set(LIBCODEC2_HAS_FREEDV_API false)
   endif()
+
+  # we need to discover if codec2 < 0.9
+  # moreover, codec2 < 0.8 doesn't provide codec2/version.h
+  if(EXISTS "${LIBCODEC2_INCLUDE_DIRS}/version.h")
+    file(READ "${LIBCODEC2_INCLUDE_DIRS}/version.h" _CODEC2_VERSION_H_CONTENTS)
+    string(REGEX MATCH "CODEC2_VERSION_MAJOR ([0-9]+)(.*)CODEC2_VERSION_MINOR ([0-9]+)" _CODEC2_TMP_MATCH " ${_CODEC2_VERSION_H_CONTENTS}")
+    if((CMAKE_MATCH_1 EQUAL 0) AND (CMAKE_MATCH_3 LESS 9))
+      add_definitions(-DCODEC2_LEGACY)
+    endif()
+  else()
+    add_definitions(-DCODEC2_LEGACY)
+  endif()
 endif(LIBCODEC2_INCLUDE_DIR AND LIBCODEC2_LIBRARIES)
 
 FIND_PACKAGE_HANDLE_STANDARD_ARGS(LIBCODEC2 DEFAULT_MSG LIBCODEC2_LIBRARIES LIBCODEC2_INCLUDE_DIRS)
diff -uNr gnuradio-3.8.0.0/cmake/Modules/FindLOG4CPP.cmake gnuradio-maint-3.8/cmake/Modules/FindLOG4CPP.cmake
--- gnuradio-3.8.0.0/cmake/Modules/FindLOG4CPP.cmake	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/cmake/Modules/FindLOG4CPP.cmake	2020-01-05 09:47:33.000000000 +0700
@@ -12,15 +12,15 @@
 endif ()
 
 find_path(LOG4CPP_INCLUDE_DIR log4cpp/Category.hh
-  /opt/local/include
-  /usr/local/include
   /usr/include
+  /usr/local/include
+  /opt/local/include
 )
 
 set(LOG4CPP_NAMES log4cpp)
 find_library(LOG4CPP_LIBRARY
   NAMES ${LOG4CPP_NAMES}
-  PATHS /usr/lib /usr/local/lib /opt/local/lib
+  PATHS /usr/lib /usr/lib64 /usr/local/lib  /usr/local/lib64 /opt/local/lib /opt/local/lib64
 )
 
 
@@ -48,7 +48,7 @@
 endif ()
 
 
-if (LOG4CPP_FOUND AND NOT TARGET log4cpp::log4cpp)
+if (LOG4CPP_FOUND AND NOT TARGET Log4Cpp::log4cpp)
   add_library(Log4Cpp::log4cpp INTERFACE IMPORTED)
   set_target_properties(Log4Cpp::log4cpp PROPERTIES
     INTERFACE_INCLUDE_DIRECTORIES "${LOG4CPP_INCLUDE_DIRS}"
diff -uNr gnuradio-3.8.0.0/cmake/Modules/FindQwt.cmake gnuradio-maint-3.8/cmake/Modules/FindQwt.cmake
--- gnuradio-3.8.0.0/cmake/Modules/FindQwt.cmake	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/cmake/Modules/FindQwt.cmake	2020-01-05 09:47:33.000000000 +0700
@@ -29,7 +29,7 @@
 )
 
 find_library (QWT_LIBRARIES
-  NAMES ${PC_QWT_LIBRARIES} qwt6-${QWT_QT_VERSION} qwt-${QWT_QT_VERSION}
+  NAMES ${PC_QWT_LIBRARIES} qwt6-${QWT_QT_VERSION} qwt-${QWT_QT_VERSION} qwt
   HINTS
   ${PC_QWT_LIBDIR}
   ${CMAKE_INSTALL_PREFIX}/lib
diff -uNr gnuradio-3.8.0.0/cmake/Modules/GnuradioConfig.cmake.in gnuradio-maint-3.8/cmake/Modules/GnuradioConfig.cmake.in
--- gnuradio-3.8.0.0/cmake/Modules/GnuradioConfig.cmake.in	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/cmake/Modules/GnuradioConfig.cmake.in	2020-01-05 09:47:33.000000000 +0700
@@ -24,15 +24,25 @@
 
 find_dependency(LOG4CPP)
 find_dependency(MPLIB)
-find_dependency(Boost "@Boost_MAJOR_VERSION@.@Boost_MINOR_VERSION@.@Boost_SUBMINOR_VERSION@" COMPONENTS
+
+set(BOOST_REQUIRED_COMPONENTS
     date_time
     program_options
     filesystem
     system
     regex
     thread
-    unit_test_framework
-    )
+)
+
+if (NOT ENABLE_TESTING)
+  set(ENABLE_TESTING @ENABLE_TESTING@ CACHE BOOL "Enable testing support")
+endif()
+
+if(ENABLE_TESTING)
+  list(APPEND BOOST_REQUIRED_COMPONENTS unit_test_framework)
+endif(ENABLE_TESTING)
+
+find_dependency(Boost "@Boost_MAJOR_VERSION@.@Boost_MINOR_VERSION@.@Boost_SUBMINOR_VERSION@" COMPONENTS ${BOOST_REQUIRED_COMPONENTS})
 find_dependency(Volk)
 set(ENABLE_PYTHON @ENABLE_PYTHON@ CACHE BOOL "Enable Python & SWIG")
 if(${ENABLE_PYTHON})
diff -uNr gnuradio-3.8.0.0/cmake/Modules/GrBoost.cmake gnuradio-maint-3.8/cmake/Modules/GrBoost.cmake
--- gnuradio-3.8.0.0/cmake/Modules/GrBoost.cmake	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/cmake/Modules/GrBoost.cmake	2020-01-05 09:47:33.000000000 +0700
@@ -33,9 +33,12 @@
     system
     regex
     thread
-    unit_test_framework
 )
 
+if(ENABLE_TESTING)
+    list(APPEND BOOST_REQUIRED_COMPONENTS unit_test_framework)
+endif(ENABLE_TESTING)
+
 if(UNIX AND NOT BOOST_ROOT AND EXISTS "/usr/lib64")
     list(APPEND BOOST_LIBRARYDIR "/usr/lib64") #fedora 64-bit fix
 endif(UNIX AND NOT BOOST_ROOT AND EXISTS "/usr/lib64")
@@ -69,19 +72,21 @@
     endif(BOOST_ALL_DYN_LINK)
 endif(MSVC)
 
-find_package(Boost ${GR_BOOST_MIN_VERSION} COMPONENTS ${BOOST_REQUIRED_COMPONENTS})
-
 # This does not allow us to disable specific versions. It is used
 # internally by cmake to know the formation newer versions. As newer
 # Boost version beyond what is shown here are produced, we must extend
 # this list. To disable Boost versions, see below.
+
 set(Boost_ADDITIONAL_VERSIONS
     "1.53" "1.54.0" "1.54"
     "1.55.0" "1.55" "1.56.0" "1.56" "1.57.0" "1.57" "1.58.0" "1.58" "1.59.0" "1.59"
     "1.60.0" "1.60" "1.61.0" "1.61" "1.62.0" "1.62" "1.63.0" "1.63" "1.64.0" "1.64"
     "1.65.0" "1.65" "1.66.0" "1.66" "1.67.0" "1.67" "1.68.0" "1.68" "1.69.0" "1.69"
+    "1.71.0" "1.71"
 )
 
+find_package(Boost ${GR_BOOST_MIN_VERSION} COMPONENTS ${BOOST_REQUIRED_COMPONENTS})
+
 # Boost 1.52 disabled, see https://svn.boost.org/trac/boost/ticket/7669
 # Similar problems with Boost 1.46 and 1.47.
 
diff -uNr gnuradio-3.8.0.0/cmake/Modules/GrPython.cmake gnuradio-maint-3.8/cmake/Modules/GrPython.cmake
--- gnuradio-3.8.0.0/cmake/Modules/GrPython.cmake	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/cmake/Modules/GrPython.cmake	2020-01-05 09:47:33.000000000 +0700
@@ -109,12 +109,8 @@
 ########################################################################
 if(NOT DEFINED GR_PYTHON_DIR)
 execute_process(COMMAND ${PYTHON_EXECUTABLE} -c "
-import os
-import sys
-if os.name == 'posix':
-    print(os.path.join('lib', 'python' + sys.version[:3], 'dist-packages'))
-if os.name == 'nt':
-    print(os.path.join('Lib', 'site-packages'))
+from distutils import sysconfig
+print(sysconfig.get_python_lib(plat_specific=True, prefix=''))
 " OUTPUT_VARIABLE GR_PYTHON_DIR OUTPUT_STRIP_TRAILING_WHITESPACE
 )
 endif()
diff -uNr gnuradio-3.8.0.0/dtools/bin/roll-tarball.sh gnuradio-maint-3.8/dtools/bin/roll-tarball.sh
--- gnuradio-3.8.0.0/dtools/bin/roll-tarball.sh	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/dtools/bin/roll-tarball.sh	2020-01-05 09:47:33.000000000 +0700
@@ -21,7 +21,6 @@
 setopt ERR_EXIT
 
 project=gnuradio
-version=$1
 tempdir=$(mktemp -d)
 
 #use gpg2 if available, gpg else
@@ -29,10 +28,16 @@
 #use parallel pigz if available, else gzip
 gz=$(which pigz 2> /dev/null || which gzip)
 
+echo "Figuring out versions"
+version_major=$(grep -i 'set(version_major' CMakeLists.txt |sed 's/.*VERSION_MAJOR[[:space:]]*\([[:digit:]]*\))/\1/i')
+version_api=$(grep -i 'set(version_api' CMakeLists.txt     |sed 's/.*VERSION_API[[:space:]]*\([[:digit:]]*\))/\1/i')
+version_abi=$(grep -i 'set(version_abi' CMakeLists.txt     |sed 's/.*VERSION_ABI[[:space:]]*\([[:digit:]]*\))/\1/i')
+version_patch=$(grep -i 'set(version_patch' CMakeLists.txt |sed 's/.*VERSION_PATCH[[:space:]]*\([[:digit:]]*\))/\1/i')
+version="${version_major}.${version_api}.${version_abi}.${version_patch}"
 echo "Releasing version ${version}"
 
 echo "Making temporary clean worktree…"
-git worktree add "${tempdir}/${project}" "v$1"
+git clone --recursive "$(pwd)" "${tempdir}/${project}"
 pushd "${tempdir}/${project}"
 gitroot=$(pwd)
 gitversion=$(git describe)
@@ -43,9 +48,6 @@
 gpg2 --list-keys "${signingkey}" || echo "Can't get info about key ${signingkey}.  Did you forget to do 'git config --local user.signingkey=0xDEADBEEF'?'"
 echo "… end of key info."
 
-echo "making sure submodules are up-to-date…"
-git submodule update --init
-echo "…sure."
 
 archivedir=${gitroot}/archives
 plaindir=${project}-${version}
@@ -113,6 +115,5 @@
 echo "… I'm moved."
 
 echo "Clean up temporary files…"
-git worktree prune
 rm -r ${tempdir}
 echo "…all clean."
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/apps/gnuradio-config-info.cc gnuradio-maint-3.8/gnuradio-runtime/apps/gnuradio-config-info.cc
--- gnuradio-3.8.0.0/gnuradio-runtime/apps/gnuradio-config-info.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/apps/gnuradio-config-info.cc	2020-01-05 09:47:33.000000000 +0700
@@ -61,7 +61,7 @@
         return 1;
     }
 
-    if (vm.size() == 0 || vm.count("help")) {
+    if (vm.empty() || vm.count("help")) {
         std::cout << desc << std::endl;
         return 1;
     }
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/include/gnuradio/basic_block.h gnuradio-maint-3.8/gnuradio-runtime/include/gnuradio/basic_block.h
--- gnuradio-3.8.0.0/gnuradio-runtime/include/gnuradio/basic_block.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/include/gnuradio/basic_block.h	2020-01-05 09:47:33.000000000 +0700
@@ -38,9 +38,7 @@
 #include <map>
 #include <string>
 
-#ifdef GR_CTRLPORT
 #include <gnuradio/rpcregisterhelpers.h>
-#endif
 
 namespace gr {
 
@@ -91,7 +89,7 @@
     bool d_rpc_set;
 
     msg_queue_map_t msg_queue;
-    std::vector<boost::any> d_rpc_vars; // container for all RPC variables
+    std::vector<rpcbasic_sptr> d_rpc_vars; // container for all RPC variables
 
     basic_block(void) {} // allows pure virtual interface sub-classes
 
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/include/gnuradio/block_gateway.h gnuradio-maint-3.8/gnuradio-runtime/include/gnuradio/block_gateway.h
--- gnuradio-3.8.0.0/gnuradio-runtime/include/gnuradio/block_gateway.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/include/gnuradio/block_gateway.h	2020-01-05 09:47:33.000000000 +0700
@@ -310,7 +310,11 @@
 
     bool has_msg_handler(pmt::pmt_t which_port)
     {
-        return (d_msg_handlers_feval.find(which_port) != d_msg_handlers_feval.end());
+        if (d_msg_handlers_feval.find(which_port) != d_msg_handlers_feval.end()) {
+            return true;
+        } else {
+            return gr::basic_block::has_msg_handler(which_port);
+        }
     }
 
     void dispatch_msg(pmt::pmt_t which_port, pmt::pmt_t msg)
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/include/gnuradio/block_registry.h gnuradio-maint-3.8/gnuradio-runtime/include/gnuradio/block_registry.h
--- gnuradio-3.8.0.0/gnuradio-runtime/include/gnuradio/block_registry.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/include/gnuradio/block_registry.h	2020-01-05 09:47:33.000000000 +0700
@@ -25,6 +25,7 @@
 
 #include <gnuradio/api.h>
 #include <gnuradio/basic_block.h>
+#include <gnuradio/thread/thread.h>
 #include <map>
 
 namespace gr {
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/include/gnuradio/pycallback_object.h gnuradio-maint-3.8/gnuradio-runtime/include/gnuradio/pycallback_object.h
--- gnuradio-3.8.0.0/gnuradio-runtime/include/gnuradio/pycallback_object.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/include/gnuradio/pycallback_object.h	2020-01-05 09:47:33.000000000 +0700
@@ -150,7 +150,7 @@
         return (dummy);
     };
 
-    std::vector<boost::any> d_rpc_vars; // container for all RPC variables
+    std::vector<rpcbasic_sptr> d_rpc_vars; // container for all RPC variables
     std::string d_name;
     int d_id;
 };
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/include/gnuradio/random.h gnuradio-maint-3.8/gnuradio-runtime/include/gnuradio/random.h
--- gnuradio-3.8.0.0/gnuradio-runtime/include/gnuradio/random.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/include/gnuradio/random.h	2020-01-05 09:47:33.000000000 +0700
@@ -96,7 +96,9 @@
     float rayleigh();
 
     /*!
-     * \brief FIXME: add description
+     * \brief Exponentially distributed random numbers with values less than or equal
+     * to factor replaced with zero. The underlying exponential distribution has
+     * mean sqrt(2) and variance 2.
      */
     float impulse(float factor);
 
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/include/gnuradio/rpcserver_aggregator.h gnuradio-maint-3.8/gnuradio-runtime/include/gnuradio/rpcserver_aggregator.h
--- gnuradio-3.8.0.0/gnuradio-runtime/include/gnuradio/rpcserver_aggregator.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/include/gnuradio/rpcserver_aggregator.h	2020-01-05 09:47:33.000000000 +0700
@@ -60,8 +60,8 @@
         }
 
         void operator()(T& x) { x->i()->registerConfigureCallback(id, callback); }
-        const std::string& id;
-        const Tcallback& callback;
+        const std::string id;
+        const Tcallback callback;
     };
 
     template <class T, typename Tcallback>
@@ -69,7 +69,7 @@
         unregisterConfigureCallback_f(const std::string& _id) : id(_id) { ; }
 
         void operator()(T& x) { x->i()->unregisterConfigureCallback(id); }
-        const std::string& id;
+        const std::string id;
     };
 
     template <class T, typename Tcallback>
@@ -81,8 +81,8 @@
         }
 
         void operator()(T& x) { x->i()->registerQueryCallback(id, callback); }
-        const std::string& id;
-        const Tcallback& callback;
+        const std::string id;
+        const Tcallback callback;
     };
 
     template <class T, typename Tcallback>
@@ -90,7 +90,7 @@
         unregisterQueryCallback_f(const std::string& _id) : id(_id) { ; }
 
         void operator()(T& x) { x->i()->unregisterQueryCallback(id); }
-        const std::string& id;
+        const std::string id;
     };
 
 
@@ -103,8 +103,8 @@
         }
 
         void operator()(T& x) { x->i()->registerHandlerCallback(id, callback); }
-        const std::string& id;
-        const Tcallback& callback;
+        const std::string id;
+        const Tcallback callback;
     };
 
     template <class T, typename Tcallback>
@@ -112,7 +112,7 @@
         unregisterHandlerCallback_f(const std::string& _id) : id(_id) { ; }
 
         void operator()(T& x) { x->i()->unregisterHandlerCallback(id); }
-        const std::string& id;
+        const std::string id;
     };
 
 
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/include/gnuradio/tag_checker.h gnuradio-maint-3.8/gnuradio-runtime/include/gnuradio/tag_checker.h
--- gnuradio-3.8.0.0/gnuradio-runtime/include/gnuradio/tag_checker.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/include/gnuradio/tag_checker.h	2020-01-05 09:47:33.000000000 +0700
@@ -41,7 +41,7 @@
     {
         d_tags = tags;
         std::sort(d_tags.begin(), d_tags.end(), &gr::tag_t::offset_compare);
-        if (d_tags.size() > 0) {
+        if (!d_tags.empty()) {
             d_has_next_tag = true;
             d_next_tag = tags[0];
         }
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/include/gnuradio/thrift_application_base.h gnuradio-maint-3.8/gnuradio-runtime/include/gnuradio/thrift_application_base.h
--- gnuradio-3.8.0.0/gnuradio-runtime/include/gnuradio/thrift_application_base.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/include/gnuradio/thrift_application_base.h	2020-01-05 09:47:33.000000000 +0700
@@ -53,13 +53,13 @@
 {
 public:
     thrift_application_base_impl()
-        : d_application_initilized(false), d_endpointStr(""), d_start_thrift_thread()
+        : d_application_initialized(false), d_endpointStr(""), d_start_thrift_thread()
     {
         ;
     }
 
     // Used to ensure the Thrift runtime is initialized on the first call to ::i().
-    bool d_application_initilized;
+    bool d_application_initialized;
     // Stores the generated endpoint string after the Thrift runtime has initialized.
     std::string d_endpointStr;
     // Thread to execute the Thrift runtime's blocking serve() function.
@@ -212,7 +212,7 @@
         static_cast<unsigned int>(gr::prefs::singleton()->get_long(
             "thrift", "init_attempts", d_default_max_init_attempts));
 
-    if (!p_impl->d_application_initilized) {
+    if (!p_impl->d_application_initialized) {
         p_impl->d_start_thrift_thread.reset((new gr::thread::thread(
             boost::bind(&thrift_application_base::start_thrift, d_application))));
 
@@ -230,7 +230,7 @@
                     "timeout waiting to port number might have failed?");
         }
 
-        p_impl->d_application_initilized = true;
+        p_impl->d_application_initialized = true;
     }
 }
 
@@ -254,7 +254,7 @@
 template <typename TserverBase, typename TserverClass>
 TserverBase* thrift_application_base<TserverBase, TserverClass>::i()
 {
-    if (!p_impl->d_application_initilized) {
+    if (!p_impl->d_application_initialized) {
         start_application();
     }
     return d_application->i_impl();
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/lib/block.cc gnuradio-maint-3.8/gnuradio-runtime/lib/block.cc
--- gnuradio-3.8.0.0/gnuradio-runtime/lib/block.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/lib/block.cc	2020-01-05 09:47:33.000000000 +0700
@@ -667,26 +667,26 @@
     d_pc_rpc_set = true;
 #if defined(GR_CTRLPORT) && defined(GR_PERFORMANCE_COUNTERS)
 #include <gnuradio/rpcregisterhelpers.h>
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_trigger<block>(alias(),
                                              "reset_perf_counters",
                                              &block::reset_perf_counters,
                                              "Reset the Performance Counters",
-                                             RPC_PRIVLVL_MIN)));
+                                             RPC_PRIVLVL_MIN));
 
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, float>(alias(),
-                                                              "noutput_items",
-                                                              &block::pc_noutput_items,
-                                                              pmt::mp(0),
-                                                              pmt::mp(32768),
-                                                              pmt::mp(0),
-                                                              "",
-                                                              "noutput items",
-                                                              RPC_PRIVLVL_MIN,
-                                                              DISPTIME | DISPOPTSTRIP)));
+    d_rpc_vars.emplace_back(
+        new rpcbasic_register_get<block, float>(alias(),
+                                                "noutput_items",
+                                                &block::pc_noutput_items,
+                                                pmt::mp(0),
+                                                pmt::mp(32768),
+                                                pmt::mp(0),
+                                                "",
+                                                "noutput items",
+                                                RPC_PRIVLVL_MIN,
+                                                DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<block, float>(alias(),
                                                 "avg noutput_items",
                                                 &block::pc_noutput_items_avg,
@@ -696,9 +696,9 @@
                                                 "",
                                                 "Average noutput items",
                                                 RPC_PRIVLVL_MIN,
-                                                DISPTIME | DISPOPTSTRIP)));
+                                                DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<block, float>(alias(),
                                                 "var noutput_items",
                                                 &block::pc_noutput_items_var,
@@ -708,45 +708,45 @@
                                                 "",
                                                 "Var. noutput items",
                                                 RPC_PRIVLVL_MIN,
-                                                DISPTIME | DISPOPTSTRIP)));
+                                                DISPTIME | DISPOPTSTRIP));
+
+    d_rpc_vars.emplace_back(
+        new rpcbasic_register_get<block, float>(alias(),
+                                                "nproduced",
+                                                &block::pc_nproduced,
+                                                pmt::mp(0),
+                                                pmt::mp(32768),
+                                                pmt::mp(0),
+                                                "",
+                                                "items produced",
+                                                RPC_PRIVLVL_MIN,
+                                                DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, float>(alias(),
-                                                              "nproduced",
-                                                              &block::pc_nproduced,
-                                                              pmt::mp(0),
-                                                              pmt::mp(32768),
-                                                              pmt::mp(0),
-                                                              "",
-                                                              "items produced",
-                                                              RPC_PRIVLVL_MIN,
-                                                              DISPTIME | DISPOPTSTRIP)));
-
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, float>(alias(),
-                                                              "avg nproduced",
-                                                              &block::pc_nproduced_avg,
-                                                              pmt::mp(0),
-                                                              pmt::mp(32768),
-                                                              pmt::mp(0),
-                                                              "",
-                                                              "Average items produced",
-                                                              RPC_PRIVLVL_MIN,
-                                                              DISPTIME | DISPOPTSTRIP)));
-
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, float>(alias(),
-                                                              "var nproduced",
-                                                              &block::pc_nproduced_var,
-                                                              pmt::mp(0),
-                                                              pmt::mp(32768),
-                                                              pmt::mp(0),
-                                                              "",
-                                                              "Var. items produced",
-                                                              RPC_PRIVLVL_MIN,
-                                                              DISPTIME | DISPOPTSTRIP)));
+    d_rpc_vars.emplace_back(
+        new rpcbasic_register_get<block, float>(alias(),
+                                                "avg nproduced",
+                                                &block::pc_nproduced_avg,
+                                                pmt::mp(0),
+                                                pmt::mp(32768),
+                                                pmt::mp(0),
+                                                "",
+                                                "Average items produced",
+                                                RPC_PRIVLVL_MIN,
+                                                DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
+        new rpcbasic_register_get<block, float>(alias(),
+                                                "var nproduced",
+                                                &block::pc_nproduced_var,
+                                                pmt::mp(0),
+                                                pmt::mp(32768),
+                                                pmt::mp(0),
+                                                "",
+                                                "Var. items produced",
+                                                RPC_PRIVLVL_MIN,
+                                                DISPTIME | DISPOPTSTRIP));
+
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<block, float>(alias(),
                                                 "work time",
                                                 &block::pc_work_time,
@@ -756,9 +756,9 @@
                                                 "",
                                                 "clock cycles in call to work",
                                                 RPC_PRIVLVL_MIN,
-                                                DISPTIME | DISPOPTSTRIP)));
+                                                DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<block, float>(alias(),
                                                 "avg work time",
                                                 &block::pc_work_time_avg,
@@ -768,9 +768,9 @@
                                                 "",
                                                 "Average clock cycles in call to work",
                                                 RPC_PRIVLVL_MIN,
-                                                DISPTIME | DISPOPTSTRIP)));
+                                                DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<block, float>(alias(),
                                                 "var work time",
                                                 &block::pc_work_time_var,
@@ -780,9 +780,9 @@
                                                 "",
                                                 "Var. clock cycles in call to work",
                                                 RPC_PRIVLVL_MIN,
-                                                DISPTIME | DISPOPTSTRIP)));
+                                                DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<block, float>(alias(),
                                                 "total work time",
                                                 &block::pc_work_time_total,
@@ -792,9 +792,9 @@
                                                 "",
                                                 "Total clock cycles in calls to work",
                                                 RPC_PRIVLVL_MIN,
-                                                DISPTIME | DISPOPTSTRIP)));
+                                                DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(new rpcbasic_register_get<block, float>(
+    d_rpc_vars.emplace_back(new rpcbasic_register_get<block, float>(
         alias(),
         "avg throughput",
         &block::pc_throughput_avg,
@@ -804,85 +804,79 @@
         "items/s",
         "Average items throughput in call to work",
         RPC_PRIVLVL_MIN,
-        DISPTIME | DISPOPTSTRIP)));
+        DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, std::vector<float>>(
-            alias(),
-            "input \% full",
-            &block::pc_input_buffers_full,
-            pmt::make_f32vector(0, 0),
-            pmt::make_f32vector(0, 1),
-            pmt::make_f32vector(0, 0),
-            "",
-            "how full input buffers are",
-            RPC_PRIVLVL_MIN,
-            DISPTIME | DISPOPTSTRIP)));
-
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, std::vector<float>>(
-            alias(),
-            "avg input \% full",
-            &block::pc_input_buffers_full_avg,
-            pmt::make_f32vector(0, 0),
-            pmt::make_f32vector(0, 1),
-            pmt::make_f32vector(0, 0),
-            "",
-            "Average of how full input buffers are",
-            RPC_PRIVLVL_MIN,
-            DISPTIME | DISPOPTSTRIP)));
-
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, std::vector<float>>(
-            alias(),
-            "var input \% full",
-            &block::pc_input_buffers_full_var,
-            pmt::make_f32vector(0, 0),
-            pmt::make_f32vector(0, 1),
-            pmt::make_f32vector(0, 0),
-            "",
-            "Var. of how full input buffers are",
-            RPC_PRIVLVL_MIN,
-            DISPTIME | DISPOPTSTRIP)));
-
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, std::vector<float>>(
-            alias(),
-            "output \% full",
-            &block::pc_output_buffers_full,
-            pmt::make_f32vector(0, 0),
-            pmt::make_f32vector(0, 1),
-            pmt::make_f32vector(0, 0),
-            "",
-            "how full output buffers are",
-            RPC_PRIVLVL_MIN,
-            DISPTIME | DISPOPTSTRIP)));
-
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, std::vector<float>>(
-            alias(),
-            "avg output \% full",
-            &block::pc_output_buffers_full_avg,
-            pmt::make_f32vector(0, 0),
-            pmt::make_f32vector(0, 1),
-            pmt::make_f32vector(0, 0),
-            "",
-            "Average of how full output buffers are",
-            RPC_PRIVLVL_MIN,
-            DISPTIME | DISPOPTSTRIP)));
-
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, std::vector<float>>(
-            alias(),
-            "var output \% full",
-            &block::pc_output_buffers_full_var,
-            pmt::make_f32vector(0, 0),
-            pmt::make_f32vector(0, 1),
-            pmt::make_f32vector(0, 0),
-            "",
-            "Var. of how full output buffers are",
-            RPC_PRIVLVL_MIN,
-            DISPTIME | DISPOPTSTRIP)));
+    d_rpc_vars.emplace_back(new rpcbasic_register_get<block, std::vector<float>>(
+        alias(),
+        "input \% full",
+        &block::pc_input_buffers_full,
+        pmt::make_f32vector(0, 0),
+        pmt::make_f32vector(0, 1),
+        pmt::make_f32vector(0, 0),
+        "",
+        "how full input buffers are",
+        RPC_PRIVLVL_MIN,
+        DISPTIME | DISPOPTSTRIP));
+
+    d_rpc_vars.emplace_back(new rpcbasic_register_get<block, std::vector<float>>(
+        alias(),
+        "avg input \% full",
+        &block::pc_input_buffers_full_avg,
+        pmt::make_f32vector(0, 0),
+        pmt::make_f32vector(0, 1),
+        pmt::make_f32vector(0, 0),
+        "",
+        "Average of how full input buffers are",
+        RPC_PRIVLVL_MIN,
+        DISPTIME | DISPOPTSTRIP));
+
+    d_rpc_vars.emplace_back(new rpcbasic_register_get<block, std::vector<float>>(
+        alias(),
+        "var input \% full",
+        &block::pc_input_buffers_full_var,
+        pmt::make_f32vector(0, 0),
+        pmt::make_f32vector(0, 1),
+        pmt::make_f32vector(0, 0),
+        "",
+        "Var. of how full input buffers are",
+        RPC_PRIVLVL_MIN,
+        DISPTIME | DISPOPTSTRIP));
+
+    d_rpc_vars.emplace_back(new rpcbasic_register_get<block, std::vector<float>>(
+        alias(),
+        "output \% full",
+        &block::pc_output_buffers_full,
+        pmt::make_f32vector(0, 0),
+        pmt::make_f32vector(0, 1),
+        pmt::make_f32vector(0, 0),
+        "",
+        "how full output buffers are",
+        RPC_PRIVLVL_MIN,
+        DISPTIME | DISPOPTSTRIP));
+
+    d_rpc_vars.emplace_back(new rpcbasic_register_get<block, std::vector<float>>(
+        alias(),
+        "avg output \% full",
+        &block::pc_output_buffers_full_avg,
+        pmt::make_f32vector(0, 0),
+        pmt::make_f32vector(0, 1),
+        pmt::make_f32vector(0, 0),
+        "",
+        "Average of how full output buffers are",
+        RPC_PRIVLVL_MIN,
+        DISPTIME | DISPOPTSTRIP));
+
+    d_rpc_vars.emplace_back(new rpcbasic_register_get<block, std::vector<float>>(
+        alias(),
+        "var output \% full",
+        &block::pc_output_buffers_full_var,
+        pmt::make_f32vector(0, 0),
+        pmt::make_f32vector(0, 1),
+        pmt::make_f32vector(0, 0),
+        "",
+        "Var. of how full output buffers are",
+        RPC_PRIVLVL_MIN,
+        DISPTIME | DISPOPTSTRIP));
 #endif /* defined(GR_CTRLPORT) && defined(GR_PERFORMANCE_COUNTERS) */
 }
 
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/lib/block_detail.cc gnuradio-maint-3.8/gnuradio-runtime/lib/block_detail.cc
--- gnuradio-3.8.0.0/gnuradio-runtime/lib/block_detail.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/lib/block_detail.cc	2020-01-05 09:47:33.000000000 +0700
@@ -231,9 +231,8 @@
     if (threaded) {
         try {
             gr::thread::thread_bind_to_processor(thread, mask);
-        } catch (std::runtime_error e) {
+        } catch (std::runtime_error& e) {
             std::cerr << "set_processor_affinity: invalid mask." << std::endl;
-            ;
         }
     }
 }
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/lib/block_executor.cc gnuradio-maint-3.8/gnuradio-runtime/lib/block_executor.cc
--- gnuradio-3.8.0.0/gnuradio-runtime/lib/block_executor.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/lib/block_executor.cc	2020-01-05 09:47:33.000000000 +0700
@@ -124,10 +124,11 @@
             d->get_tags_in_range(
                 rtags, i, start_nitems_read[i], d->nitems_read(i), block_id);
 
-            if (rtags.size() == 0)
+            if (rtags.empty()) {
                 continue;
+            }
 
-            if (out_buf.size() == 0) {
+            if (out_buf.empty()) {
                 out_buf.reserve(d->noutputs());
                 for (int o = 0; o < d->noutputs(); o++)
                     out_buf.push_back(d->output(o));
@@ -176,8 +177,9 @@
                 d->get_tags_in_range(
                     rtags, i, start_nitems_read[i], d->nitems_read(i), block_id);
 
-                if (rtags.size() == 0)
+                if (rtags.empty()) {
                     continue;
+                }
 
                 out_buf = d->output(i);
 
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/lib/flowgraph.cc gnuradio-maint-3.8/gnuradio-runtime/lib/flowgraph.cc
--- gnuradio-3.8.0.0/gnuradio-runtime/lib/flowgraph.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/lib/flowgraph.cc	2020-01-05 09:47:33.000000000 +0700
@@ -328,7 +328,7 @@
     basic_block_vector_t blocks = calc_used_blocks();
     basic_block_vector_t graph;
 
-    while (blocks.size() > 0) {
+    while (!blocks.empty()) {
         graph = calc_reachable_blocks(blocks[0], blocks);
         assert(graph.size());
         result.push_back(topological_sort(graph));
@@ -432,7 +432,7 @@
 
 bool flowgraph::source_p(basic_block_sptr block)
 {
-    return (calc_upstream_edges(block).size() == 0);
+    return calc_upstream_edges(block).empty();
 }
 
 void flowgraph::topological_dfs_visit(basic_block_sptr block,
@@ -491,6 +491,7 @@
 {
     basic_block_vector_t blocks = fg->calc_used_blocks();
     edge_vector_t edges = fg->edges();
+    msg_edge_vector_t msg_edges = fg->msg_edges();
 
     std::stringstream out;
 
@@ -498,7 +499,7 @@
 
     // Define nodes and set labels
     for (basic_block_viter_t block = blocks.begin(); block != blocks.end(); ++block) {
-        out << (*block)->unique_id() << " [ label=\"" << (*block)->name() << "\" ]"
+        out << (*block)->unique_id() << " [ label=\"" << (*block)->alias() << "\" ]"
             << std::endl;
     }
 
@@ -508,6 +509,11 @@
             << edge->dst().block()->unique_id() << std::endl;
     }
 
+    for (msg_edge_viter_t edge = msg_edges.begin(); edge != msg_edges.end(); edge++) {
+        out << edge->src().block()->unique_id() << " -> "
+            << edge->dst().block()->unique_id() << " [color=blue]" << std::endl;
+    }
+
     out << "}" << std::endl;
 
     return out.str();
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/lib/hier_block2.cc gnuradio-maint-3.8/gnuradio-runtime/lib/hier_block2.cc
--- gnuradio-3.8.0.0/gnuradio-runtime/lib/hier_block2.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/lib/hier_block2.cc	2020-01-05 09:47:33.000000000 +0700
@@ -171,9 +171,10 @@
 void hier_block2::set_max_output_buffer(int max_output_buffer)
 {
     if (output_signature()->max_streams() > 0) {
-        if (d_detail->d_max_output_buffer.size() == 0)
+        if (d_detail->d_max_output_buffer.empty()) {
             throw std::length_error("hier_block2::set_max_output_buffer(int): out_sig "
                                     "greater than zero, buff_vect isn't");
+        }
         for (int idx = 0; idx < output_signature()->max_streams(); idx++) {
             d_detail->d_max_output_buffer[idx] = max_output_buffer;
         }
@@ -182,10 +183,10 @@
 
 void hier_block2::set_max_output_buffer(size_t port, int max_output_buffer)
 {
-    if (port >= d_detail->d_max_output_buffer.size())
+    if (port >= d_detail->d_max_output_buffer.size()) {
         throw std::invalid_argument(
             "hier_block2::set_max_output_buffer(size_t,int): port out of range.");
-    else {
+    } else {
         d_detail->d_max_output_buffer[port] = max_output_buffer;
     }
 }
@@ -201,9 +202,10 @@
 void hier_block2::set_min_output_buffer(int min_output_buffer)
 {
     if (output_signature()->max_streams() > 0) {
-        if (d_detail->d_min_output_buffer.size() == 0)
+        if (d_detail->d_min_output_buffer.empty()) {
             throw std::length_error("hier_block2::set_min_output_buffer(int): out_sig "
                                     "greater than zero, buff_vect isn't");
+        }
         for (int idx = 0; idx < output_signature()->max_streams(); idx++) {
             d_detail->d_min_output_buffer[idx] = min_output_buffer;
         }
@@ -222,8 +224,9 @@
 
 bool hier_block2::all_min_output_buffer_p(void)
 {
-    if (!d_detail->d_min_output_buffer.size())
+    if (d_detail->d_min_output_buffer.empty()) {
         return false;
+    }
     for (size_t idx = 1; idx < d_detail->d_min_output_buffer.size(); idx++) {
         if (d_detail->d_min_output_buffer[0] != d_detail->d_min_output_buffer[idx])
             return false;
@@ -232,7 +235,7 @@
 }
 bool hier_block2::all_max_output_buffer_p(void)
 {
-    if (!d_detail->d_max_output_buffer.size())
+    if (d_detail->d_max_output_buffer.empty())
         return false;
     for (size_t idx = 1; idx < d_detail->d_max_output_buffer.size(); idx++) {
         if (d_detail->d_max_output_buffer[0] != d_detail->d_max_output_buffer[idx])
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/lib/hier_block2_detail.cc gnuradio-maint-3.8/gnuradio-runtime/lib/hier_block2_detail.cc
--- gnuradio-3.8.0.0/gnuradio-runtime/lib/hier_block2_detail.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/lib/hier_block2_detail.cc	2020-01-05 09:47:33.000000000 +0700
@@ -288,7 +288,7 @@
         }
     }
 
-    if (edges.size() == 0) {
+    if (edges.empty()) {
         std::stringstream msg;
         msg << "cannot disconnect block " << block << ", not found";
         throw std::invalid_argument(msg.str());
@@ -560,7 +560,7 @@
     edge_vector_t edges = d_fg->edges();
     msg_edge_vector_t msg_edges = d_fg->msg_edges();
     edge_viter_t p;
-    msg_edge_viter_t q, u;
+    msg_edge_viter_t q;
 
     // Only run setup_rpc if ControlPort config param is enabled.
     bool ctrlport_on = prefs::singleton()->get_bool("ControlPort", "on", false);
@@ -784,7 +784,7 @@
     // Now add the list of connected input blocks
     std::stringstream msg;
     for (unsigned int i = 0; i < d_inputs.size(); i++) {
-        if (d_inputs[i].size() == 0) {
+        if (d_inputs[i].empty()) {
             msg << "In hierarchical block " << d_owner->name() << ", input " << i
                 << " is not connected internally";
             throw std::runtime_error(msg.str());
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/lib/io_signature.cc gnuradio-maint-3.8/gnuradio-runtime/lib/io_signature.cc
--- gnuradio-3.8.0.0/gnuradio-runtime/lib/io_signature.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/lib/io_signature.cc	2020-01-05 09:47:33.000000000 +0700
@@ -79,8 +79,9 @@
     if (min_streams < 0 || (max_streams != IO_INFINITE && max_streams < min_streams))
         throw std::invalid_argument("gr::io_signature(1)");
 
-    if (sizeof_stream_items.size() < 1)
+    if (sizeof_stream_items.empty()) {
         throw std::invalid_argument("gr::io_signature(2)");
+    }
 
     for (size_t i = 0; i < sizeof_stream_items.size(); i++) {
         if (max_streams != 0 && sizeof_stream_items[i] < 1)
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/lib/logger.cc gnuradio-maint-3.8/gnuradio-runtime/lib/logger.cc
--- gnuradio-3.8.0.0/gnuradio-runtime/lib/logger.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/lib/logger.cc	2020-01-05 09:47:33.000000000 +0700
@@ -157,7 +157,7 @@
 
 bool logger_load_config(const std::string& config_filename)
 {
-    if (config_filename.size() != 0) {
+    if (!config_filename.empty()) {
         try {
             log4cpp::PropertyConfigurator::configure(config_filename);
             return true;
@@ -263,7 +263,10 @@
 {
     log4cpp::PatternLayout* layout = new log4cpp::PatternLayout();
     log4cpp::Appender* app =
-        new log4cpp::FileAppender("FileAppender::" + filename, filename);
+        new log4cpp::FileAppender(
+            "FileAppender::" + filename,
+            filename,
+            append);
     layout->setConversionPattern(pattern);
     app->setLayout(layout);
     logger->setAppender(app);
@@ -343,7 +346,7 @@
     GR_LOG_GETLOGGER(LOG, "gr_log." + name);
     GR_LOG_SET_LEVEL(LOG, log_level);
 
-    if (log_file.size() > 0) {
+    if (!log_file.empty()) {
         if (log_file == "stdout") {
             GR_LOG_SET_CONSOLE_APPENDER(LOG, "stdout", "gr::log :%p: %c{1} - %m%n");
         } else if (log_file == "stderr") {
@@ -356,7 +359,7 @@
 
     GR_LOG_GETLOGGER(DLOG, "gr_log_debug." + name);
     GR_LOG_SET_LEVEL(DLOG, debug_level);
-    if (debug_file.size() > 0) {
+    if (!debug_file.empty()) {
         if (debug_file == "stdout") {
             GR_LOG_SET_CONSOLE_APPENDER(DLOG, "stdout", "gr::debug :%p: %c{1} - %m%n");
         } else if (debug_file == "stderr") {
@@ -376,7 +379,7 @@
     std::string debug_file = p->get_string("LOG", "debug_file", "");
 
     GR_LOG_GETLOGGER(LOG, "gr_log." + name);
-    if (log_file.size() > 0) {
+    if (!log_file.empty()) {
         if (log_file == "stdout") {
             boost::format str("gr::log :%%p: %1% - %%m%%n");
             GR_LOG_SET_CONSOLE_APPENDER(LOG, "stdout", boost::str(str % alias));
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/lib/math/gen_sine_table.py gnuradio-maint-3.8/gnuradio-runtime/lib/math/gen_sine_table.py
--- gnuradio-3.8.0.0/gnuradio-runtime/lib/math/gen_sine_table.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/lib/math/gen_sine_table.py	2020-01-05 09:47:33.000000000 +0700
@@ -20,7 +20,6 @@
 # Boston, MA 02110-1301, USA.
 #
 
-from __future__ import division
 from __future__ import unicode_literals
 import math
 import sys
@@ -41,7 +40,7 @@
         a = (i * incx) + min_x
         b = ((i + 1) * incx) + min_x
         m = (f(b)-f(a)) / (b-a)
-        c = (3*a+b)*(f(a)-f(b))/(4*(b-a)) + (f((a+b)/2) + f(a))//2
+        c = (3.0*a+b)*(f(a)-f(b))/(4.0*(b-a)) + (f((a+b)/2.0) + f(a))/2.0
         abs_error = c+m*a-f(a)
         r.append ((m, c, abs_error))
     return r
@@ -71,7 +70,7 @@
     # sys.stdout.write ('static const double sine_table[%d][2] = {\n'% (nentries,))
 
     for e in t:
-        sys.stdout.write ('  { %22.15e, %22.15e },\n' % (2 * e[0], e[1]))
+        sys.stdout.write ('  { %22.15e, %22.15e },\n' % (2.0 * e[0], e[1]))
 
     # sys.stdout.write ('};\n')
 
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/lib/prefs.cc gnuradio-maint-3.8/gnuradio-runtime/lib/prefs.cc
--- gnuradio-3.8.0.0/gnuradio-runtime/lib/prefs.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/lib/prefs.cc	2020-01-05 09:47:33.000000000 +0700
@@ -110,7 +110,7 @@
                     std::string value = o.value[0];
                     d_config_map[section][key] = value;
                 }
-            } catch (std::exception e) {
+            } catch (std::exception& e) {
                 std::cerr << "WARNING: Config file '" << fname
                           << "' failed to parse:" << std::endl;
                 std::cerr << e.what() << std::endl;
@@ -243,7 +243,7 @@
 {
     if (has_option(section, option)) {
         std::string str = get_string(section, option, "");
-        if (str == "") {
+        if (str.empty()) {
             return default_val;
         }
         std::transform(str.begin(), str.end(), str.begin(), ::tolower);
@@ -281,7 +281,7 @@
 {
     if (has_option(section, option)) {
         std::string str = get_string(section, option, "");
-        if (str == "") {
+        if (str.empty()) {
             return default_val;
         }
         std::stringstream sstr(str);
@@ -316,7 +316,7 @@
 {
     if (has_option(section, option)) {
         std::string str = get_string(section, option, "");
-        if (str == "") {
+        if (str.empty()) {
             return default_val;
         }
         std::stringstream sstr(str);
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/lib/top_block.cc gnuradio-maint-3.8/gnuradio-runtime/lib/top_block.cc
--- gnuradio-3.8.0.0/gnuradio-runtime/lib/top_block.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/lib/top_block.cc	2020-01-05 09:47:33.000000000 +0700
@@ -109,14 +109,14 @@
         return;
 
     // Triggers
-    d_rpc_vars.push_back(rpcbasic_sptr(new rpcbasic_register_trigger<top_block>(
-        alias(), "stop", &top_block::stop, "Stop the flowgraph", RPC_PRIVLVL_MIN)));
+    d_rpc_vars.emplace_back(new rpcbasic_register_trigger<top_block>(
+        alias(), "stop", &top_block::stop, "Stop the flowgraph", RPC_PRIVLVL_MIN));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(new rpcbasic_register_trigger<top_block>(
-        alias(), "lock", &top_block::lock, "Lock the flowgraph", RPC_PRIVLVL_MIN)));
+    d_rpc_vars.emplace_back(new rpcbasic_register_trigger<top_block>(
+        alias(), "lock", &top_block::lock, "Lock the flowgraph", RPC_PRIVLVL_MIN));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(new rpcbasic_register_trigger<top_block>(
-        alias(), "unlock", &top_block::unlock, "Unock the flowgraph", RPC_PRIVLVL_MIN)));
+    d_rpc_vars.emplace_back(new rpcbasic_register_trigger<top_block>(
+        alias(), "unlock", &top_block::unlock, "Unock the flowgraph", RPC_PRIVLVL_MIN));
 
     // Getters
     add_rpc_variable(rpcbasic_sptr(
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/lib/tpb_thread_body.cc gnuradio-maint-3.8/gnuradio-runtime/lib/tpb_thread_body.cc
--- gnuradio-3.8.0.0/gnuradio-runtime/lib/tpb_thread_body.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/lib/tpb_thread_body.cc	2020-01-05 09:47:33.000000000 +0700
@@ -68,7 +68,7 @@
     GR_LOG_GETLOGGER(LOG, "gr_log.tpb_thread_body");
     GR_LOG_SET_LEVEL(LOG, log_level);
     GR_CONFIG_LOGGER(config_file);
-    if (log_file.size() > 0) {
+    if (!log_file.empty()) {
         if (log_file == "stdout") {
             GR_LOG_SET_CONSOLE_APPENDER(LOG, "stdout", "gr::log :%p: %c{1} - %m%n");
         } else if (log_file == "stderr") {
@@ -79,7 +79,7 @@
     }
 
     // Set thread affinity if it was set before fg was started.
-    if (block->processor_affinity().size() > 0) {
+    if (!block->processor_affinity().empty()) {
         gr::thread::thread_bind_to_processor(d->thread, block->processor_affinity());
     }
 
diff -uNr gnuradio-3.8.0.0/gnuradio-runtime/python/gnuradio/gr_unittest.py gnuradio-maint-3.8/gnuradio-runtime/python/gnuradio/gr_unittest.py
--- gnuradio-3.8.0.0/gnuradio-runtime/python/gnuradio/gr_unittest.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gnuradio-runtime/python/gnuradio/gr_unittest.py	2020-01-05 09:47:33.000000000 +0700
@@ -82,10 +82,10 @@
         places.0
         """
         self.assertEqual(len(a), len(b))
-        return all((
+        return all([
             self.assertComplexAlmostEqual(x, y, places, msg)
             for (x, y) in zip(a, b)
-        ))
+        ])
 
 
     def assertComplexTuplesAlmostEqual2(self, a, b,
@@ -95,10 +95,10 @@
         Approximate equality is determined by calling assertComplexAlmostEqual().
         """
         self.assertEqual(len(a), len(b))
-        return all((
+        return all([
             self.assertComplexAlmostEqual2(x, y, abs_eps, rel_eps, msg)
             for (x, y) in zip(a, b)
-        ))
+        ])
 
 
     def assertFloatTuplesAlmostEqual(self, a, b, places=7, msg=None):
@@ -108,19 +108,19 @@
         places.
         """
         self.assertEqual(len(a), len(b))
-        return all((
+        return all([
             self.assertAlmostEqual(x, y, places, msg)
             for (x, y) in zip(a, b)
-        ))
+        ])
 
 
     def assertFloatTuplesAlmostEqual2(self, a, b,
                                       abs_eps=1e-12, rel_eps=1e-6, msg=None):
         self.assertEqual(len(a), len(b))
-        return all((
+        return all([
             self.assertComplexAlmostEqual2(x, y, abs_eps, rel_eps, msg)
             for (x, y) in zip(a, b)
-        ))
+        ])
 
 TestResult = unittest.TestResult
 TestSuite = unittest.TestSuite
diff -uNr gnuradio-3.8.0.0/gr-analog/grc/analog_agc2_xx.block.yml gnuradio-maint-3.8/gr-analog/grc/analog_agc2_xx.block.yml
--- gnuradio-3.8.0.0/gr-analog/grc/analog_agc2_xx.block.yml	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-analog/grc/analog_agc2_xx.block.yml	2020-01-05 09:47:33.000000000 +0700
@@ -56,7 +56,7 @@
     declarations: 'analog::agc2_${type.fcn}::sptr ${id};'
     make: |-
         this->${id} = analog::agc2_${type.fcn}::make(${attack_rate}, ${decay_rate}, ${reference}, ${gain});
-        this->${id}.set_max_gain(${max_gain});
+        this->${id}->set_max_gain(${max_gain});
     callbacks:
     - set_attack_rate(${attack_rate})
     - set_decay_rate(${decay_rate})
diff -uNr gnuradio-3.8.0.0/gr-analog/grc/analog_agc3_xx.block.yml gnuradio-maint-3.8/gr-analog/grc/analog_agc3_xx.block.yml
--- gnuradio-3.8.0.0/gr-analog/grc/analog_agc3_xx.block.yml	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-analog/grc/analog_agc3_xx.block.yml	2020-01-05 09:47:33.000000000 +0700
@@ -60,7 +60,7 @@
     declarations: 'analog::agc3_${type.fcn}::sptr ${id};'
     make: |-
         this->${id} = analog::agc3_${type.fcn}::make(${attack_rate}, ${decay_rate}, ${reference}, ${gain}, ${iir_update_decim});
-        this->${id}.set_max_gain(${max_gain});
+        this->${id}->set_max_gain(${max_gain});
     callbacks:
     - set_attack_rate(${attack_rate})
     - set_decay_rate(${decay_rate})
diff -uNr gnuradio-3.8.0.0/gr-analog/grc/analog_agc_xx.block.yml gnuradio-maint-3.8/gr-analog/grc/analog_agc_xx.block.yml
--- gnuradio-3.8.0.0/gr-analog/grc/analog_agc_xx.block.yml	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-analog/grc/analog_agc_xx.block.yml	2020-01-05 09:47:33.000000000 +0700
@@ -51,7 +51,7 @@
     declarations: 'analog::agc_${type.fcn}::sptr ${id};'
     make: |-
         this->${id} = analog::agc_${type.fcn}::make(${rate}, ${reference}, ${gain});
-        this->${id}.set_max_gain(${max_gain});
+        this->${id}->set_max_gain(${max_gain});
     callbacks:
     - set_rate(${rate})
     - set_reference(${reference})
diff -uNr gnuradio-3.8.0.0/gr-analog/grc/analog_const_source_x.block.yml gnuradio-maint-3.8/gr-analog/grc/analog_const_source_x.block.yml
--- gnuradio-3.8.0.0/gr-analog/grc/analog_const_source_x.block.yml	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-analog/grc/analog_const_source_x.block.yml	2020-01-05 09:47:33.000000000 +0700
@@ -27,7 +27,8 @@
     - set_offset(${const})
 
 cpp_templates:
-    includes: ['#include <gnuradio/analog/sig_source_${type.fcn}.h>']
+    includes: ['#include <gnuradio/analog/sig_source.h>']
+    declarations: 'analog::sig_source_${type.fcn}::sptr ${id};'
     make: 'this->${id} = analog::sig_source_${type.fcn}::make(0, analog::GR_CONST_WAVE, 0, 0, ${const});'
     callbacks:
     - set_offset(${const})
diff -uNr gnuradio-3.8.0.0/gr-analog/grc/analog_frequency_modulator_fc.block.yml gnuradio-maint-3.8/gr-analog/grc/analog_frequency_modulator_fc.block.yml
--- gnuradio-3.8.0.0/gr-analog/grc/analog_frequency_modulator_fc.block.yml	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-analog/grc/analog_frequency_modulator_fc.block.yml	2020-01-05 09:47:33.000000000 +0700
@@ -23,6 +23,7 @@
 
 cpp_templates:
     includes: ['#include <gnuradio/analog/frequency_modulator_fc.h>']
+    declarations: 'gr::analog::frequency_modulator_fc::sptr ${id};'
     make: 'this->${id} = analog::frequency_modulator_fc::make(${sensitivity});'
     callbacks:
     - set_sensitivity(${sensitivity})
diff -uNr gnuradio-3.8.0.0/gr-analog/grc/analog_pwr_squelch_xx.block.yml gnuradio-maint-3.8/gr-analog/grc/analog_pwr_squelch_xx.block.yml
--- gnuradio-3.8.0.0/gr-analog/grc/analog_pwr_squelch_xx.block.yml	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-analog/grc/analog_pwr_squelch_xx.block.yml	2020-01-05 09:47:33.000000000 +0700
@@ -53,4 +53,18 @@
         True: true
         False: false
 
+documentation: |-
+    This will either pass the input unchanged or block it, depending on
+    whether its envelope is over a certain threshold. The envelope is calculated
+    by taking the squared magnitude of the signal and lowpassing it with a
+    single pole IIR filter (with the specified alpha).
+
+    The ramp parameter specifies the attack / release time, in samples.
+    A sinusodial ramp is used to progressively mute / unmute the input.
+    If ramp is set to 0, input is muted / unmuted without a ramp.
+
+    For realtime applications you'll want to set the gate parameter to
+    false, which produces zeros when the input is muted. If it is true,
+    the block will stop producing samples when in muted state.
+
 file_format: 1
diff -uNr gnuradio-3.8.0.0/gr-analog/grc/analog_wfm_tx.block.yml gnuradio-maint-3.8/gr-analog/grc/analog_wfm_tx.block.yml
--- gnuradio-3.8.0.0/gr-analog/grc/analog_wfm_tx.block.yml	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-analog/grc/analog_wfm_tx.block.yml	2020-01-05 09:47:33.000000000 +0700
@@ -1,6 +1,6 @@
 id: analog_wfm_tx
 label: WBFM Transmit
-flags: [ python ]
+flags: [ python, cpp ]
 
 parameters:
 -   id: audio_rate
@@ -38,4 +38,10 @@
     make: "analog.wfm_tx(\n\taudio_rate=${audio_rate},\n\tquad_rate=${quad_rate},\n\
         \ttau=${tau},\n\tmax_dev=${max_dev},\n\tfh=${fh},\n)"
 
+cpp_templates:
+    includes: [ '#include <gnuradio/analog/frequency_modulator_fc.h>', '#include <boost/math/constants/constants.hpp>' ]
+    declarations: gr::analog::frequency_modulator_fc::sptr ${id};
+    make: this->${id} = gr::analog::frequency_modulator_fc::make(2 * boost::math::constants::pi<double>() * ${max_dev} / ${quad_rate});
+    link: ['gnuradio-analog']          
+      
 file_format: 1
diff -uNr gnuradio-3.8.0.0/gr-analog/include/gnuradio/analog/ctcss_squelch_ff.h gnuradio-maint-3.8/gr-analog/include/gnuradio/analog/ctcss_squelch_ff.h
--- gnuradio-3.8.0.0/gr-analog/include/gnuradio/analog/ctcss_squelch_ff.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-analog/include/gnuradio/analog/ctcss_squelch_ff.h	2020-01-05 09:47:33.000000000 +0700
@@ -51,7 +51,8 @@
      * \param freq frequency value to use as the squelch tone.
      * \param level threshold level for the squelch tone.
      * \param len length of the frequency filters.
-     * \param ramp sets response characteristic.
+     * \param ramp attack / release time in samples; a sinusodial ramp
+     *             is used. set to 0 to disable.
      * \param gate if true, no output if no squelch tone.
      *             if false, output 0's if no squelch tone.
      */
diff -uNr gnuradio-3.8.0.0/gr-analog/include/gnuradio/analog/pwr_squelch_cc.h gnuradio-maint-3.8/gr-analog/include/gnuradio/analog/pwr_squelch_cc.h
--- gnuradio-3.8.0.0/gr-analog/include/gnuradio/analog/pwr_squelch_cc.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-analog/include/gnuradio/analog/pwr_squelch_cc.h	2020-01-05 09:47:33.000000000 +0700
@@ -49,7 +49,8 @@
      *
      * \param db threshold (in dB) for power squelch
      * \param alpha Gain of averaging filter. Defaults to 0.0001.
-     * \param ramp sets response characteristic. Defaults to 0.
+     * \param ramp attack / release time in samples; a sinusodial ramp
+     *             is used. set to 0 to disable.
      * \param gate if true, no output if no squelch tone.
      *             if false, output 0's if no squelch tone (default).
      *
diff -uNr gnuradio-3.8.0.0/gr-analog/include/gnuradio/analog/pwr_squelch_ff.h gnuradio-maint-3.8/gr-analog/include/gnuradio/analog/pwr_squelch_ff.h
--- gnuradio-3.8.0.0/gr-analog/include/gnuradio/analog/pwr_squelch_ff.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-analog/include/gnuradio/analog/pwr_squelch_ff.h	2020-01-05 09:47:33.000000000 +0700
@@ -49,7 +49,8 @@
      *
      * \param db threshold (in dB) for power squelch
      * \param alpha Gain of averaging filter. Defaults to 0.0001.
-     * \param ramp sets response characteristic. Defaults to 0.
+     * \param ramp attack / release time in samples; a sinusodial ramp
+     *             is used. set to 0 to disable.
      * \param gate if true, no output if no squelch tone.
      *             if false, output 0's if no squelch tone (default).
      *
diff -uNr gnuradio-3.8.0.0/gr-analog/python/analog/fm_demod.py gnuradio-maint-3.8/gr-analog/python/analog/fm_demod.py
--- gnuradio-3.8.0.0/gr-analog/python/analog/fm_demod.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-analog/python/analog/fm_demod.py	2020-01-05 09:47:33.000000000 +0700
@@ -110,5 +110,4 @@
         fm_demod_cf.__init__(self, channel_rate, audio_decim,
                              75000,  # Deviation
                              15000,  # Audio passband
-                             16000,  # Audio stopband
-                             20.0)   # Audio gain
+                             16000)  # Audio stopband
diff -uNr gnuradio-3.8.0.0/gr-analog/python/analog/qa_sig_source.py gnuradio-maint-3.8/gr-analog/python/analog/qa_sig_source.py
--- gnuradio-3.8.0.0/gr-analog/python/analog/qa_sig_source.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-analog/python/analog/qa_sig_source.py	2020-01-05 09:47:33.000000000 +0700
@@ -69,7 +69,7 @@
         tb.run()
         dst_data = dst1.data()
         self.assertEqual(expected_result, dst_data)
-        
+
     def test_sine_f(self):
         tb = self.tb
         sqrt2 = math.sqrt(2) / 2
@@ -97,7 +97,9 @@
         tb.connect(op, dst1)
         tb.run()
         dst_data = dst1.data()
-        self.assertFloatTuplesAlmostEqual(expected_result, dst_data)        
+        # Let the python know we are dealing with signed int behind scenes
+        dst_data_signed = [b if b < 127 else (256 - b) * -1 for b in dst_data]
+        self.assertFloatTuplesAlmostEqual(expected_result, dst_data_signed)
 
     def test_cosine_f(self):
         tb = self.tb
diff -uNr gnuradio-3.8.0.0/gr-analog/python/analog/wfm_rcv_fmdet.py gnuradio-maint-3.8/gr-analog/python/analog/wfm_rcv_fmdet.py
--- gnuradio-3.8.0.0/gr-analog/python/analog/wfm_rcv_fmdet.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-analog/python/analog/wfm_rcv_fmdet.py	2020-01-05 09:47:33.000000000 +0700
@@ -115,7 +115,7 @@
                                       stereo_carrier_filter_coeffs)
 
             # carrier is twice the picked off carrier so arrange to do
-            # a commplex multiply
+            # a complex multiply
             self.stereo_carrier_generator = blocks.multiply_cc();
 
             # Pick off the rds signal
diff -uNr gnuradio-3.8.0.0/gr-analog/python/analog/wfm_rcv_pll.py gnuradio-maint-3.8/gr-analog/python/analog/wfm_rcv_pll.py
--- gnuradio-3.8.0.0/gr-analog/python/analog/wfm_rcv_pll.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-analog/python/analog/wfm_rcv_pll.py	2020-01-05 09:47:33.000000000 +0700
@@ -106,7 +106,7 @@
             self.stereo_carrier_filter = \
                 filter.fir_filter_fcc(audio_decimation, stereo_carrier_filter_coeffs)
 
-            # carrier is twice the picked off carrier so arrange to do a commplex multiply
+            # carrier is twice the picked off carrier so arrange to do a complex multiply
 
             self.stereo_carrier_generator = blocks.multiply_cc();
 
diff -uNr gnuradio-3.8.0.0/gr-audio/lib/jack/jack_sink.cc gnuradio-maint-3.8/gr-audio/lib/jack/jack_sink.cc
--- gnuradio-3.8.0.0/gr-audio/lib/jack/jack_sink.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-audio/lib/jack/jack_sink.cc	2020-01-05 09:47:33.000000000 +0700
@@ -99,7 +99,6 @@
           "audio_jack_sink", io_signature::make(0, 0, 0), io_signature::make(0, 0, 0)),
       d_sampling_rate(sampling_rate),
       d_device_name(device_name.empty() ? default_device_name() : device_name),
-      d_ok_to_block(ok_to_block),
       d_jack_client(0),
       d_portcount(0),
       d_jack_output_port(),
diff -uNr gnuradio-3.8.0.0/gr-audio/lib/jack/jack_sink.h gnuradio-maint-3.8/gr-audio/lib/jack/jack_sink.h
--- gnuradio-3.8.0.0/gr-audio/lib/jack/jack_sink.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-audio/lib/jack/jack_sink.h	2020-01-05 09:47:33.000000000 +0700
@@ -52,7 +52,6 @@
 
     unsigned int d_sampling_rate;
     std::string d_device_name;
-    bool d_ok_to_block;
 
     jack_client_t* d_jack_client;
     static const int MAX_PORTS = 10;
diff -uNr gnuradio-3.8.0.0/gr-audio/lib/jack/jack_source.cc gnuradio-maint-3.8/gr-audio/lib/jack/jack_source.cc
--- gnuradio-3.8.0.0/gr-audio/lib/jack/jack_source.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-audio/lib/jack/jack_source.cc	2020-01-05 09:47:33.000000000 +0700
@@ -101,7 +101,6 @@
           "audio_jack_source", io_signature::make(0, 0, 0), io_signature::make(0, 0, 0)),
       d_sampling_rate(sampling_rate),
       d_device_name(device_name.empty() ? default_device_name() : device_name),
-      d_ok_to_block(ok_to_block),
       d_jack_client(0),
       d_portcount(0),
       d_jack_input_port(),
diff -uNr gnuradio-3.8.0.0/gr-audio/lib/jack/jack_source.h gnuradio-maint-3.8/gr-audio/lib/jack/jack_source.h
--- gnuradio-3.8.0.0/gr-audio/lib/jack/jack_source.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-audio/lib/jack/jack_source.h	2020-01-05 09:47:33.000000000 +0700
@@ -52,7 +52,6 @@
 
     unsigned int d_sampling_rate;
     std::string d_device_name;
-    bool d_ok_to_block;
 
     jack_client_t* d_jack_client;
     static const int MAX_PORTS = 10;
diff -uNr gnuradio-3.8.0.0/gr-audio/lib/portaudio/portaudio_source.cc gnuradio-maint-3.8/gr-audio/lib/portaudio/portaudio_source.cc
--- gnuradio-3.8.0.0/gr-audio/lib/portaudio/portaudio_source.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-audio/lib/portaudio/portaudio_source.cc	2020-01-05 09:47:33.000000000 +0700
@@ -106,7 +106,7 @@
 
         // copy from input buffer to ringbuffer
         {
-            gr::thread::scoped_lock(d_ringbuffer_mutex);
+            gr::thread::scoped_lock guard(self->d_ringbuffer_mutex);
 
             memcpy(self->d_writer->write_pointer(),
                    inputBuffer,
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/ctrlport_probe2_b_impl.cc gnuradio-maint-3.8/gr-blocks/lib/ctrlport_probe2_b_impl.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/ctrlport_probe2_b_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/ctrlport_probe2_b_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -116,7 +116,7 @@
 {
 #ifdef GR_CTRLPORT
     int len = static_cast<int>(d_len);
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe2_b, std::vector<signed char>>(
             alias(),
             d_id.c_str(),
@@ -127,9 +127,9 @@
             "volts",
             d_desc.c_str(),
             RPC_PRIVLVL_MIN,
-            d_disp_mask)));
+            d_disp_mask));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe2_b, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_b::length,
@@ -139,9 +139,9 @@
                                                           "samples",
                                                           "get vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_set<ctrlport_probe2_b, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_b::set_length,
@@ -151,7 +151,7 @@
                                                           "samples",
                                                           "set vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 #endif /* GR_CTRLPORT */
 }
 
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/ctrlport_probe2_c_impl.cc gnuradio-maint-3.8/gr-blocks/lib/ctrlport_probe2_c_impl.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/ctrlport_probe2_c_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/ctrlport_probe2_c_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -116,7 +116,7 @@
 {
 #ifdef GR_CTRLPORT
     int len = static_cast<int>(d_len);
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe2_c, std::vector<std::complex<float>>>(
             alias(),
             d_id.c_str(),
@@ -127,9 +127,9 @@
             "volts",
             d_desc.c_str(),
             RPC_PRIVLVL_MIN,
-            d_disp_mask | DISPOPTCPLX)));
+            d_disp_mask | DISPOPTCPLX));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe2_c, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_c::length,
@@ -139,9 +139,9 @@
                                                           "samples",
                                                           "get vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_set<ctrlport_probe2_c, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_c::set_length,
@@ -151,7 +151,7 @@
                                                           "samples",
                                                           "set vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 #endif /* GR_CTRLPORT */
 }
 
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/ctrlport_probe2_f_impl.cc gnuradio-maint-3.8/gr-blocks/lib/ctrlport_probe2_f_impl.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/ctrlport_probe2_f_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/ctrlport_probe2_f_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -116,8 +116,8 @@
 {
 #ifdef GR_CTRLPORT
     int len = static_cast<int>(d_len);
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<ctrlport_probe2_f, std::vector<float>>(
+    d_rpc_vars.emplace_back(
+        new rpcbasic_register_get<ctrlport_probe2_f, std::vector<float>>(
             alias(),
             d_id.c_str(),
             &ctrlport_probe2_f::get,
@@ -130,9 +130,9 @@
             "volts",
             d_desc.c_str(),
             RPC_PRIVLVL_MIN,
-            d_disp_mask)));
+            d_disp_mask));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe2_f, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_f::length,
@@ -142,9 +142,9 @@
                                                           "samples",
                                                           "get vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_set<ctrlport_probe2_f, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_f::set_length,
@@ -154,7 +154,7 @@
                                                           "samples",
                                                           "set vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 #endif /* GR_CTRLPORT */
 }
 
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/ctrlport_probe2_i_impl.cc gnuradio-maint-3.8/gr-blocks/lib/ctrlport_probe2_i_impl.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/ctrlport_probe2_i_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/ctrlport_probe2_i_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -115,8 +115,8 @@
 {
 #ifdef GR_CTRLPORT
     int len = static_cast<int>(d_len);
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<ctrlport_probe2_i, std::vector<int>>(
+    d_rpc_vars.emplace_back(
+        new rpcbasic_register_get<ctrlport_probe2_i, std::vector<int>>(
             alias(),
             d_id.c_str(),
             &ctrlport_probe2_i::get,
@@ -126,9 +126,9 @@
             "volts",
             d_desc.c_str(),
             RPC_PRIVLVL_MIN,
-            d_disp_mask)));
+            d_disp_mask));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe2_i, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_i::length,
@@ -138,9 +138,9 @@
                                                           "samples",
                                                           "get vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_set<ctrlport_probe2_i, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_i::set_length,
@@ -150,7 +150,7 @@
                                                           "samples",
                                                           "set vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 #endif /* GR_CTRLPORT */
 }
 
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/ctrlport_probe2_s_impl.cc gnuradio-maint-3.8/gr-blocks/lib/ctrlport_probe2_s_impl.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/ctrlport_probe2_s_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/ctrlport_probe2_s_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -115,8 +115,8 @@
 {
 #ifdef GR_CTRLPORT
     int len = static_cast<int>(d_len);
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<ctrlport_probe2_s, std::vector<short>>(
+    d_rpc_vars.emplace_back(
+        new rpcbasic_register_get<ctrlport_probe2_s, std::vector<short>>(
             alias(),
             d_id.c_str(),
             &ctrlport_probe2_s::get,
@@ -126,9 +126,9 @@
             "volts",
             d_desc.c_str(),
             RPC_PRIVLVL_MIN,
-            d_disp_mask)));
+            d_disp_mask));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe2_s, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_s::length,
@@ -138,9 +138,9 @@
                                                           "samples",
                                                           "get vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_set<ctrlport_probe2_s, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_s::set_length,
@@ -150,7 +150,7 @@
                                                           "samples",
                                                           "set vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 #endif /* GR_CTRLPORT */
 }
 
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/ctrlport_probe_c_impl.cc gnuradio-maint-3.8/gr-blocks/lib/ctrlport_probe_c_impl.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/ctrlport_probe_c_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/ctrlport_probe_c_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -81,7 +81,7 @@
 void ctrlport_probe_c_impl::setup_rpc()
 {
 #ifdef GR_CTRLPORT
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe_c, std::vector<std::complex<float>>>(
             alias(),
             d_id.c_str(),
@@ -92,7 +92,7 @@
             "volts",
             d_desc.c_str(),
             RPC_PRIVLVL_MIN,
-            DISPXY | DISPOPTSCATTER)));
+            DISPXY | DISPOPTSCATTER));
 #endif /* GR_CTRLPORT */
 }
 
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/file_meta_source_impl.cc gnuradio-maint-3.8/gr-blocks/lib/file_meta_source_impl.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/file_meta_source_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/file_meta_source_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -258,7 +258,7 @@
     bool ret = true;
     if (d_state == STATE_DETACHED) {
         std::string s;
-        if (hdr_filename == "")
+        if (hdr_filename.empty())
             s = filename + ".hdr";
         else
             s = hdr_filename;
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/multiply_matrix_impl.cc gnuradio-maint-3.8/gr-blocks/lib/multiply_matrix_impl.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/multiply_matrix_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/multiply_matrix_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -212,7 +212,7 @@
 multiply_matrix<T>::make(std::vector<std::vector<T>> A,
                          gr::block::tag_propagation_policy_t tag_propagation_policy)
 {
-    if (A.empty() || A[0].size() == 0) {
+    if (A.empty() || A[0].empty()) {
         throw std::invalid_argument("matrix A has invalid dimensions.");
     }
     return gnuradio::get_initial_sptr(
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/mute_impl.cc gnuradio-maint-3.8/gr-blocks/lib/mute_impl.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/mute_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/mute_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2004,2010,2013,2018 Free Software Foundation, Inc.
+ * Copyright 2004,2010,2013,2018,2019 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -28,6 +28,7 @@
 #include "mute_impl.h"
 #include <gnuradio/io_signature.h>
 #include <string.h>
+#include <algorithm>
 
 namespace gr {
 namespace blocks {
@@ -66,7 +67,7 @@
     int size = noutput_items;
 
     if (d_mute) {
-        memset(optr, 0, noutput_items * sizeof(T));
+        std::fill_n(optr, noutput_items, 0);
     } else {
         while (size >= 8) {
             *optr++ = *iptr++;
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/nop_impl.cc gnuradio-maint-3.8/gr-blocks/lib/nop_impl.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/nop_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/nop_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -69,19 +69,18 @@
 void nop_impl::setup_rpc()
 {
 #ifdef GR_CTRLPORT
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<nop, int>(alias(),
-                                                          "test",
-                                                          &nop::ctrlport_test,
-                                                          pmt::mp(-256),
-                                                          pmt::mp(255),
-                                                          pmt::mp(0),
-                                                          "",
-                                                          "Simple testing variable",
-                                                          RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+    d_rpc_vars.emplace_back(new rpcbasic_register_get<nop, int>(alias(),
+                                                                "test",
+                                                                &nop::ctrlport_test,
+                                                                pmt::mp(-256),
+                                                                pmt::mp(255),
+                                                                pmt::mp(0),
+                                                                "",
+                                                                "Simple testing variable",
+                                                                RPC_PRIVLVL_MIN,
+                                                                DISPNULL));
 
-    d_rpc_vars.push_back(
+    d_rpc_vars.emplace_back(
         rpcbasic_sptr(new rpcbasic_register_set<nop, int>(alias(),
                                                           "test",
                                                           &nop::set_ctrlport_test,
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/qa_gr_flowgraph.cc gnuradio-maint-3.8/gr-blocks/lib/qa_gr_flowgraph.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/qa_gr_flowgraph.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/qa_gr_flowgraph.cc	2020-01-05 09:47:33.000000000 +0700
@@ -269,8 +269,8 @@
 
     fg->clear();
 
-    BOOST_REQUIRE(fg->edges().size() == 0);
-    BOOST_REQUIRE(fg->calc_used_blocks().size() == 0);
+    BOOST_REQUIRE(fg->edges().empty());
+    BOOST_REQUIRE(fg->calc_used_blocks().empty());
 }
 
 BOOST_AUTO_TEST_CASE(t16_partition)
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/tag_debug_impl.cc gnuradio-maint-3.8/gr-blocks/lib/tag_debug_impl.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/tag_debug_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/tag_debug_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -71,7 +71,7 @@
 
 void tag_debug_impl::set_key_filter(const std::string& key_filter)
 {
-    if (key_filter == "")
+    if (key_filter.empty())
         d_filter = pmt::PMT_NIL;
     else
         d_filter = pmt::intern(key_filter);
@@ -104,7 +104,7 @@
         else
             get_tags_in_range(d_tags, i, abs_N, end_N, d_filter);
 
-        if (d_tags.size() > 0) {
+        if (!d_tags.empty()) {
             toprint = true;
         }
 
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/tag_gate_impl.cc gnuradio-maint-3.8/gr-blocks/lib/tag_gate_impl.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/tag_gate_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/tag_gate_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -64,7 +64,7 @@
 
 void tag_gate_impl::set_single_key(const std::string& single_key)
 {
-    if (single_key == "") {
+    if (single_key.empty()) {
         d_single_key = pmt::PMT_NIL;
         d_single_key_set = false;
     } else {
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/tagged_file_sink_impl.cc gnuradio-maint-3.8/gr-blocks/lib/tagged_file_sink_impl.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/tagged_file_sink_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/tagged_file_sink_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -94,7 +94,7 @@
     // Look for a time tag and initialize d_timeval.
     std::vector<tag_t> time_tags_outer;
     get_tags_in_range(time_tags_outer, 0, start_N, end_N, tkey);
-    if (time_tags_outer.size() > 0) {
+    if (!time_tags_outer.empty()) {
         const tag_t tag = time_tags_outer[0];
         uint64_t offset = tag.offset;
         pmt::pmt_t time = tag.value;
@@ -122,7 +122,7 @@
                     std::vector<tag_t> time_tags;
                     // get_tags_in_range(time_tags, 0, d_last_N, N, gr_tags::key_time);
                     get_tags_in_range(time_tags, 0, d_last_N, N, tkey);
-                    if (time_tags.size() > 0) {
+                    if (!time_tags.empty()) {
                         const tag_t tag = time_tags[time_tags.size() - 1];
 
                         uint64_t time_nitems = tag.offset;
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/tagged_stream_align_impl.cc gnuradio-maint-3.8/gr-blocks/lib/tagged_stream_align_impl.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/tagged_stream_align_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/tagged_stream_align_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -72,7 +72,7 @@
     } else {
         get_tags_in_range(
             tags, 0, nitems_read(0), nitems_read(0) + ninput_items[0], d_lengthtag);
-        if (tags.size() > 0) {
+        if (!tags.empty()) {
             d_have_sync = true;
             consume_each(tags[0].offset - nitems_read(0));
         } else {
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/throttle_impl.cc gnuradio-maint-3.8/gr-blocks/lib/throttle_impl.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/throttle_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/throttle_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -116,7 +116,7 @@
 void throttle_impl::setup_rpc()
 {
 #ifdef GR_CTRLPORT
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<throttle, double>(alias(),
                                                     "sample_rate",
                                                     &throttle::sample_rate,
@@ -126,9 +126,9 @@
                                                     "Hz",
                                                     "Sample Rate",
                                                     RPC_PRIVLVL_MIN,
-                                                    DISPTIME | DISPOPTSTRIP)));
+                                                    DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_set<throttle, double>(alias(),
                                                     "sample_rate",
                                                     &throttle::set_sample_rate,
@@ -138,7 +138,7 @@
                                                     "Hz",
                                                     "Sample Rate",
                                                     RPC_PRIVLVL_MIN,
-                                                    DISPTIME | DISPOPTSTRIP)));
+                                                    DISPTIME | DISPOPTSTRIP));
 #endif /* GR_CTRLPORT */
 }
 
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/udp_sink_impl.cc gnuradio-maint-3.8/gr-blocks/lib/udp_sink_impl.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/udp_sink_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/udp_sink_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -70,7 +70,7 @@
         disconnect();
 
     std::string s_port = (boost::format("%d") % port).str();
-    if (host.size() > 0) {
+    if (!host.empty()) {
         boost::asio::ip::udp::resolver resolver(d_io_service);
         boost::asio::ip::udp::resolver::query query(
             host, s_port, boost::asio::ip::resolver_query_base::passive);
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/udp_source_impl.cc gnuradio-maint-3.8/gr-blocks/lib/udp_source_impl.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/udp_source_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/udp_source_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -84,7 +84,7 @@
     std::string s_port;
     s_port = (boost::format("%d") % d_port).str();
 
-    if (host.size() > 0) {
+    if (!host.empty()) {
         boost::asio::ip::udp::resolver resolver(d_io_service);
         boost::asio::ip::udp::resolver::query query(
             d_host, s_port, boost::asio::ip::resolver_query_base::passive);
diff -uNr gnuradio-3.8.0.0/gr-blocks/lib/vector_source_impl.cc gnuradio-maint-3.8/gr-blocks/lib/vector_source_impl.cc
--- gnuradio-3.8.0.0/gr-blocks/lib/vector_source_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/lib/vector_source_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -57,7 +57,7 @@
       d_vlen(vlen),
       d_tags(tags)
 {
-    if (tags.size() == 0) {
+    if (tags.empty()) {
         d_settags = 0;
     } else {
         d_settags = 1;
@@ -79,7 +79,7 @@
     d_data = data;
     d_tags = tags;
     rewind();
-    if (tags.size() == 0) {
+    if (tags.empty()) {
         d_settags = false;
     } else {
         d_settags = true;
diff -uNr gnuradio-3.8.0.0/gr-blocks/python/blocks/qa_python_message_passing.py gnuradio-maint-3.8/gr-blocks/python/blocks/qa_python_message_passing.py
--- gnuradio-3.8.0.0/gr-blocks/python/blocks/qa_python_message_passing.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-blocks/python/blocks/qa_python_message_passing.py	2020-01-05 09:47:33.000000000 +0700
@@ -103,13 +103,7 @@
         self.assertEqual('in_port' in pmt.to_python(msg_cons.message_ports_in()), True)
 
         # Run to verify message passing
-        self.tb.start()
-
-        # Wait for all messages to be sent
-        while msg_gen.msg_ctr < num_msgs:
-            time.sleep(0.5)
-        self.tb.stop()
-        self.tb.wait()
+        self.tb.run()
 
         # Verify that the message consumer got all the messages
         self.assertEqual(num_msgs, len(msg_cons.msg_list))
diff -uNr gnuradio-3.8.0.0/gr-digital/grc/digital_symbol_sync_xx.block.yml gnuradio-maint-3.8/gr-digital/grc/digital_symbol_sync_xx.block.yml
--- gnuradio-3.8.0.0/gr-digital/grc/digital_symbol_sync_xx.block.yml	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-digital/grc/digital_symbol_sync_xx.block.yml	2020-01-05 09:47:33.000000000 +0700
@@ -19,7 +19,7 @@
     options: [digital.TED_MUELLER_AND_MULLER, digital.TED_MOD_MUELLER_AND_MULLER,
         digital.TED_ZERO_CROSSING, digital.TED_GARDNER, digital.TED_EARLY_LATE, digital.TED_DANDREA_AND_MENGALI_GEN_MSK,
         digital.TED_MENGALI_AND_DANDREA_GMSK, digital.TED_SIGNAL_TIMES_SLOPE_ML, digital.TED_SIGNUM_TIMES_SLOPE_ML]
-    option_labels: ["Mueller and M\xFCller", "Modified Mueller and M\xFCller", Zero
+    option_labels: ["Mueller and Mueller", "Modified Mueller and Mueller", Zero
             Crossing, Gardner, Early-Late, D'Andrea and Mengali Gen MSK, Mengali and
             D'Andrea GMSK, 'y[n]y''[n] Maximum Likelyhood', 'sgn(y[n])y''[n] Maximum
             Likelyhood']
@@ -61,8 +61,8 @@
     option_labels: ['MMSE, 8 tap FIR', 'Polyphase Filterbank, MMSE', 'Polyphase Filterbank,
             MF']
     option_attributes:
-        hide_nfilters: [all, '', '']
-        hide_pfb_mf_taps: [all, all, '']
+        hide_nfilters: [all, none, none]
+        hide_pfb_mf_taps: [all, all, none]
 -   id: nfilters
     label: Filterbank Arms
     dtype: int
diff -uNr gnuradio-3.8.0.0/gr-digital/lib/additive_scrambler_bb_impl.cc gnuradio-maint-3.8/gr-digital/lib/additive_scrambler_bb_impl.cc
--- gnuradio-3.8.0.0/gr-digital/lib/additive_scrambler_bb_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-digital/lib/additive_scrambler_bb_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -109,35 +109,19 @@
     unsigned char* out = (unsigned char*)output_items[0];
     int reset_index = _get_next_reset_index(noutput_items);
 
-    if (d_count >= 0) {
-        for (int i = 0; i < noutput_items; i++) {
-            unsigned char scramble_byte = 0x00;
-            for (int k = 0; k < d_bits_per_byte; k++) {
-                scramble_byte ^= (d_lfsr.next_bit() << k);
-            }
-            out[i] = in[i] ^ scramble_byte;
-            d_bytes++;
-            if (i == reset_index) {
-                d_lfsr.reset();
-                d_bytes = 0;
-                reset_index = _get_next_reset_index(noutput_items, reset_index);
-            }
+    for (int i = 0; i < noutput_items; i++) {
+        // Reset should occur at/before the item associated with the tag.
+        if (i == reset_index) {
+            d_lfsr.reset();
+            d_bytes = 0;
+            reset_index = _get_next_reset_index(noutput_items, reset_index);
         }
-    } else {
-        for (int i = 0; i < noutput_items; i++) {
-            // Reset should occur at/before the item associated with the tag.
-            if (i == reset_index) {
-                d_lfsr.reset();
-                d_bytes = 0;
-                reset_index = _get_next_reset_index(noutput_items, reset_index);
-            }
-            unsigned char scramble_byte = 0x00;
-            for (int k = 0; k < d_bits_per_byte; k++) {
-                scramble_byte ^= (d_lfsr.next_bit() << k);
-            }
-            out[i] = in[i] ^ scramble_byte;
-            d_bytes++;
+        unsigned char scramble_byte = 0x00;
+        for (int k = 0; k < d_bits_per_byte; k++) {
+            scramble_byte ^= (d_lfsr.next_bit() << k);
         }
+        out[i] = in[i] ^ scramble_byte;
+        d_bytes++;
     }
 
     return noutput_items;
diff -uNr gnuradio-3.8.0.0/gr-digital/lib/burst_shaper_impl.cc gnuradio-maint-3.8/gr-digital/lib/burst_shaper_impl.cc
--- gnuradio-3.8.0.0/gr-digital/lib/burst_shaper_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-digital/lib/burst_shaper_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2015,2018 Free Software Foundation, Inc.
+ * Copyright 2015,2018,2019 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -28,6 +28,7 @@
 #include <gnuradio/io_signature.h>
 #include <volk/volk.h>
 #include <boost/format.hpp>
+#include <algorithm>
 
 namespace gr {
 namespace digital {
@@ -220,7 +221,7 @@
 void burst_shaper_impl<T>::write_padding(T*& dst, int& nwritten, int nspace)
 {
     int nprocess = std::min(d_limit - d_index, nspace);
-    std::memset(dst, 0x00, nprocess * sizeof(T));
+    std::fill_n(dst, nprocess, 0x00);
     dst += nprocess;
     nwritten += nprocess;
     d_index += nprocess;
diff -uNr gnuradio-3.8.0.0/gr-digital/lib/constellation.cc gnuradio-maint-3.8/gr-digital/lib/constellation.cc
--- gnuradio-3.8.0.0/gr-digital/lib/constellation.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-digital/lib/constellation.cc	2020-01-05 09:47:33.000000000 +0700
@@ -69,7 +69,7 @@
             d_constellation[i] = d_constellation[i] * d_scalefactor;
         }
     }
-    if (pre_diff_code.size() == 0)
+    if (pre_diff_code.empty())
         d_apply_pre_diff_code = false;
     else if (pre_diff_code.size() != constsize)
         throw std::runtime_error(
@@ -307,7 +307,7 @@
     d_lut_scale = powf(2.0, static_cast<float>(precision));
 }
 
-bool constellation::has_soft_dec_lut() { return d_soft_dec_lut.size() > 0; }
+bool constellation::has_soft_dec_lut() { return !d_soft_dec_lut.empty(); }
 
 std::vector<std::vector<float>> constellation::soft_dec_lut() { return d_soft_dec_lut; }
 
diff -uNr gnuradio-3.8.0.0/gr-digital/lib/costas_loop_cc_impl.cc gnuradio-maint-3.8/gr-digital/lib/costas_loop_cc_impl.cc
--- gnuradio-3.8.0.0/gr-digital/lib/costas_loop_cc_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-digital/lib/costas_loop_cc_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -180,7 +180,7 @@
                       pmt::intern("phase_est"));
 
     for (int i = 0; i < noutput_items; i++) {
-        if (tags.size() > 0) {
+        if (!tags.empty()) {
             if (tags[0].offset - nitems_read(0) == (size_t)i) {
                 d_phase = (float)pmt::to_double(tags[0].value);
                 tags.erase(tags.begin());
diff -uNr gnuradio-3.8.0.0/gr-digital/lib/fll_band_edge_cc_impl.cc gnuradio-maint-3.8/gr-digital/lib/fll_band_edge_cc_impl.cc
--- gnuradio-3.8.0.0/gr-digital/lib/fll_band_edge_cc_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-digital/lib/fll_band_edge_cc_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -226,7 +226,6 @@
     float error;
     gr_complex nco_out;
     gr_complex out_upper, out_lower;
-    gr_complex out_uppersse, out_lowersse;
 
     for (i = 0; i < noutput_items; i++) {
         nco_out = gr_expj(d_phase);
diff -uNr gnuradio-3.8.0.0/gr-digital/lib/hdlc_framer_pb_impl.cc gnuradio-maint-3.8/gr-digital/lib/hdlc_framer_pb_impl.cc
--- gnuradio-3.8.0.0/gr-digital/lib/hdlc_framer_pb_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-digital/lib/hdlc_framer_pb_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -114,7 +114,7 @@
     // partial packets., but if we're to preserve tag boundaries
     // this is much, much simpler.
     int oidx = 0;
-    while (d_leftovers.size() > 0) {
+    while (!d_leftovers.empty()) {
         if ((size_t)noutput_items < (oidx + d_leftovers[0].size()))
             return oidx;
         memcpy(out + oidx, &d_leftovers[0][0], d_leftovers[0].size());
diff -uNr gnuradio-3.8.0.0/gr-digital/lib/map_bb_impl.cc gnuradio-maint-3.8/gr-digital/lib/map_bb_impl.cc
--- gnuradio-3.8.0.0/gr-digital/lib/map_bb_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-digital/lib/map_bb_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -49,19 +49,22 @@
 {
     gr::thread::scoped_lock guard(d_mutex);
 
-    for (int i = 0; i < 0x100; i++)
+    for (int i = 0; i < s_map_size; i++) {
         d_map[i] = i;
+    }
 
-    unsigned int size = std::min((size_t)0x100, map.size());
+    const unsigned int size = std::min(s_map_size, map.size());
     for (unsigned int i = 0; i < size; i++)
         d_map[i] = map[i];
 }
 
 std::vector<int> map_bb_impl::map() const
 {
-    std::vector<int> m;
-    for (unsigned i = 0; i < 0x100; i++)
+    std::vector<int> m(s_map_size);
+    gr::thread::scoped_lock guard(d_mutex);
+    for (unsigned i = 0; i < s_map_size; i++) {
         m[i] = d_map[i];
+    }
     return m;
 }
 
diff -uNr gnuradio-3.8.0.0/gr-digital/lib/map_bb_impl.h gnuradio-maint-3.8/gr-digital/lib/map_bb_impl.h
--- gnuradio-3.8.0.0/gr-digital/lib/map_bb_impl.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-digital/lib/map_bb_impl.h	2020-01-05 09:47:33.000000000 +0700
@@ -32,8 +32,9 @@
 class map_bb_impl : public map_bb
 {
 private:
-    unsigned char d_map[0x100];
-    gr::thread::mutex d_mutex;
+    static constexpr size_t s_map_size = 0x100;
+    unsigned char d_map[s_map_size];
+    mutable gr::thread::mutex d_mutex;
 
 public:
     map_bb_impl(const std::vector<int>& map);
diff -uNr gnuradio-3.8.0.0/gr-digital/lib/msk_timing_recovery_cc_impl.cc gnuradio-maint-3.8/gr-digital/lib/msk_timing_recovery_cc_impl.cc
--- gnuradio-3.8.0.0/gr-digital/lib/msk_timing_recovery_cc_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-digital/lib/msk_timing_recovery_cc_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -133,7 +133,7 @@
 
     while (oidx < noutput_items && iidx < ninp) {
         // check to see if there's a tag to reset the timing estimate
-        if (tags.size() > 0) {
+        if (!tags.empty()) {
             int offset = tags[0].offset - nitems_read(0);
             if ((offset >= iidx) && (offset < (iidx + d_sps))) {
                 float center = (float)pmt::to_double(tags[0].value);
diff -uNr gnuradio-3.8.0.0/gr-digital/lib/ofdm_chanest_vcvc_impl.cc gnuradio-maint-3.8/gr-digital/lib/ofdm_chanest_vcvc_impl.cc
--- gnuradio-3.8.0.0/gr-digital/lib/ofdm_chanest_vcvc_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-digital/lib/ofdm_chanest_vcvc_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -60,8 +60,8 @@
       d_n_data_syms(n_data_symbols),
       d_n_sync_syms(1),
       d_eq_noise_red_len(eq_noise_red_len),
-      d_ref_sym((sync_symbol2.size() && !force_one_sync_symbol) ? sync_symbol2
-                                                                : sync_symbol1),
+      d_ref_sym((!sync_symbol2.empty() && !force_one_sync_symbol) ? sync_symbol2
+                                                                  : sync_symbol1),
       d_corr_v(sync_symbol2),
       d_known_symbol_diffs(0, 0),
       d_new_symbol_diffs(0, 0),
@@ -84,7 +84,7 @@
     }
 
     // Sanity checks
-    if (sync_symbol2.size()) {
+    if (!sync_symbol2.empty()) {
         if (sync_symbol1.size() != sync_symbol2.size()) {
             throw std::invalid_argument("sync symbols must have equal length.");
         }
@@ -149,7 +149,7 @@
                                             const gr_complex* sync_sym2)
 {
     int carr_offset = 0;
-    if (d_corr_v.size()) {
+    if (!d_corr_v.empty()) {
         // Use Schmidl & Cox method
         float Bg_max = 0;
         // g here is 2g in the paper
diff -uNr gnuradio-3.8.0.0/gr-digital/lib/ofdm_equalizer_base.cc gnuradio-maint-3.8/gr-digital/lib/ofdm_equalizer_base.cc
--- gnuradio-3.8.0.0/gr-digital/lib/ofdm_equalizer_base.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-digital/lib/ofdm_equalizer_base.cc	2020-01-05 09:47:33.000000000 +0700
@@ -57,7 +57,7 @@
     if (input_is_shifted) {
         fft_shift_width = fft_len / 2;
     }
-    if (!occupied_carriers.size()) {
+    if (occupied_carriers.empty()) {
         std::fill(d_occupied_carriers.begin(), d_occupied_carriers.end(), true);
     } else {
         for (unsigned i = 0; i < occupied_carriers.size(); i++) {
@@ -73,7 +73,7 @@
             }
         }
     }
-    if (pilot_carriers.size()) {
+    if (!pilot_carriers.empty()) {
         for (unsigned i = 0; i < pilot_carriers.size(); i++) {
             if (pilot_carriers[i].size() != pilot_symbols[i].size()) {
                 throw std::invalid_argument("pilot carriers and -symbols do not match.");
diff -uNr gnuradio-3.8.0.0/gr-digital/lib/pfb_clock_sync_ccf_impl.cc gnuradio-maint-3.8/gr-digital/lib/pfb_clock_sync_ccf_impl.cc
--- gnuradio-3.8.0.0/gr-digital/lib/pfb_clock_sync_ccf_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-digital/lib/pfb_clock_sync_ccf_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -68,7 +68,7 @@
       d_error(0),
       d_out_idx(0)
 {
-    if (taps.size() == 0)
+    if (taps.empty())
         throw std::runtime_error("pfb_clock_sync_ccf: please specify a filter.\n");
 
     // Let scheduler adjust our relative_rate.
@@ -382,7 +382,7 @@
 
     // produce output as long as we can and there are enough input samples
     while (i < noutput_items) {
-        if (tags.size() > 0) {
+        if (!tags.empty()) {
             size_t offset = tags[0].offset - nitems_read(0);
             if ((offset >= (size_t)count) && (offset < (size_t)(count + d_sps))) {
                 float center = (float)pmt::to_double(tags[0].value);
diff -uNr gnuradio-3.8.0.0/gr-digital/lib/pfb_clock_sync_fff_impl.cc gnuradio-maint-3.8/gr-digital/lib/pfb_clock_sync_fff_impl.cc
--- gnuradio-3.8.0.0/gr-digital/lib/pfb_clock_sync_fff_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-digital/lib/pfb_clock_sync_fff_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -65,7 +65,7 @@
       d_error(0),
       d_out_idx(0)
 {
-    if (taps.size() == 0)
+    if (taps.empty())
         throw std::runtime_error("pfb_clock_sync_fff: please specify a filter.\n");
 
     // Let scheduler adjust our relative_rate.
diff -uNr gnuradio-3.8.0.0/gr-digital/lib/timing_error_detector.cc gnuradio-maint-3.8/gr-digital/lib/timing_error_detector.cc
--- gnuradio-3.8.0.0/gr-digital/lib/timing_error_detector.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-digital/lib/timing_error_detector.cc	2020-01-05 09:47:33.000000000 +0700
@@ -232,11 +232,9 @@
     d_input_derivative.assign(d_error_depth, gr_complex(0.0f, 0.0f));
 
     if (d_constellation) {
-        std::deque<gr_complex>::iterator it;
-        d_decision.clear();
-        for (it = d_input.begin(); it != d_input.end(); ++it)
-            d_decision.push_back(gr_complex(0.0f, 0.0f));
-        // d_decision.push_back(slice(*it));
+        d_decision.assign(d_input.size(), gr_complex(0.0f, 0.0f));
+        // for (it = d_input.begin(); it != d_input.end(); ++it)
+        //   d_decision.push_back(slice(*it));
     }
 
     sync_reset_input_clock();
diff -uNr gnuradio-3.8.0.0/gr-digital/python/digital/qa_scrambler.py gnuradio-maint-3.8/gr-digital/python/digital/qa_scrambler.py
--- gnuradio-3.8.0.0/gr-digital/python/digital/qa_scrambler.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-digital/python/digital/qa_scrambler.py	2020-01-05 09:47:33.000000000 +0700
@@ -64,28 +64,24 @@
         self.assertEqual(src_data, dst.data())
 
     def test_additive_scrambler_reset(self):
-        src_data = (1,)*1000
+        src_data = (1,)*200
         src = blocks.vector_source_b(src_data, False)
-        scrambler = digital.additive_scrambler_bb(0x8a, 0x7f, 7, 100)
-        descrambler = digital.additive_scrambler_bb(0x8a, 0x7f, 7, 100)
+        scrambler = digital.additive_scrambler_bb(0x8a, 0x7f, 7, 50)
         dst = blocks.vector_sink_b()
-        self.tb.connect(src, scrambler, descrambler, dst)
+        self.tb.connect(src, scrambler, dst)
         self.tb.run()
-        self.assertEqual(src_data, dst.data())
+        output = dst.data()
+        self.assertEqual(output[:50] * 4, output)
 
     def test_additive_scrambler_reset_3bpb(self):
-        src_data = (5,)*2000
+        src_data = (5,)*200
         src = blocks.vector_source_b(src_data, False)
-        scrambler = digital.additive_scrambler_bb(0x8a, 0x7f, 7, 100, 3)
-        descrambler = digital.additive_scrambler_bb(0x8a, 0x7f, 7, 100, 3)
+        scrambler = digital.additive_scrambler_bb(0x8a, 0x7f, 7, 50, 3)
         dst = blocks.vector_sink_b()
-        dst2 = blocks.vector_sink_b()
-        self.tb.connect(src, scrambler, descrambler, dst)
-        self.tb.connect(scrambler, dst2)
+        self.tb.connect(src, scrambler, dst)
         self.tb.run()
-        if not (src_data == dst.data()):
-            self.fail('Not equal.')
-        self.assertEqual(src_data, src_data)
+        output = dst.data()
+        self.assertEqual(output[:50] * 4, output)
 
     def test_additive_scrambler_tags(self):
         src_data = (1,)*1000
diff -uNr gnuradio-3.8.0.0/gr-dtv/lib/atsc/atsc_field_sync_mux_impl.cc gnuradio-maint-3.8/gr-dtv/lib/atsc/atsc_field_sync_mux_impl.cc
--- gnuradio-3.8.0.0/gr-dtv/lib/atsc/atsc_field_sync_mux_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-dtv/lib/atsc/atsc_field_sync_mux_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -29,8 +29,6 @@
 namespace gr {
 namespace dtv {
 
-static const int N_SAVED_SYMBOLS = 12;
-
 atsc_field_sync_mux::sptr atsc_field_sync_mux::make()
 {
     return gnuradio::get_initial_sptr(new atsc_field_sync_mux_impl());
diff -uNr gnuradio-3.8.0.0/gr-dtv/lib/atsc/atsc_trellis_encoder_impl.cc gnuradio-maint-3.8/gr-dtv/lib/atsc/atsc_trellis_encoder_impl.cc
--- gnuradio-3.8.0.0/gr-dtv/lib/atsc/atsc_trellis_encoder_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-dtv/lib/atsc/atsc_trellis_encoder_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -34,9 +34,6 @@
 #define SEGOF(x) ((x) / ((SEGMENT_SIZE + 1) * DIBITS_PER_BYTE))
 #define SYMOF(x) (((x) % ((SEGMENT_SIZE + 1) * DIBITS_PER_BYTE)) - 4)
 
-/* How many separate Trellis encoders / Viterbi decoders run in parallel */
-static const int NCODERS = 12;
-
 #define ENCODER_SEG_BUMP 4
 
 /* A Segment sync symbol is an 8VSB +5,-5,-5,+5 sequence that occurs at
@@ -83,7 +80,7 @@
     assert(sizeof(in_copy) == sizeof(in[0].data) * NCODERS);
     assert(sizeof(out_copy) == sizeof(out[0].data) * NCODERS);
 
-    // copy input into continguous temporary buffer
+    // copy input into contiguous temporary buffer
     for (int i = 0; i < NCODERS; i++) {
         assert(in[i].pli.regular_seg_p());
         plinfo::sanity_check(in[i].pli);
@@ -112,7 +109,7 @@
 }
 
 /*
- * This code expects contiguous arrrays. Use it as is, it computes
+ * This code expects contiguous arrays. Use it as is, it computes
  * the correct answer. Maybe someday, when we've run out of better
  * things to do, rework to avoid the copying in encode.
  */
diff -uNr gnuradio-3.8.0.0/gr-dtv/lib/atsc/atsc_trellis_encoder_impl.h gnuradio-maint-3.8/gr-dtv/lib/atsc/atsc_trellis_encoder_impl.h
--- gnuradio-3.8.0.0/gr-dtv/lib/atsc/atsc_trellis_encoder_impl.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-dtv/lib/atsc/atsc_trellis_encoder_impl.h	2020-01-05 09:47:33.000000000 +0700
@@ -33,6 +33,7 @@
 private:
     bool debug;
 
+    /* How many separate Trellis encoders / Viterbi decoders run in parallel */
     static const int NCODERS = 12;
     static const int SEGMENT_SIZE = ATSC_MPEG_RS_ENCODED_LENGTH;
     static const int INPUT_SIZE = (SEGMENT_SIZE * 12);
diff -uNr gnuradio-3.8.0.0/gr-dtv/lib/dvbt/dvbt_convolutional_deinterleaver_impl.cc gnuradio-maint-3.8/gr-dtv/lib/dvbt/dvbt_convolutional_deinterleaver_impl.cc
--- gnuradio-3.8.0.0/gr-dtv/lib/dvbt/dvbt_convolutional_deinterleaver_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-dtv/lib/dvbt/dvbt_convolutional_deinterleaver_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -110,7 +110,7 @@
                             nread + (noutput_items * d_I * d_blocks),
                             pmt::string_to_symbol("superframe_start"));
 
-    if (tags.size()) {
+    if (!tags.empty()) {
         if (tags[0].offset - nread) {
             consume_each(tags[0].offset - nread);
             return (0);
diff -uNr gnuradio-3.8.0.0/gr-dtv/lib/dvbt/dvbt_demod_reference_signals_impl.cc gnuradio-maint-3.8/gr-dtv/lib/dvbt/dvbt_demod_reference_signals_impl.cc
--- gnuradio-3.8.0.0/gr-dtv/lib/dvbt/dvbt_demod_reference_signals_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-dtv/lib/dvbt/dvbt_demod_reference_signals_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -116,7 +116,7 @@
     this->get_tags_in_range(
         tags, 0, nread, nread + nitems, pmt::string_to_symbol("sync_start"));
 
-    return tags.size() ? 1 : 0;
+    return !tags.empty() ? 1 : 0;
 }
 
 int dvbt_demod_reference_signals_impl::general_work(
diff -uNr gnuradio-3.8.0.0/gr-dtv/lib/dvbt/dvbt_ofdm_sym_acquisition_impl.cc gnuradio-maint-3.8/gr-dtv/lib/dvbt/dvbt_ofdm_sym_acquisition_impl.cc
--- gnuradio-3.8.0.0/gr-dtv/lib/dvbt/dvbt_ofdm_sym_acquisition_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-dtv/lib/dvbt/dvbt_ofdm_sym_acquisition_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -409,7 +409,7 @@
             send_sync_start();
             d_initial_acquisition = 0;
 
-            // Restart wit a half number so that we'll not end up with the same situation
+            // Restart with a half number so that we'll not end up with the same situation
             // This will prevent peak_detect to not detect anything
             d_to_consume = d_to_consume / 2;
             d_consumed += d_to_consume;
diff -uNr gnuradio-3.8.0.0/gr-dtv/lib/dvbt/dvbt_reference_signals_impl.h gnuradio-maint-3.8/gr-dtv/lib/dvbt/dvbt_reference_signals_impl.h
--- gnuradio-3.8.0.0/gr-dtv/lib/dvbt/dvbt_reference_signals_impl.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-dtv/lib/dvbt/dvbt_reference_signals_impl.h	2020-01-05 09:47:33.000000000 +0700
@@ -218,7 +218,7 @@
      * TODO
      * ETSI EN 300 744 Clause 4.5. \n
      * Extract data from a set of carriers using pilot signals. \n
-     * This is doing frequency correcton, equalization. \n
+     * This is doing frequency correction, equalization. \n
      */
     int parse_input(const gr_complex* in,
                     gr_complex* out,
diff -uNr gnuradio-3.8.0.0/gr-dtv/lib/dvbt/dvbt_viterbi_decoder_impl.cc gnuradio-maint-3.8/gr-dtv/lib/dvbt/dvbt_viterbi_decoder_impl.cc
--- gnuradio-3.8.0.0/gr-dtv/lib/dvbt/dvbt_viterbi_decoder_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-dtv/lib/dvbt/dvbt_viterbi_decoder_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -644,7 +644,7 @@
                                 nread + (nblocks * d_nsymbols),
                                 pmt::string_to_symbol("superframe_start"));
 
-        if (tags.size()) {
+        if (!tags.empty()) {
             d_init = 0;
 
 #ifdef DTV_SSE2
diff -uNr gnuradio-3.8.0.0/gr-fec/lib/conv_bit_corr_bb_impl.h gnuradio-maint-3.8/gr-fec/lib/conv_bit_corr_bb_impl.h
--- gnuradio-3.8.0.0/gr-fec/lib/conv_bit_corr_bb_impl.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-fec/lib/conv_bit_corr_bb_impl.h	2020-01-05 09:47:33.000000000 +0700
@@ -64,7 +64,7 @@
     std::vector<int> get_corr()
     {
         std::vector<int> bits;
-        if (d_correlator.size() < 1) {
+        if (d_correlator.empty()) {
             return bits;
         }
         for (size_t i = 0; i < d_correlator[0].size(); i++) {
diff -uNr gnuradio-3.8.0.0/gr-fec/lib/generic_decoder.cc gnuradio-maint-3.8/gr-fec/lib/generic_decoder.cc
--- gnuradio-3.8.0.0/gr-fec/lib/generic_decoder.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-fec/lib/generic_decoder.cc	2020-01-05 09:47:33.000000000 +0700
@@ -45,7 +45,7 @@
 
     GR_LOG_GETLOGGER(LOG, "gr_log." + alias());
     GR_LOG_SET_LEVEL(LOG, log_level);
-    if (log_file.size() > 0) {
+    if (!log_file.empty()) {
         if (log_file == "stdout") {
             GR_LOG_SET_CONSOLE_APPENDER(LOG, "stdout", "gr::log :%p: %c{1} - %m%n");
         } else if (log_file == "stderr") {
diff -uNr gnuradio-3.8.0.0/gr-fec/lib/generic_encoder.cc gnuradio-maint-3.8/gr-fec/lib/generic_encoder.cc
--- gnuradio-3.8.0.0/gr-fec/lib/generic_encoder.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-fec/lib/generic_encoder.cc	2020-01-05 09:47:33.000000000 +0700
@@ -45,7 +45,7 @@
 
     GR_LOG_GETLOGGER(LOG, "gr_log." + alias());
     GR_LOG_SET_LEVEL(LOG, log_level);
-    if (log_file.size() > 0) {
+    if (!log_file.empty()) {
         if (log_file == "stdout") {
             GR_LOG_SET_CONSOLE_APPENDER(LOG, "stdout", "gr::log :%p: %c{1} - %m%n");
         } else if (log_file == "stderr") {
diff -uNr gnuradio-3.8.0.0/gr-fec/lib/tpc_decoder.cc gnuradio-maint-3.8/gr-fec/lib/tpc_decoder.cc
--- gnuradio-3.8.0.0/gr-fec/lib/tpc_decoder.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-fec/lib/tpc_decoder.cc	2020-01-05 09:47:33.000000000 +0700
@@ -703,7 +703,7 @@
 {
     // Return maximum of delta1 and delta2
     // and in correction value if |delta1-delta2| < TVALUE
-    register float diff;
+    float diff;
     diff = delta2 - delta1;
 
     if (diff > TVALUE)
diff -uNr gnuradio-3.8.0.0/gr-fft/include/gnuradio/fft/fft_vcc.h gnuradio-maint-3.8/gr-fft/include/gnuradio/fft/fft_vcc.h
--- gnuradio-3.8.0.0/gr-fft/include/gnuradio/fft/fft_vcc.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-fft/include/gnuradio/fft/fft_vcc.h	2020-01-05 09:47:33.000000000 +0700
@@ -51,7 +51,7 @@
  * \f$N-1\f$.
  *
  * \b Note, that due to the underlying FFTW library, the output of a FFT
- * followed by an IFFT (or the other way arround) will be scaled i.e.
+ * followed by an IFFT (or the other way around) will be scaled i.e.
  * \f$FFT\{ \, IFFT\{x\} \,\} =  N \cdot x \neq x\f$.
  *
  * \see http://www.fftw.org/faq/section3.html#whyscaled
diff -uNr gnuradio-3.8.0.0/gr-fft/include/gnuradio/fft/fft_vfc.h gnuradio-maint-3.8/gr-fft/include/gnuradio/fft/fft_vfc.h
--- gnuradio-3.8.0.0/gr-fft/include/gnuradio/fft/fft_vfc.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-fft/include/gnuradio/fft/fft_vfc.h	2020-01-05 09:47:33.000000000 +0700
@@ -51,7 +51,7 @@
  * \f$N-1\f$.
  *
  * \b Note, that due to the underlying FFTW library, the output of a FFT
- * followed by an IFFT (or the other way arround) will be scaled i.e.
+ * followed by an IFFT (or the other way around) will be scaled i.e.
  * \f$FFT\{ \, IFFT\{x\} \,\} =  N \cdot x \neq x\f$.
  *
  * \see http://www.fftw.org/faq/section3.html#whyscaled
diff -uNr gnuradio-3.8.0.0/gr-fft/include/gnuradio/fft/window.h gnuradio-maint-3.8/gr-fft/include/gnuradio/fft/window.h
--- gnuradio-3.8.0.0/gr-fft/include/gnuradio/fft/window.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-fft/include/gnuradio/fft/window.h	2020-01-05 09:47:33.000000000 +0700
@@ -177,7 +177,7 @@
     static std::vector<float> blackman_harris(int ntaps, int atten = 92);
 
     /*!
-     * Alias to gr::fft::window::blakcman_harris.
+     * Alias to gr::fft::window::blackman_harris.
      */
     static std::vector<float> blackmanharris(int ntaps, int atten = 92);
 
diff -uNr gnuradio-3.8.0.0/gr-fft/lib/ctrlport_probe_psd_impl.cc gnuradio-maint-3.8/gr-fft/lib/ctrlport_probe_psd_impl.cc
--- gnuradio-3.8.0.0/gr-fft/lib/ctrlport_probe_psd_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-fft/lib/ctrlport_probe_psd_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -137,7 +137,7 @@
 {
 #ifdef GR_CTRLPORT
     int len = static_cast<int>(d_len);
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe_psd, std::vector<std::complex<float>>>(
             alias(),
             d_id.c_str(),
@@ -148,9 +148,9 @@
             "dB",
             d_desc.c_str(),
             RPC_PRIVLVL_MIN,
-            DISPXY | DISPOPTSCATTER)));
+            DISPXY | DISPOPTSCATTER));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe_psd, int>(alias(),
                                                            "length",
                                                            &ctrlport_probe_psd::length,
@@ -160,13 +160,13 @@
                                                            "samples",
                                                            "get vector length",
                                                            RPC_PRIVLVL_MIN,
-                                                           DISPNULL)));
+                                                           DISPNULL));
 
-//      d_rpc_vars.push_back(
-//        rpcbasic_sptr(new rpcbasic_register_set<ctrlport_probe_psd, int>(
+//      d_rpc_vars.emplace_back(
+//        new rpcbasic_register_set<ctrlport_probe_psd, int>(
 //          alias(), "length", &ctrlport_probe_psd::set_length,
 //          pmt::mp(1), pmt::mp(10*len), pmt::mp(len),
-//          "samples", "set vector length", RPC_PRIVLVL_MIN, DISPNULL)));
+//          "samples", "set vector length", RPC_PRIVLVL_MIN, DISPNULL));
 #endif /* GR_CTRLPORT */
 }
 
diff -uNr gnuradio-3.8.0.0/gr-fft/lib/fft_vcc_fftw.cc gnuradio-maint-3.8/gr-fft/lib/fft_vcc_fftw.cc
--- gnuradio-3.8.0.0/gr-fft/lib/fft_vcc_fftw.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-fft/lib/fft_vcc_fftw.cc	2020-01-05 09:47:33.000000000 +0700
@@ -67,7 +67,7 @@
 
 bool fft_vcc_fftw::set_window(const std::vector<float>& window)
 {
-    if (window.size() == 0 || window.size() == d_fft_size) {
+    if (window.empty() || window.size() == d_fft_size) {
         d_window = window;
         return true;
     } else
@@ -89,7 +89,7 @@
     while (count++ < noutput_items) {
 
         // copy input into optimally aligned buffer
-        if (d_window.size()) {
+        if (!d_window.empty()) {
             gr_complex* dst = d_fft->get_inbuf();
             if (!d_forward && d_shift) {
                 unsigned int offset = (!d_forward && d_shift) ? (d_fft_size / 2) : 0;
diff -uNr gnuradio-3.8.0.0/gr-fft/lib/fft_vfc_fftw.cc gnuradio-maint-3.8/gr-fft/lib/fft_vfc_fftw.cc
--- gnuradio-3.8.0.0/gr-fft/lib/fft_vfc_fftw.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-fft/lib/fft_vfc_fftw.cc	2020-01-05 09:47:33.000000000 +0700
@@ -62,7 +62,7 @@
 
 bool fft_vfc_fftw::set_window(const std::vector<float>& window)
 {
-    if (window.size() == 0 || window.size() == d_fft_size) {
+    if (window.empty() || window.size() == d_fft_size) {
         d_window = window;
         return true;
     } else
@@ -83,7 +83,7 @@
     while (count++ < noutput_items) {
 
         // copy input into optimally aligned buffer
-        if (d_window.size()) {
+        if (!d_window.empty()) {
             gr_complex* dst = d_fft->get_inbuf();
             for (unsigned int i = 0; i < d_fft_size; i++) // apply window
                 dst[i] = in[i] * d_window[i];
diff -uNr gnuradio-3.8.0.0/gr-filter/grc/filter_pfb_channelizer.block.yml gnuradio-maint-3.8/gr-filter/grc/filter_pfb_channelizer.block.yml
--- gnuradio-3.8.0.0/gr-filter/grc/filter_pfb_channelizer.block.yml	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-filter/grc/filter_pfb_channelizer.block.yml	2020-01-05 09:47:33.000000000 +0700
@@ -53,7 +53,8 @@
             ${taps},
             ${osr},
             ${atten})
-        self.${id}.set_channel_map(${ch_map})\nself.${id}.declare_sample_delay(${samp_delay})
+        self.${id}.set_channel_map(${ch_map})
+        self.${id}.declare_sample_delay(${samp_delay})
     callbacks:
     - set_taps(${taps})
     - set_channel_map(${ch_map})
diff -uNr gnuradio-3.8.0.0/gr-filter/lib/fft_filter.cc gnuradio-maint-3.8/gr-filter/lib/fft_filter.cc
--- gnuradio-3.8.0.0/gr-filter/lib/fft_filter.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-filter/lib/fft_filter.cc	2020-01-05 09:47:33.000000000 +0700
@@ -168,7 +168,7 @@
         dec_ctr = (j - d_nsamples);
 
         // stash the tail
-        if (d_tail.size()) {
+        if (!d_tail.empty()) {
             memcpy(&d_tail[0],
                    d_invfft->get_outbuf() + d_nsamples,
                    tailsize() * sizeof(float));
@@ -315,7 +315,7 @@
         dec_ctr = (j - d_nsamples);
 
         // stash the tail
-        if (d_tail.size()) {
+        if (!d_tail.empty()) {
             memcpy(&d_tail[0],
                    d_invfft->get_outbuf() + d_nsamples,
                    tailsize() * sizeof(gr_complex));
@@ -464,7 +464,7 @@
         dec_ctr = (j - d_nsamples);
 
         // stash the tail
-        if (d_tail.size()) {
+        if (!d_tail.empty()) {
             memcpy(&d_tail[0],
                    d_invfft->get_outbuf() + d_nsamples,
                    tailsize() * sizeof(gr_complex));
diff -uNr gnuradio-3.8.0.0/gr-filter/lib/fir_filter.cc gnuradio-maint-3.8/gr-filter/lib/fir_filter.cc
--- gnuradio-3.8.0.0/gr-filter/lib/fir_filter.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-filter/lib/fir_filter.cc	2020-01-05 09:47:33.000000000 +0700
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2004,2010,2012,2018 Free Software Foundation, Inc.
+ * Copyright 2004,2010,2012,2018,2019 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -80,7 +80,7 @@
     for (int i = 0; i < d_naligned; i++) {
         d_aligned_taps[i] =
             (TAP_T*)volk_malloc((d_ntaps + d_naligned - 1) * sizeof(TAP_T), d_align);
-        memset(d_aligned_taps[i], 0, sizeof(TAP_T) * (d_ntaps + d_naligned - 1));
+        std::fill_n(d_aligned_taps[i], d_ntaps + d_naligned - 1, 0);
         for (unsigned int j = 0; j < d_ntaps; j++)
             d_aligned_taps[i][i + j] = d_taps[j];
     }
diff -uNr gnuradio-3.8.0.0/gr-filter/lib/fir_filter_with_buffer.cc gnuradio-maint-3.8/gr-filter/lib/fir_filter_with_buffer.cc
--- gnuradio-3.8.0.0/gr-filter/lib/fir_filter_with_buffer.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-filter/lib/fir_filter_with_buffer.cc	2020-01-05 09:47:33.000000000 +0700
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2010,2012 Free Software Foundation, Inc.
+ * Copyright 2010,2012,2019 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -242,7 +242,7 @@
     // allocated space.
     d_buffer_ptr = (gr_complex*)volk_malloc(
         (2 * (d_ntaps + d_naligned)) * sizeof(gr_complex), d_align);
-    memset(d_buffer_ptr, 0, 2 * (d_ntaps + d_naligned) * sizeof(gr_complex));
+    std::fill_n(d_buffer_ptr, 2 * (d_ntaps + d_naligned), 0);
     d_buffer = d_buffer_ptr + d_naligned;
 
     // Allocate aligned taps
@@ -250,7 +250,7 @@
     for (int i = 0; i < d_naligned; i++) {
         d_aligned_taps[i] = (gr_complex*)volk_malloc(
             (d_ntaps + d_naligned - 1) * sizeof(gr_complex), d_align);
-        memset(d_aligned_taps[i], 0, sizeof(gr_complex) * (d_ntaps + d_naligned - 1));
+        std::fill_n(d_aligned_taps[i], d_ntaps + d_naligned - 1, 0);
         for (unsigned int j = 0; j < d_ntaps; j++)
             d_aligned_taps[i][i + j] = d_taps[j];
     }
@@ -386,7 +386,7 @@
     // allocated space.
     d_buffer_ptr = (gr_complex*)volk_malloc(
         (2 * (d_ntaps + d_naligned)) * sizeof(gr_complex), d_align);
-    memset(d_buffer_ptr, 0, 2 * (d_ntaps + d_naligned) * sizeof(gr_complex));
+    std::fill_n(d_buffer_ptr, 2 * (d_ntaps + d_naligned), 0);
     d_buffer = d_buffer_ptr + d_naligned;
 
     // Allocate aligned taps
diff -uNr gnuradio-3.8.0.0/gr-filter/lib/interp_fir_filter_impl.cc gnuradio-maint-3.8/gr-filter/lib/interp_fir_filter_impl.cc
--- gnuradio-3.8.0.0/gr-filter/lib/interp_fir_filter_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-filter/lib/interp_fir_filter_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -55,7 +55,7 @@
         throw std::out_of_range("interp_fir_filter_impl: interpolation must be > 0\n");
     }
 
-    if (taps.size() == 0) {
+    if (taps.empty()) {
         throw std::runtime_error("interp_fir_filter_impl: no filter taps provided.\n");
     }
 
diff -uNr gnuradio-3.8.0.0/gr-filter/lib/pfb_channelizer_ccf_impl.cc gnuradio-maint-3.8/gr-filter/lib/pfb_channelizer_ccf_impl.cc
--- gnuradio-3.8.0.0/gr-filter/lib/pfb_channelizer_ccf_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-filter/lib/pfb_channelizer_ccf_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -125,7 +125,7 @@
 {
     gr::thread::scoped_lock guard(d_mutex);
 
-    if (map.size() > 0) {
+    if (!map.empty()) {
         unsigned int max = (unsigned int)*std::max_element(map.begin(), map.end());
         if (max >= d_nfilts) {
             throw std::invalid_argument(
diff -uNr gnuradio-3.8.0.0/gr-filter/lib/pfb_synthesizer_ccf_impl.cc gnuradio-maint-3.8/gr-filter/lib/pfb_synthesizer_ccf_impl.cc
--- gnuradio-3.8.0.0/gr-filter/lib/pfb_synthesizer_ccf_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-filter/lib/pfb_synthesizer_ccf_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2010,2012,2014 Free Software Foundation, Inc.
+ * Copyright 2010,2012,2014,2019 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -27,6 +27,7 @@
 #include "pfb_synthesizer_ccf_impl.h"
 #include <gnuradio/io_signature.h>
 #include <cstdio>
+#include <algorithm>
 
 namespace gr {
 namespace filter {
@@ -72,7 +73,7 @@
 
     // Create the IFFT to handle the input channel rotations
     d_fft = new fft::fft_complex(d_twox * d_numchans, false);
-    memset(d_fft->get_inbuf(), 0, d_twox * d_numchans * sizeof(gr_complex));
+    std::fill_n(d_fft->get_inbuf(), d_twox * d_numchans, 0);
 
     set_output_multiple(d_numchans);
 }
@@ -213,7 +214,7 @@
 {
     gr::thread::scoped_lock guard(d_mutex);
 
-    if (map.size() > 0) {
+    if (!map.empty()) {
         int max = *std::max_element(map.begin(), map.end());
         int min = *std::min_element(map.begin(), map.end());
         if ((max >= static_cast<int>(d_twox * d_numchans)) || (min < 0)) {
@@ -223,7 +224,7 @@
         d_channel_map = map;
 
         // Zero out fft buffer so that unused channels are always 0
-        memset(d_fft->get_inbuf(), 0, d_twox * d_numchans * sizeof(gr_complex));
+        std::fill_n(d_fft->get_inbuf(), d_twox * d_numchans, 0);
     }
 }
 
diff -uNr gnuradio-3.8.0.0/gr-filter/lib/pm_remez.cc gnuradio-maint-3.8/gr-filter/lib/pm_remez.cc
--- gnuradio-3.8.0.0/gr-filter/lib/pm_remez.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-filter/lib/pm_remez.cc	2020-01-05 09:47:33.000000000 +0700
@@ -821,7 +821,7 @@
     for (int i = 0; i < numbands; i++)
         weight[i] = 1.0;
 
-    if (arg_weight.size() != 0) {
+    if (!arg_weight.empty()) {
         if ((int)arg_weight.size() != numbands)
             punt("gr_remez: need one weight for each band [=length(band)/2]");
         for (int i = 0; i < numbands; i++)
diff -uNr gnuradio-3.8.0.0/gr-filter/lib/qa_fir_filter_with_buffer.cc gnuradio-maint-3.8/gr-filter/lib/qa_fir_filter_with_buffer.cc
--- gnuradio-3.8.0.0/gr-filter/lib/qa_fir_filter_with_buffer.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-filter/lib/qa_fir_filter_with_buffer.cc	2020-01-05 09:47:33.000000000 +0700
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2010,2012 Free Software Foundation, Inc.
+ * Copyright 2010,2012,2019 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -32,6 +32,7 @@
 #include <boost/test/unit_test.hpp>
 #include <cmath>
 #include <cstring>
+#include <algorithm>
 
 using std::vector;
 
@@ -201,7 +202,7 @@
         (gr_complex*)volk_malloc(OUTPUT_LEN * sizeof(gr_complex), align);
     tap_type* taps = (gr_complex*)volk_malloc(MAX_TAPS * sizeof(gr_complex), align);
 
-    memset(dline, 0, INPUT_LEN * sizeof(i_type));
+    std::fill_n(dline, INPUT_LEN, 0);
 
     for (int n = 0; n <= MAX_TAPS; n++) {
         for (int ol = 0; ol <= OUTPUT_LEN; ol++) {
@@ -211,7 +212,7 @@
             random_complex(taps, MAX_TAPS);
 
             // compute expected output values
-            memset(dline, 0, INPUT_LEN * sizeof(i_type));
+            std::fill_n(dline, INPUT_LEN, 0);
             for (int o = 0; o < (int)(ol / decimate); o++) {
                 // use an actual delay line for this test
                 for (int dd = 0; dd < (int)decimate; dd++) {
@@ -228,7 +229,7 @@
                 new kernel::fir_filter_with_buffer_ccc(f1_taps);
 
             // zero the output, then do the filtering
-            memset(actual_output, 0, OUTPUT_LEN * sizeof(o_type));
+            std::fill_n(actual_output, OUTPUT_LEN, 0);
             f1->filterNdec(actual_output, input, ol / decimate, decimate);
 
             // check results
@@ -302,7 +303,7 @@
         (gr_complex*)volk_malloc(OUTPUT_LEN * sizeof(gr_complex), align);
     tap_type* taps = (float*)volk_malloc(MAX_TAPS * sizeof(float), align);
 
-    memset(dline, 0, INPUT_LEN * sizeof(i_type));
+    std::fill_n(dline, INPUT_LEN, 0);
 
     for (int n = 0; n <= MAX_TAPS; n++) {
         for (int ol = 0; ol <= OUTPUT_LEN; ol++) {
@@ -312,7 +313,7 @@
             random_floats(taps, MAX_TAPS);
 
             // compute expected output values
-            memset(dline, 0, INPUT_LEN * sizeof(i_type));
+            std::fill_n(dline, INPUT_LEN, 0);
             for (int o = 0; o < (int)(ol / decimate); o++) {
                 // use an actual delay line for this test
                 for (int dd = 0; dd < (int)decimate; dd++) {
@@ -329,7 +330,7 @@
                 new kernel::fir_filter_with_buffer_ccf(f1_taps);
 
             // zero the output, then do the filtering
-            memset(actual_output, 0, OUTPUT_LEN * sizeof(gr_complex));
+            std::fill_n(actual_output, OUTPUT_LEN, 0);
             f1->filterNdec(actual_output, input, ol / decimate, decimate);
 
             // check results
diff -uNr gnuradio-3.8.0.0/gr-filter/python/filter/design/filter_design.py gnuradio-maint-3.8/gr-filter/python/filter/design/filter_design.py
--- gnuradio-3.8.0.0/gr-filter/python/filter/design/filter_design.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-filter/python/filter/design/filter_design.py	2020-01-05 09:47:33.000000000 +0700
@@ -33,16 +33,26 @@
 from gnuradio import filter
 
 try:
-    import numpy
-    from numpy.fft import fftpack
-    from scipy import poly1d, signal
+    import numpy as np
 except ImportError:
-    raise SystemExit('Please install SciPy to run this script (https://www.scipy.org)')
+    raise SystemExit('Please install NumPy to run this script (https://www.np.org/)')
 
 try:
-    import numpy as np
+    from numpy.fft import fftpack as fft_detail
 except ImportError:
-    raise SystemExit('Please install NumPy to run this script (https://www.numpy.org/)')
+
+    print('Could not import fftpack, trying pocketfft')
+    # Numpy changed fft implementation in version 1.17
+    # from fftpack to pocketfft
+    try:
+        from numpy.fft import pocketfft as fft_detail
+    except ImportError:
+        raise SystemExit('Could not import fft implementation of numpy')
+    
+try:
+    from scipy import poly1d, signal
+except ImportError:
+    raise SystemExit('Please install SciPy to run this script (https://www.scipy.org)')
 
 try:
     from PyQt5 import Qt, QtCore, QtWidgets
@@ -950,10 +960,10 @@
     def iir_plot_all(self,z,p,k):
         self.b,self.a = signal.zpk2tf(z,p,k)
         w,h = signal.freqz(self.b,self.a)
-        self.fftdB = 20 * numpy.log10 (abs(h))
+        self.fftdB = 20 * np.log10 (abs(h))
         self.freq = w / max(w)
-        self.fftDeg = numpy.unwrap(numpy.arctan2(numpy.imag(h),numpy.real(h)))
-        self.groupDelay = -numpy.diff(self.fftDeg)
+        self.fftDeg = np.unwrap(np.arctan2(np.imag(h),np.real(h)))
+        self.groupDelay = -np.diff(self.fftDeg)
         self.phaseDelay = -self.fftDeg[1:] / self.freq[1:]
         if self.gridview:
             self.set_mfmagresponse()
@@ -985,17 +995,17 @@
 
     def get_fft(self, fs, taps, Npts):
         Ts = 1.0 / fs
-        fftpts = fftpack.fft(taps, Npts)
-        self.freq = numpy.arange(0, fs, 1.0 / (Npts*Ts))
+        fftpts = fft_detail.fft(taps, Npts)
+        self.freq = np.arange(0, fs, 1.0 / (Npts*Ts))
         with warnings.catch_warnings(record=True) as w:
             warnings.simplefilter("always")
-            self.fftdB = 20.0*numpy.log10(abs(fftpts))
+            self.fftdB = 20.0*np.log10(abs(fftpts))
             if any(self.fftdB == float('-inf')):
                 sys.stderr.write('Filter design failed (taking log10 of 0).\n')
-                self.fftdB = numpy.zeros([len(fftpts)])
+                self.fftdB = np.zeros([len(fftpts)])
 
-        self.fftDeg = numpy.unwrap(numpy.angle(fftpts))
-        self.groupDelay = -numpy.diff(self.fftDeg)
+        self.fftDeg = np.unwrap(np.angle(fftpts))
+        self.groupDelay = -np.diff(self.fftDeg)
         self.phaseDelay = -self.fftDeg[1:] / self.freq[1:]
 
     def update_time_curves(self):
@@ -1014,14 +1024,14 @@
 
         if self.mttaps:
             if(type(self.taps[0]) == scipy.complex128):
-                self.mtimecurve_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+                self.mtimecurve_stems.setData(np.repeat(np.arange(ntaps), 2),
                                                 np.dstack((np.zeros(self.taps.real.shape[0], dtype=int),
                                                         self.taps.real)).flatten())
 
-                self.mtimecurve.setData(numpy.arange(ntaps), self.taps.real)
+                self.mtimecurve.setData(np.arange(ntaps), self.taps.real)
 
 
-                self.mtimecurve_i_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+                self.mtimecurve_i_stems.setData(np.repeat(np.arange(ntaps), 2),
                                                 np.dstack((np.zeros(self.taps.imag.shape[0], dtype=int),
                                                             self.taps.imag)).flatten())
 
@@ -1062,15 +1072,15 @@
         else:
             stepres = self.step_response(self.taps)
 
-        if(type(stepres[0]) == numpy.complex128):
-            self.steprescurve_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+        if(type(stepres[0]) == np.complex128):
+            self.steprescurve_stems.setData(np.repeat(np.arange(ntaps), 2),
                                             np.dstack((np.zeros(stepres.real.shape[0], dtype=int),
                                                        stepres.real)).flatten())
 
-            self.steprescurve.setData(numpy.arange(ntaps), stepres.real)
+            self.steprescurve.setData(np.arange(ntaps), stepres.real)
 
 
-            self.steprescurve_i_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+            self.steprescurve_i_stems.setData(np.repeat(np.arange(ntaps), 2),
                                               np.dstack((np.zeros(stepres.imag.shape[0], dtype=int),
                                                          stepres.imag)).flatten())
 
@@ -1085,15 +1095,15 @@
             self.steprescurve_i.setData([],[])
 
         if self.mtstep:
-            if(type(stepres[0]) == numpy.complex128):
-                self.mtimecurve_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+            if(type(stepres[0]) == np.complex128):
+                self.mtimecurve_stems.setData(np.repeat(np.arange(ntaps), 2),
                                                 np.dstack((np.zeros(stepres.real.shape[0], dtype=int),
                                                         stepres.real)).flatten())
 
-                self.mtimecurve.setData(numpy.arange(ntaps), stepres.real)
+                self.mtimecurve.setData(np.arange(ntaps), stepres.real)
 
 
-                self.mtimecurve_i_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+                self.mtimecurve_i_stems.setData(np.repeat(np.arange(ntaps), 2),
                                                 np.dstack((np.zeros(stepres.imag.shape[0], dtype=int),
                                                             stepres.imag)).flatten())
 
@@ -1131,15 +1141,15 @@
         else:
             impres = self.impulse_response(self.taps)
 
-        if(type(impres[0]) == numpy.complex128):
-            self.imprescurve_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+        if(type(impres[0]) == np.complex128):
+            self.imprescurve_stems.setData(np.repeat(np.arange(ntaps), 2),
                                            np.dstack((np.zeros(impres.real.shape[0], dtype=int),
                                                       impres.real)).flatten())
 
-            self.imprescurve.setData(numpy.arange(ntaps), impres.real)
+            self.imprescurve.setData(np.arange(ntaps), impres.real)
 
 
-            self.imprescurve_i_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+            self.imprescurve_i_stems.setData(np.repeat(np.arange(ntaps), 2),
                                              np.dstack((np.zeros(impres.imag.shape[0], dtype=int),
                                                         impres.imag)).flatten())
 
@@ -1150,15 +1160,15 @@
                                                       impres)).flatten())
 
         if self.mtimpulse:
-            if(type(impres[0]) == numpy.complex128):
-                self.mtimecurve_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+            if(type(impres[0]) == np.complex128):
+                self.mtimecurve_stems.setData(np.repeat(np.arange(ntaps), 2),
                                             np.dstack((np.zeros(impres.real.shape[0], dtype=int),
                                                         impres.real)).flatten())
 
-                self.mtimecurve.setData(numpy.arange(ntaps), impres.real)
+                self.mtimecurve.setData(np.arange(ntaps), impres.real)
 
 
-                self.mtimecurve_i_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+                self.mtimecurve_i_stems.setData(np.repeat(np.arange(ntaps), 2),
                                                 np.dstack((np.zeros(impres.imag.shape[0], dtype=int),
                                                             impres.imag)).flatten())
 
@@ -1639,7 +1649,7 @@
 
     def update_fft(self, taps, params):
         self.params = params
-        self.taps = numpy.array(taps)
+        self.taps = np.array(taps)
         self.get_fft(self.params["fs"], self.taps, self.nfftpts)
 
     def set_mfoverlay(self):
@@ -1942,9 +1952,9 @@
         length = len(b)
         if self.iir:
             length = 50
-        impulse = numpy.repeat(0., length)
+        impulse = np.repeat(0., length)
         impulse[0] = 1.
-        x = numpy.arange(0, length)
+        x = np.arange(0, length)
         response = signal.lfilter(b, a, impulse)
         return response
 
@@ -1952,11 +1962,11 @@
         length = len(b)
         if self.iir:
             length = 50
-        impulse = numpy.repeat(0., length)
+        impulse = np.repeat(0., length)
         impulse[0] = 1.
-        x = numpy.arange(0, length)
+        x = np.arange(0, length)
         response = signal.lfilter(b, a, impulse)
-        step = numpy.cumsum(response)
+        step = np.cumsum(response)
         return step
 
     def update_fcoeff(self):
@@ -2192,7 +2202,7 @@
 
     def draw_plots(self, taps, params):
         self.params = params
-        self.taps = numpy.array(taps)
+        self.taps = np.array(taps)
         if self.params:
             self.get_fft(self.params["fs"], self.taps, self.nfftpts)
             self.update_time_curves()
diff -uNr gnuradio-3.8.0.0/gr-qtgui/CMakeLists.txt gnuradio-maint-3.8/gr-qtgui/CMakeLists.txt
--- gnuradio-3.8.0.0/gr-qtgui/CMakeLists.txt	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/CMakeLists.txt	2020-01-05 09:47:33.000000000 +0700
@@ -22,8 +22,6 @@
 ########################################################################
 include(GrBoost)
 
-find_package(PythonLibs 2)
-
 include(GrPython)
 
 # Note: gr-qtgui requires Qt5.
diff -uNr gnuradio-3.8.0.0/gr-qtgui/grc/qtgui_edit_box_msg.block.yml gnuradio-maint-3.8/gr-qtgui/grc/qtgui_edit_box_msg.block.yml
--- gnuradio-3.8.0.0/gr-qtgui/grc/qtgui_edit_box_msg.block.yml	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/grc/qtgui_edit_box_msg.block.yml	2020-01-05 09:47:33.000000000 +0700
@@ -39,7 +39,7 @@
     hide: part
 
 asserts:
-- ${(is_pair and is_static and len(key) > 0) or not (is_pair and is_static)}
+- ${(len(key) > 0) or not ((is_pair == 'True') and (is_static == 'True'))}
 
 inputs:
 -   domain: message
diff -uNr gnuradio-3.8.0.0/gr-qtgui/grc/qtgui_tab_widget.block.yml gnuradio-maint-3.8/gr-qtgui/grc/qtgui_tab_widget.block.yml
--- gnuradio-3.8.0.0/gr-qtgui/grc/qtgui_tab_widget.block.yml	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/grc/qtgui_tab_widget.block.yml	2020-01-05 09:47:33.000000000 +0700
@@ -1,6 +1,6 @@
 id: qtgui_tab_widget
 label: QT GUI Tab Widget
-flags: [ python ]
+flags: [show_id, python ]
 
 parameters:
 -   id: num_tabs
diff -uNr gnuradio-3.8.0.0/gr-qtgui/include/gnuradio/qtgui/form_menus.h gnuradio-maint-3.8/gr-qtgui/include/gnuradio/qtgui/form_menus.h
--- gnuradio-3.8.0.0/gr-qtgui/include/gnuradio/qtgui/form_menus.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/include/gnuradio/qtgui/form_menus.h	2020-01-05 09:47:33.000000000 +0700
@@ -700,7 +700,6 @@
 
 private:
     QList<QAction*> d_act;
-    OtherAction* d_other;
     QActionGroup* d_grp;
 };
 
@@ -807,7 +806,6 @@
 
 private:
     QList<QAction*> d_act;
-    OtherAction* d_other;
     QActionGroup* d_grp;
     float d_off, d_high, d_medium, d_low;
 };
@@ -929,7 +927,6 @@
 private:
     QList<QAction*> d_act;
     QActionGroup* d_grp;
-    int d_which;
 };
 
 
@@ -1078,7 +1075,6 @@
 private:
     QActionGroup* d_grp;
     QList<QAction*> d_act;
-    OtherDualAction* d_other;
     QColor d_max_value, d_min_value;
     int d_which;
 };
diff -uNr gnuradio-3.8.0.0/gr-qtgui/include/gnuradio/qtgui/freq_sink_c.h gnuradio-maint-3.8/gr-qtgui/include/gnuradio/qtgui/freq_sink_c.h
--- gnuradio-3.8.0.0/gr-qtgui/include/gnuradio/qtgui/freq_sink_c.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/include/gnuradio/qtgui/freq_sink_c.h	2020-01-05 09:47:33.000000000 +0700
@@ -45,7 +45,7 @@
  * This is a QT-based graphical sink the takes set of a complex
  * streams and plots the PSD. Each signal is plotted with a
  * different color, and the \a set_title and \a set_color
- * functions can be used to change the lable and color for a given
+ * functions can be used to change the label and color for a given
  * input number.
  *
  * The sink supports plotting streaming complex data or
diff -uNr gnuradio-3.8.0.0/gr-qtgui/include/gnuradio/qtgui/freq_sink_f.h gnuradio-maint-3.8/gr-qtgui/include/gnuradio/qtgui/freq_sink_f.h
--- gnuradio-3.8.0.0/gr-qtgui/include/gnuradio/qtgui/freq_sink_f.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/include/gnuradio/qtgui/freq_sink_f.h	2020-01-05 09:47:33.000000000 +0700
@@ -45,7 +45,7 @@
  * This is a QT-based graphical sink the takes set of a floating
  * point streams and plots the PSD. Each signal is plotted with a
  * different color, and the \a set_title and \a set_color
- * functions can be used to change the lable and color for a given
+ * functions can be used to change the label and color for a given
  * input number.
  *
  * The sink supports plotting streaming float data or
diff -uNr gnuradio-3.8.0.0/gr-qtgui/include/gnuradio/qtgui/plot_raster.h gnuradio-maint-3.8/gr-qtgui/include/gnuradio/qtgui/plot_raster.h
--- gnuradio-3.8.0.0/gr-qtgui/include/gnuradio/qtgui/plot_raster.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/include/gnuradio/qtgui/plot_raster.h	2020-01-05 09:47:33.000000000 +0700
@@ -69,11 +69,6 @@
 
     virtual int rtti() const;
 
-    virtual void draw(QPainter* p,
-                      const QwtScaleMap& xMap,
-                      const QwtScaleMap& yMap,
-                      const QRect& rect) const;
-
 protected:
 #if QWT_VERSION < 0x060000
     QImage renderImage(const QwtScaleMap& xMap,
diff -uNr gnuradio-3.8.0.0/gr-qtgui/include/gnuradio/qtgui/plot_waterfall.h gnuradio-maint-3.8/gr-qtgui/include/gnuradio/qtgui/plot_waterfall.h
--- gnuradio-3.8.0.0/gr-qtgui/include/gnuradio/qtgui/plot_waterfall.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/include/gnuradio/qtgui/plot_waterfall.h	2020-01-05 09:47:33.000000000 +0700
@@ -64,11 +64,6 @@
 
     virtual int rtti() const;
 
-    virtual void draw(QPainter* p,
-                      const QwtScaleMap& xMap,
-                      const QwtScaleMap& yMap,
-                      const QRect& rect) const;
-
 protected:
 #if QWT_VERSION < 0x060000
     QImage renderImage(const QwtScaleMap& xMap,
diff -uNr gnuradio-3.8.0.0/gr-qtgui/include/gnuradio/qtgui/time_raster_sink_b.h gnuradio-maint-3.8/gr-qtgui/include/gnuradio/qtgui/time_raster_sink_b.h
--- gnuradio-3.8.0.0/gr-qtgui/include/gnuradio/qtgui/time_raster_sink_b.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/include/gnuradio/qtgui/time_raster_sink_b.h	2020-01-05 09:47:33.000000000 +0700
@@ -98,7 +98,7 @@
 
     virtual void set_update_time(double t) = 0;
     virtual void set_title(const std::string& title) = 0;
-    virtual void set_line_label(unsigned int which, const std::string& lable) = 0;
+    virtual void set_line_label(unsigned int which, const std::string& label) = 0;
     virtual void set_line_color(unsigned int which, const std::string& color) = 0;
     virtual void set_line_width(unsigned int which, int width) = 0;
     virtual void set_line_style(unsigned int which, Qt::PenStyle style) = 0;
diff -uNr gnuradio-3.8.0.0/gr-qtgui/include/gnuradio/qtgui/time_raster_sink_f.h gnuradio-maint-3.8/gr-qtgui/include/gnuradio/qtgui/time_raster_sink_f.h
--- gnuradio-3.8.0.0/gr-qtgui/include/gnuradio/qtgui/time_raster_sink_f.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/include/gnuradio/qtgui/time_raster_sink_f.h	2020-01-05 09:47:33.000000000 +0700
@@ -94,7 +94,7 @@
 
     virtual void set_update_time(double t) = 0;
     virtual void set_title(const std::string& title) = 0;
-    virtual void set_line_label(unsigned int which, const std::string& lable) = 0;
+    virtual void set_line_label(unsigned int which, const std::string& label) = 0;
     virtual void set_line_color(unsigned int which, const std::string& color) = 0;
     virtual void set_line_width(unsigned int which, int width) = 0;
     virtual void set_line_style(unsigned int which, Qt::PenStyle style) = 0;
diff -uNr gnuradio-3.8.0.0/gr-qtgui/include/gnuradio/qtgui/time_sink_c.h gnuradio-maint-3.8/gr-qtgui/include/gnuradio/qtgui/time_sink_c.h
--- gnuradio-3.8.0.0/gr-qtgui/include/gnuradio/qtgui/time_sink_c.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/include/gnuradio/qtgui/time_sink_c.h	2020-01-05 09:47:33.000000000 +0700
@@ -45,7 +45,7 @@
  * streams and plots them in the time domain. For each signal, both
  * the signal's I and Q parts are plotted, and they are all plotted
  * with a different color, and the \a set_title and \a set_color
- * functions can be used to change the lable and color for a given
+ * functions can be used to change the label and color for a given
  * input number.
  *
  * The sink supports plotting streaming complex data or
diff -uNr gnuradio-3.8.0.0/gr-qtgui/include/gnuradio/qtgui/time_sink_f.h gnuradio-maint-3.8/gr-qtgui/include/gnuradio/qtgui/time_sink_f.h
--- gnuradio-3.8.0.0/gr-qtgui/include/gnuradio/qtgui/time_sink_f.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/include/gnuradio/qtgui/time_sink_f.h	2020-01-05 09:47:33.000000000 +0700
@@ -44,7 +44,7 @@
  * This is a QT-based graphical sink the takes set of a float streams
  * and plots them in the time domain. Each signal is plotted with a
  * different color, and the \a set_title and \a set_color functions
- * can be used to change the lable and color for a given input number.
+ * can be used to change the label and color for a given input number.
  *
  * The sink supports plotting streaming float data or
  * messages. The message port is named "in". The two modes cannot
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/TimeDomainDisplayPlot.cc gnuradio-maint-3.8/gr-qtgui/lib/TimeDomainDisplayPlot.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/TimeDomainDisplayPlot.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/TimeDomainDisplayPlot.cc	2020-01-05 09:47:33.000000000 +0700
@@ -260,7 +260,7 @@
             // Plot and attach any new tags found.
             // First test if this was a complex input where real/imag get
             // split here into two stream.
-            if (tags.size() > 0) {
+            if (!tags.empty()) {
                 bool cmplx = false;
                 unsigned int mult = d_nplots / tags.size();
                 if (mult == 2)
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/ber_sink_b_impl.cc gnuradio-maint-3.8/gr-qtgui/lib/ber_sink_b_impl.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/ber_sink_b_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/ber_sink_b_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -109,7 +109,7 @@
 
     if (curvenames.size() == (unsigned int)curves) {
         for (int j = 0; j < curves; j++) {
-            if (curvenames[j] != "") {
+            if (!curvenames[j].empty()) {
                 set_line_label(j, curvenames[j]);
             }
         }
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/const_sink_c_impl.cc gnuradio-maint-3.8/gr-qtgui/lib/const_sink_c_impl.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/const_sink_c_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/const_sink_c_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -138,7 +138,7 @@
     d_main_gui = new ConstellationDisplayForm(numplots, d_parent);
     d_main_gui->setNPoints(d_size);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     // initialize update time to 10 times a second
@@ -364,7 +364,7 @@
     uint64_t nr = nitems_read(d_trigger_channel);
     std::vector<gr::tag_t> tags;
     get_tags_in_range(tags, d_trigger_channel, nr, nr + nitems, d_trigger_tag_key);
-    if (tags.size() > 0) {
+    if (!tags.empty()) {
         d_triggered = true;
         trigger_index = tags[0].offset - nr;
         d_start = d_index + trigger_index;
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/edit_box_msg_impl.cc gnuradio-maint-3.8/gr-qtgui/lib/edit_box_msg_impl.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/edit_box_msg_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/edit_box_msg_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -106,7 +106,7 @@
             d_key->setFixedWidth(width);
 
             // Verify that a default key has been set or emit an error
-            if (key.size() == 0) {
+            if (key.empty()) {
                 throw std::runtime_error(
                     "When using static + pair mode, please set a default key.");
             }
@@ -118,7 +118,7 @@
     }
 
     d_label = NULL;
-    if (label != "") {
+    if (!label.empty()) {
         d_label = new QLabel(QString(label.c_str()));
         d_vlayout->addWidget(d_label);
     }
@@ -481,7 +481,6 @@
         std::vector<gr_complex> xv;
         QStringList text_list = text.split(",");
         bool even = false;
-        gr_complex c;
         float re, im;
         for (int i = 0; i < text_list.size(); ++i) {
             QString s = text_list.at(i);
@@ -492,7 +491,7 @@
             if (conv_ok) {
                 if (even) {
                     im = t;
-                    xv.push_back(gr_complex(re, im));
+                    xv.emplace_back(re, im);
                     even = false;
                 } else {
                     re = t;
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/freq_sink_c_impl.cc gnuradio-maint-3.8/gr-qtgui/lib/freq_sink_c_impl.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/freq_sink_c_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/freq_sink_c_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2012,2014-2015 Free Software Foundation, Inc.
+ * Copyright 2012,2014-2015,2019 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -33,6 +33,7 @@
 #include <volk/volk.h>
 
 #include <string.h>
+#include <algorithm>
 
 namespace gr {
 namespace qtgui {
@@ -111,7 +112,7 @@
         d_magbufs.push_back(
             (double*)volk_malloc(d_fftsize * sizeof(double), volk_get_alignment()));
 
-        memset(d_residbufs[i], 0, d_fftsize * sizeof(gr_complex));
+        std::fill_n(d_residbufs[i], d_fftsize, 0);
         memset(d_magbufs[i], 0, d_fftsize * sizeof(double));
     }
 
@@ -119,7 +120,7 @@
         (gr_complex*)volk_malloc(d_fftsize * sizeof(gr_complex), volk_get_alignment()));
     d_pdu_magbuf = (double*)volk_malloc(d_fftsize * sizeof(double), volk_get_alignment());
     d_magbufs.push_back(d_pdu_magbuf);
-    memset(d_residbufs[d_nconnections], 0, d_fftsize * sizeof(gr_complex));
+    std::fill_n(d_residbufs[d_nconnections], d_fftsize, 0);
     memset(d_pdu_magbuf, 0, d_fftsize * sizeof(double));
 
     buildwindow();
@@ -171,7 +172,7 @@
     set_fft_size(d_fftsize);
     set_frequency_range(d_center_freq, d_bandwidth);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     set_output_multiple(d_fftsize);
@@ -387,7 +388,7 @@
 
 void freq_sink_c_impl::fft(float* data_out, const gr_complex* data_in, int size)
 {
-    if (d_window.size()) {
+    if (!d_window.empty()) {
         volk_32fc_32f_multiply_32fc(d_fft->get_inbuf(), data_in, &d_window.front(), size);
     } else {
         memcpy(d_fft->get_inbuf(), data_in, sizeof(gr_complex) * size);
@@ -442,7 +443,7 @@
             d_magbufs[i] =
                 (double*)volk_malloc(newfftsize * sizeof(double), volk_get_alignment());
 
-            memset(d_residbufs[i], 0, newfftsize * sizeof(gr_complex));
+            std::fill_n(d_residbufs[i], newfftsize, 0);
             memset(d_magbufs[i], 0, newfftsize * sizeof(double));
         }
 
@@ -529,7 +530,7 @@
     std::vector<gr::tag_t> tags;
     get_tags_in_range(
         tags, d_trigger_channel, nr + start, nr + start + nitems, d_trigger_tag_key);
-    if (tags.size() > 0) {
+    if (!tags.empty()) {
         d_triggered = true;
         d_index = tags[0].offset - nr;
         d_trigger_count = 0;
@@ -672,7 +673,7 @@
         size_t max = std::min(d_fftsize, static_cast<int>(len));
         for (int n = 0; n < nffts; n++) {
             // Clear in case (max-min) < d_fftsize
-            memset(d_residbufs[d_nconnections], 0x00, sizeof(gr_complex) * d_fftsize);
+            std::fill_n(d_residbufs[d_nconnections], d_fftsize, 0x00);
 
             // Copy in as much of the input samples as we can
             memcpy(
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/freq_sink_f_impl.cc gnuradio-maint-3.8/gr-qtgui/lib/freq_sink_f_impl.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/freq_sink_f_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/freq_sink_f_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -172,7 +172,7 @@
     set_fft_size(d_fftsize);
     set_frequency_range(d_center_freq, d_bandwidth);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     set_output_multiple(d_fftsize);
@@ -394,7 +394,7 @@
     for (int i = 0; i < size; i++)
         dst[i] = data_in[i];
 
-    if (d_window.size()) {
+    if (!d_window.empty()) {
         volk_32fc_32f_multiply_32fc(d_fft->get_inbuf(), dst, &d_window.front(), size);
     }
 
@@ -533,7 +533,7 @@
     std::vector<gr::tag_t> tags;
     get_tags_in_range(
         tags, d_trigger_channel, nr + start, nr + start + nitems, d_trigger_tag_key);
-    if (tags.size() > 0) {
+    if (!tags.empty()) {
         d_triggered = true;
         d_index = tags[0].offset - nr;
         d_trigger_count = 0;
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/freqdisplayform.cc gnuradio-maint-3.8/gr-qtgui/lib/freqdisplayform.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/freqdisplayform.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/freqdisplayform.cc	2020-01-05 09:47:33.000000000 +0700
@@ -423,7 +423,7 @@
     }
 
     // if tag mode, popup tag key box to set
-    if ((d_trig_tag_key == "") && (d_trig_mode == gr::qtgui::TRIG_MODE_TAG))
+    if ((d_trig_tag_key.empty()) && (d_trig_mode == gr::qtgui::TRIG_MODE_TAG))
         d_tr_tag_key_act->activate(QAction::Trigger);
 
     emit signalReplot();
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/histogram_sink_f_impl.cc gnuradio-maint-3.8/gr-qtgui/lib/histogram_sink_f_impl.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/histogram_sink_f_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/histogram_sink_f_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -137,7 +137,7 @@
     d_main_gui->setNPoints(d_size);
     d_main_gui->setXaxis(d_xmin, d_xmax);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     // initialize update time to 10 times a second
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/numberdisplayform.cc gnuradio-maint-3.8/gr-qtgui/lib/numberdisplayform.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/numberdisplayform.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/numberdisplayform.cc	2020-01-05 09:47:33.000000000 +0700
@@ -40,7 +40,7 @@
         d_min.push_back(+1e32);
         d_max.push_back(-1e32);
         d_label.push_back(new QLabel(QString("Data %1").arg(i)));
-        d_unit.push_back("");
+        d_unit.emplace_back("");
         d_factor.push_back(1);
         d_text_box.push_back(new QLabel(QString("0")));
 
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/plot_raster.cc gnuradio-maint-3.8/gr-qtgui/lib/plot_raster.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/plot_raster.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/plot_raster.cc	2020-01-05 09:47:33.000000000 +0700
@@ -299,22 +299,3 @@
 }
 #endif
 
-/*!
-  \brief Draw the raster
-
-  \param painter Painter
-  \param xMap Maps x-values into pixel coordinates.
-  \param yMap Maps y-values into pixel coordinates.
-  \param canvasRect Contents rect of the canvas in painter coordinates
-
-  \sa setDisplayMode, renderImage,
-  QwtPlotRasterItem::draw, drawContourLines
-*/
-
-void PlotTimeRaster::draw(QPainter* painter,
-                          const QwtScaleMap& xMap,
-                          const QwtScaleMap& yMap,
-                          const QRect& canvasRect) const
-{
-    QwtPlotRasterItem::draw(painter, xMap, yMap, canvasRect);
-}
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/plot_waterfall.cc gnuradio-maint-3.8/gr-qtgui/lib/plot_waterfall.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/plot_waterfall.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/plot_waterfall.cc	2020-01-05 09:47:33.000000000 +0700
@@ -280,22 +280,3 @@
     return image;
 }
 
-/*!
-  \brief Draw the spectrogram
-
-  \param painter Painter
-  \param xMap Maps x-values into pixel coordinates.
-  \param yMap Maps y-values into pixel coordinates.
-  \param canvasRect Contents rect of the canvas in painter coordinates
-
-  \sa setDisplayMode, renderImage,
-  QwtPlotRasterItem::draw, drawContourLines
-*/
-
-void PlotWaterfall::draw(QPainter* painter,
-                         const QwtScaleMap& xMap,
-                         const QwtScaleMap& yMap,
-                         const QRect& canvasRect) const
-{
-    QwtPlotRasterItem::draw(painter, xMap, yMap, canvasRect);
-}
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/qtgui_util.cc gnuradio-maint-3.8/gr-qtgui/lib/qtgui_util.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/qtgui_util.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/qtgui_util.cc	2020-01-05 09:47:33.000000000 +0700
@@ -104,7 +104,7 @@
 void check_set_qss(QApplication* app)
 {
     std::string qssfile = gr::prefs::singleton()->get_string("qtgui", "qss", "");
-    if (qssfile.size() > 0) {
+    if (!qssfile.empty()) {
         QString sstext = get_qt_style_sheet(QString(qssfile.c_str()));
         app->setStyleSheet(sstext);
     }
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/sink_c_impl.cc gnuradio-maint-3.8/gr-qtgui/lib/sink_c_impl.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/sink_c_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/sink_c_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -238,7 +238,7 @@
 
 void sink_c_impl::fft(float* data_out, const gr_complex* data_in, int size)
 {
-    if (d_window.size()) {
+    if (!d_window.empty()) {
         volk_32fc_32f_multiply_32fc(d_fft->get_inbuf(), data_in, &d_window.front(), size);
     } else {
         memcpy(d_fft->get_inbuf(), data_in, sizeof(gr_complex) * size);
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/sink_f_impl.cc gnuradio-maint-3.8/gr-qtgui/lib/sink_f_impl.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/sink_f_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/sink_f_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -228,7 +228,7 @@
 
 void sink_f_impl::fft(float* data_out, const float* data_in, int size)
 {
-    if (d_window.size()) {
+    if (!d_window.empty()) {
         gr_complex* dst = d_fft->get_inbuf();
         for (int i = 0; i < size; i++) // apply window
             dst[i] = data_in[i] * d_window[i];
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/spectrumdisplayform.cc gnuradio-maint-3.8/gr-qtgui/lib/spectrumdisplayform.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/spectrumdisplayform.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/spectrumdisplayform.cc	2020-01-05 09:47:33.000000000 +0700
@@ -484,7 +484,7 @@
 void SpectrumDisplayForm::_averageHistory(const double* newBuffer)
 {
     if (_numRealDataPoints > 0) {
-        if (_historyVector->size() > 0) {
+        if (!_historyVector->empty()) {
             memcpy(_historyVector->operator[](_historyEntry),
                    newBuffer,
                    _numRealDataPoints * sizeof(double));
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/time_raster_sink_b_impl.cc gnuradio-maint-3.8/gr-qtgui/lib/time_raster_sink_b_impl.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/time_raster_sink_b_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/time_raster_sink_b_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -146,7 +146,7 @@
     d_main_gui =
         new TimeRasterDisplayForm(numplots, d_samp_rate, d_rows, d_cols, 1, d_parent);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     // initialize update time to 10 times a second
@@ -297,7 +297,7 @@
 
 void time_raster_sink_b_impl::set_multiplier(const std::vector<float>& mult)
 {
-    if (mult.size() == 0) {
+    if (mult.empty()) {
         for (int i = 0; i < d_nconnections + 1; i++) {
             d_mult[i] = 1.0f;
         }
@@ -317,7 +317,7 @@
 
 void time_raster_sink_b_impl::set_offset(const std::vector<float>& offset)
 {
-    if (offset.size() == 0) {
+    if (offset.empty()) {
         for (int i = 0; i < d_nconnections + 1; i++) {
             d_offset[i] = 0.0f;
         }
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/time_raster_sink_f_impl.cc gnuradio-maint-3.8/gr-qtgui/lib/time_raster_sink_f_impl.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/time_raster_sink_f_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/time_raster_sink_f_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -144,7 +144,7 @@
     d_main_gui =
         new TimeRasterDisplayForm(numplots, d_samp_rate, d_rows, d_cols, 1, d_parent);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     // initialize update time to 10 times a second
@@ -300,7 +300,7 @@
 
 void time_raster_sink_f_impl::set_multiplier(const std::vector<float>& mult)
 {
-    if (mult.size() == 0) {
+    if (mult.empty()) {
         for (int i = 0; i < d_nconnections; i++) {
             d_mult[i] = 1.0f;
         }
@@ -316,7 +316,7 @@
 
 void time_raster_sink_f_impl::set_offset(const std::vector<float>& offset)
 {
-    if (offset.size() == 0) {
+    if (offset.empty()) {
         for (int i = 0; i < d_nconnections; i++) {
             d_offset[i] = 0.0f;
         }
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/time_sink_c_impl.cc gnuradio-maint-3.8/gr-qtgui/lib/time_sink_c_impl.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/time_sink_c_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/time_sink_c_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2011-2013,2015 Free Software Foundation, Inc.
+ * Copyright 2011-2013,2015,2019 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -34,6 +34,7 @@
 #include <volk/volk.h>
 
 #include <string.h>
+#include <algorithm>
 
 namespace gr {
 namespace qtgui {
@@ -92,7 +93,7 @@
     for (unsigned int n = 0; n < d_nconnections / 2; n++) {
         d_cbuffers.push_back((gr_complex*)volk_malloc(d_buffer_size * sizeof(gr_complex),
                                                       volk_get_alignment()));
-        memset(d_cbuffers[n], 0, d_buffer_size * sizeof(gr_complex));
+        std::fill_n(d_cbuffers[n], d_buffer_size, 0);
     }
 
     // Set alignment properties for VOLK
@@ -151,7 +152,7 @@
     d_main_gui->setNPoints(d_size);
     d_main_gui->setSampleRate(d_samp_rate);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     // initialize update time to 10 times a second
@@ -323,7 +324,7 @@
             volk_free(d_cbuffers[n]);
             d_cbuffers[n] = (gr_complex*)volk_malloc(d_buffer_size * sizeof(gr_complex),
                                                      volk_get_alignment());
-            memset(d_cbuffers[n], 0, d_buffer_size * sizeof(gr_complex));
+            std::fill_n(d_cbuffers[n], d_buffer_size, 0);
         }
 
         // If delay was set beyond the new boundary, pull it back.
@@ -496,7 +497,7 @@
     std::vector<gr::tag_t> tags;
     get_tags_in_range(
         tags, d_trigger_channel / 2, nr, nr + nitems + 1, d_trigger_tag_key);
-    if (tags.size() > 0) {
+    if (!tags.empty()) {
         trigger_index = tags[0].offset - nr;
         int start = d_index + trigger_index - d_trigger_delay - 1;
         if (start >= 0) {
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/time_sink_c_impl.h gnuradio-maint-3.8/gr-qtgui/lib/time_sink_c_impl.h
--- gnuradio-3.8.0.0/gr-qtgui/lib/time_sink_c_impl.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/time_sink_c_impl.h	2020-01-05 09:47:33.000000000 +0700
@@ -65,7 +65,6 @@
     pmt::pmt_t d_trigger_tag_key;
     bool d_triggered;
     int d_trigger_count;
-    int d_initial_delay; // used for limiting d_trigger_delay
 
     void _reset();
     void _npoints_resize();
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/time_sink_f_impl.cc gnuradio-maint-3.8/gr-qtgui/lib/time_sink_f_impl.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/time_sink_f_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/time_sink_f_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -147,7 +147,7 @@
     d_main_gui->setNPoints(d_size);
     d_main_gui->setSampleRate(d_samp_rate);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     // initialize update time to 10 times a second
@@ -489,7 +489,7 @@
     uint64_t nr = nitems_read(d_trigger_channel);
     std::vector<gr::tag_t> tags;
     get_tags_in_range(tags, d_trigger_channel, nr, nr + nitems + 1, d_trigger_tag_key);
-    if (tags.size() > 0) {
+    if (!tags.empty()) {
         trigger_index = tags[0].offset - nr;
         int start = d_index + trigger_index - d_trigger_delay - 1;
         if (start >= 0) {
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/time_sink_f_impl.h gnuradio-maint-3.8/gr-qtgui/lib/time_sink_f_impl.h
--- gnuradio-3.8.0.0/gr-qtgui/lib/time_sink_f_impl.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/time_sink_f_impl.h	2020-01-05 09:47:33.000000000 +0700
@@ -63,7 +63,6 @@
     pmt::pmt_t d_trigger_tag_key;
     bool d_triggered;
     int d_trigger_count;
-    int d_initial_delay; // used for limiting d_trigger_delay
 
     void _reset();
     void _npoints_resize();
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/timedisplayform.cc gnuradio-maint-3.8/gr-qtgui/lib/timedisplayform.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/timedisplayform.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/timedisplayform.cc	2020-01-05 09:47:33.000000000 +0700
@@ -376,7 +376,7 @@
     }
 
     // if tag mode, popup tag key box to set
-    if ((d_trig_tag_key == "") && (d_trig_mode == gr::qtgui::TRIG_MODE_TAG))
+    if ((d_trig_tag_key.empty()) && (d_trig_mode == gr::qtgui::TRIG_MODE_TAG))
         d_tr_tag_key_act->activate(QAction::Trigger);
 
     emit signalReplot();
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/waterfall_sink_c_impl.cc gnuradio-maint-3.8/gr-qtgui/lib/waterfall_sink_c_impl.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/waterfall_sink_c_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/waterfall_sink_c_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2012,2014-2015 Free Software Foundation, Inc.
+ * Copyright 2012,2014-2015,2019 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -34,6 +34,7 @@
 
 #include <string.h>
 #include <iostream>
+#include <algorithm>
 
 namespace gr {
 namespace qtgui {
@@ -98,7 +99,7 @@
                                                        volk_get_alignment()));
         d_magbufs.push_back(
             (double*)volk_malloc(d_fftsize * sizeof(double), volk_get_alignment()));
-        memset(d_residbufs[i], 0, d_fftsize * sizeof(gr_complex));
+        std::fill_n(d_residbufs[i], d_fftsize, 0);
         memset(d_magbufs[i], 0, d_fftsize * sizeof(double));
     }
 
@@ -108,7 +109,7 @@
         (double*)volk_malloc(d_fftsize * sizeof(double) * d_nrows, volk_get_alignment());
     d_magbufs.push_back(d_pdu_magbuf);
     memset(d_pdu_magbuf, 0, d_fftsize * sizeof(double) * d_nrows);
-    memset(d_residbufs[d_nconnections], 0, d_fftsize * sizeof(gr_complex));
+    std::fill_n(d_residbufs[d_nconnections], d_fftsize, 0);
 
     buildwindow();
 
@@ -182,7 +183,7 @@
     set_fft_size(d_fftsize);
     set_frequency_range(d_center_freq, d_bandwidth);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     // initialize update time to 10 times a second
@@ -318,7 +319,7 @@
 
 void waterfall_sink_c_impl::fft(float* data_out, const gr_complex* data_in, int size)
 {
-    if (d_window.size()) {
+    if (!d_window.empty()) {
         volk_32fc_32f_multiply_32fc(d_fft->get_inbuf(), data_in, &d_window.front(), size);
     } else {
         memcpy(d_fft->get_inbuf(), data_in, sizeof(gr_complex) * size);
@@ -371,7 +372,7 @@
             d_magbufs[i] =
                 (double*)volk_malloc(newfftsize * sizeof(double), volk_get_alignment());
 
-            memset(d_residbufs[i], 0, newfftsize * sizeof(gr_complex));
+            std::fill_n(d_residbufs[i], newfftsize, 0);
             memset(d_magbufs[i], 0, newfftsize * sizeof(double));
         }
 
@@ -385,7 +386,7 @@
         d_pdu_magbuf = (double*)volk_malloc(newfftsize * sizeof(double) * d_nrows,
                                             volk_get_alignment());
         d_magbufs[d_nconnections] = d_pdu_magbuf;
-        memset(d_residbufs[d_nconnections], 0, newfftsize * sizeof(gr_complex));
+        std::fill_n(d_residbufs[d_nconnections], newfftsize, 0);
         memset(d_pdu_magbuf, 0, newfftsize * sizeof(double) * d_nrows);
 
         // Set new fft size and reset buffer index
@@ -558,7 +559,7 @@
         size_t max = std::min(d_fftsize, static_cast<int>(len));
         for (size_t i = 0; j < d_nrows; i += stride) {
             // Clear residbufs if len < d_fftsize
-            memset(d_residbufs[d_nconnections], 0x00, sizeof(gr_complex) * d_fftsize);
+            std::fill_n(d_residbufs[d_nconnections], d_fftsize, 0x00);
 
             // Copy in as much of the input samples as we can
             memcpy(
diff -uNr gnuradio-3.8.0.0/gr-qtgui/lib/waterfall_sink_f_impl.cc gnuradio-maint-3.8/gr-qtgui/lib/waterfall_sink_f_impl.cc
--- gnuradio-3.8.0.0/gr-qtgui/lib/waterfall_sink_f_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-qtgui/lib/waterfall_sink_f_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -181,7 +181,7 @@
     set_fft_size(d_fftsize);
     set_frequency_range(d_center_freq, d_bandwidth);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     // initialize update time to 10 times a second
@@ -327,7 +327,7 @@
     for (int i = 0; i < size; i++)
         dst[i] = data_in[i];
 
-    if (d_window.size()) {
+    if (!d_window.empty()) {
         volk_32fc_32f_multiply_32fc(d_fft->get_inbuf(), dst, &d_window.front(), size);
     }
 
diff -uNr gnuradio-3.8.0.0/gr-trellis/docs/gr-trellis.xml gnuradio-maint-3.8/gr-trellis/docs/gr-trellis.xml
--- gnuradio-3.8.0.0/gr-trellis/docs/gr-trellis.xml	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-trellis/docs/gr-trellis.xml	2020-01-05 09:47:33.000000000 +0700
@@ -52,7 +52,7 @@
 code (CC), a trellis code (TC), an inter-symbol interference (ISI)
 channel, or any
 other communication system that can be modeled with an FSM.
-To achieve this goal, we need to separate the pure FSM descrition from the
+To achieve this goal, we need to separate the pure FSM description from the
 rest of the model details. For instance, in the case of a rate 2/3 TC,
 the FSM should not involve details about the modulation used (it can
 be an 8-ary PAM, or 8-PSK, etc). Similarly, when attempting maximum likelihood
@@ -272,7 +272,7 @@
 
 <listitem>
 <para>
-The fourth way is specific to FSMs resulting from shift registers, and the output symbol being the entire transition (ie, current_state and current_input). These FSMs are usefull when describibg ISI channels. In particular the state is comprised of the input symbols x(k-1), x(k-2),...,x(k-L), where L = ch_length-1 and each x(i) belongs to an alphabet of size mod_size. The output is taken to be x(k), x(k-1), x(k-2),...,x(k-L) (in decimal format)
+The fourth way is specific to FSMs resulting from shift registers, and the output symbol being the entire transition (ie, current_state and current_input). These FSMs are useful when describing ISI channels. In particular the state is comprised of the input symbols x(k-1), x(k-2),...,x(k-L), where L = ch_length-1 and each x(i) belongs to an alphabet of size mod_size. The output is taken to be x(k), x(k-1), x(k-2),...,x(k-L) (in decimal format)
 </para>
 <programlisting>
   fsm(const int mod_size, const int ch_length);
@@ -365,7 +365,7 @@
 The input is a sequence of K x FSM.O( ) floats, where the k x K + i
 float represents the cost associated with the k-th
 step in the trellis and the i-th FSM output.
-Observe that these inputs are generated externally and thus the Viterbi block is not informed of their meaning (they can be genarated as soft or hard inputs, etc); the only requirement is that they represent additive costs.
+Observe that these inputs are generated externally and thus the Viterbi block is not informed of their meaning (they can be generated as soft or hard inputs, etc); the only requirement is that they represent additive costs.
 </para>
 </sect2>
 
@@ -393,7 +393,7 @@
 ||r<subscript>k</subscript>-c<subscript>i</subscript>||<superscript>2</superscript> = sum<subscript>j=1</subscript><superscript>D</superscript> |r<subscript>k,j</subscript>-c<subscript>i,j</subscript>|<superscript>2</superscript>
 </para>
 <para>
-for each of the O hypothesized ouput
+for each of the O hypothesized output
 symbols c<subscript>i</subscript> = (c<subscript>i,1</subscript>,c<subscript>i,2</subscript>,...,c<subscript>i,D</subscript>) defined in the vector TABLE,
 where TABLE[i * D + j] = c<subscript>i,j</subscript>.
 </para></listitem>
@@ -446,7 +446,7 @@
 Although the separation of metric calculation and Viterbi algorithm blocks
 is consistent with our goal of providing general blocks that can be easily
 reused, this separation might result in large input/output buffer sizes
-betwen blocks. Indeed for an FSM with a large output alphabet, the
+between blocks. Indeed for an FSM with a large output alphabet, the
 output of the metric block/input of the Viterbi block is FSM.O( ) floats for
 each trellis step. Sometimes this results in buffer overflow even for
 moderate sequence lengths.
@@ -522,7 +522,7 @@
 
 
 <para>
-The FSM will produce K output symbols (remeber the FSM produces always one output symbol for each input symbol). Each of these symbols needs to be modulated. Since we are simulating the communication system, we need not simulate the actual waveforms. An M-ary, D-dimensional
+The FSM will produce K output symbols (remember the FSM produces always one output symbol for each input symbol). Each of these symbols needs to be modulated. Since we are simulating the communication system, we need not simulate the actual waveforms. An M-ary, D-dimensional
 modulation is completely specified by a set of M, D-dimensional real vectors. In "fsm_utils.py" file we give a number of useful modulations with the following format: modulation = (D,constellation), where
 constellation=[c11,c12,...,c1D,c21,c22,...,c2D,...,cM1,cM2,...cMD].
 The meaning of the above is that every constellation point c_i
@@ -882,7 +882,7 @@
 the SISO blocks, as done in some of the python examples) there is an advantage
 in having this functionality as a single block. To see why, think of a turbo decoder with 10 iterations. Previously we needed to concatenate 10 x 2 SISO blocks
 (for a sccc decoder) to emulate the passing of soft information between SISOs over 10 iterartions. With the new block however, only a single such block is needed that internally loops through 10 iterations; this results in space savings
-and possibly time saving as well (since queueing at the input/ouput of the gr-blocks is avoided).
+and possibly time saving as well (since queueing at the input/output of the gr-blocks is avoided).
 
 
 Still need to document them...
diff -uNr gnuradio-3.8.0.0/gr-uhd/apps/uhd_fft gnuradio-maint-3.8/gr-uhd/apps/uhd_fft
--- gnuradio-3.8.0.0/gr-uhd/apps/uhd_fft	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-uhd/apps/uhd_fft	2020-01-05 09:47:33.000000000 +0700
@@ -1,4 +1,4 @@
-#!/usr/bin/env python2
+#!/usr/bin/env python
 #
 # Copyright 2015-2016,2018 Free Software Foundation, Inc.
 #
@@ -34,6 +34,8 @@
 # Note this is a heavily modified version of a
 # the uhd_fft.grc example.
 
+from __future__ import print_function
+from __future__ import division
 import ctypes
 import sys
 import sip
@@ -244,9 +246,9 @@
         self.qtgui_time_sink_x_0.disable_legend()
         for i in range(2*len(self.channels)):
             if(i % 2 == 0):
-                self.qtgui_time_sink_x_0.set_line_label(i, "Re{{Channel {0}}}".format(i/2))
+                self.qtgui_time_sink_x_0.set_line_label(i, "Re{{Channel {0}}}".format(i//2))
             else:
-                self.qtgui_time_sink_x_0.set_line_label(i, "Im{{Channel {0}}}".format(i/2))
+                self.qtgui_time_sink_x_0.set_line_label(i, "Im{{Channel {0}}}".format(i//2))
             self.qtgui_time_sink_x_0.set_line_width(i, widths[i])
             self.qtgui_time_sink_x_0.set_line_color(i, colors[i])
             self.qtgui_time_sink_x_0.set_line_style(i, styles[i])
@@ -510,4 +512,3 @@
         except:
             print("Warning: failed to XInitThreads()")
     main()
-
diff -uNr gnuradio-3.8.0.0/gr-uhd/apps/uhd_rx_cfile gnuradio-maint-3.8/gr-uhd/apps/uhd_rx_cfile
--- gnuradio-3.8.0.0/gr-uhd/apps/uhd_rx_cfile	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-uhd/apps/uhd_rx_cfile	2020-01-05 09:47:33.000000000 +0700
@@ -26,6 +26,7 @@
 (interleaved 16 bit signed short integers).
 """
 
+from __future__ import print_function
 import sys
 import os
 import pmt
@@ -179,13 +180,13 @@
                     rx_serial = info["rx_serial"]
                 rx_antenna = info["rx_antenna"]
                 rx_subdev_spec = info["rx_subdev_spec"]
-                print "[UHD_RX] Motherboard: %s (%s)" % (mboard_id, mboard_serial)
+                print("[UHD_RX] Motherboard: %s (%s)" % (mboard_id, mboard_serial))
                 if "B200" in mboard_id or "B210" in mboard_id or "E310" in mboard_id:
-                    print "[UHD_RX] Daughterboard: %s (%s, %s)" % (mboard_id, rx_antenna, rx_subdev_spec)
+                    print("[UHD_RX] Daughterboard: %s (%s, %s)" % (mboard_id, rx_antenna, rx_subdev_spec))
                 else:
-                    print "[UHD_RX] Daughterboard: %s (%s, %s, %s)" % (rx_id, rx_serial, rx_antenna, rx_subdev_spec)
+                    print("[UHD_RX] Daughterboard: %s (%s, %s, %s)" % (rx_id, rx_serial, rx_antenna, rx_subdev_spec))
             except KeyError:
-                print "[UHD_RX] Args: ", options.args
+                print("[UHD_RX] Args: ", options.args)
             print("[UHD_RX] Receiving on {} channels.".format(len(self.channels)))
             print("[UHD_RX] Rx gain:               {gain}".format(gain=gain))
             print("[UHD_RX] Rx frequency:          {freq}".format(freq=freq))
diff -uNr gnuradio-3.8.0.0/gr-uhd/apps/uhd_rx_nogui gnuradio-maint-3.8/gr-uhd/apps/uhd_rx_nogui
--- gnuradio-3.8.0.0/gr-uhd/apps/uhd_rx_nogui	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-uhd/apps/uhd_rx_nogui	2020-01-05 09:47:33.000000000 +0700
@@ -32,7 +32,7 @@
 AGC   - Automatic gain control leveling signal at [-1.0, +1.0]
 DEMOD - Demodulation block appropriate to selected signal type.
         This converts the complex baseband to real audio frequencies,
-	and applies an appropriate low pass decimating filter.
+        and applies an appropriate low pass decimating filter.
 CTCSS - Optional tone squelch zeroing output when tone is not present.
 RSAMP - Resampler block to convert audio sample rate to user specified
         sound card output rate.
@@ -40,8 +40,8 @@
 
 The following are required command line parameters:
 
--f FREQ		USRP receive frequency
--m MOD		Modulation type, select from AM, FM, or WFM
+-f FREQ         USRP receive frequency
+-m MOD          Modulation type, select from AM, FM, or WFM
 
 The following are optional command line parameters:
 
@@ -51,8 +51,8 @@
 -g GAIN         Daughterboard gain setting. Defaults to mid-range.
 -o RATE         Sound card output rate. Defaults to 32000. Useful if
                 your sound card only accepts particular sample rates.
--r RFSQL	RF squelch in db. Defaults to -50.0.
--p FREQ		CTCSS frequency.  Opens squelch when tone is present.
+-r RFSQL        RF squelch in db. Defaults to -50.0.
+-p FREQ         CTCSS frequency.  Opens squelch when tone is present.
 
 Once the program is running, ctrl-break (Ctrl-C) stops operation.
 
@@ -61,6 +61,7 @@
 """
 
 from __future__ import print_function
+from __future__ import division
 import sys
 from argparse import ArgumentParser
 from gnuradio import gr, gru, uhd, audio
@@ -72,10 +73,10 @@
 
 # (device_rate, channel_rate, audio_rate, channel_pass, channel_stop, demod)
 DEMOD_PARAMS = {
-		'AM'  : (256e3,  16e3, 16e3,  5000,   8000, analog.demod_10k0a3e_cf),
-		'FM'  : (256e3,  32e3,  8e3,  8000,   9000, analog.demod_20k0f3e_cf),
-		'WFM' : (320e3, 320e3, 32e3, 80000, 115000, analog.demod_200kf3e_cf)
-	       }
+                'AM'  : (256e3,  16e3, 16e3,  5000,   8000, analog.demod_10k0a3e_cf),
+                'FM'  : (256e3,  32e3,  8e3,  8000,   9000, analog.demod_20k0f3e_cf),
+                'WFM' : (320e3, 320e3, 32e3, 80000, 115000, analog.demod_200kf3e_cf)
+               }
 
 class uhd_src(gr.hier_block2):
     """
@@ -140,37 +141,37 @@
         dev = uhd_src(options.args,             # UHD device address
                       options.spec,             # device subdev spec
                       options.antenna,          # device antenna
-                      dev_rate,         	# device sample rate
-                      options.gain, 	    	# Receiver gain
+                      dev_rate,                 # device sample rate
+                      options.gain,             # Receiver gain
                       options.calibration)      # Frequency offset
         dev.tune(options.frequency)
 
         if_rate = dev.rate()
-        channel_decim = int(if_rate // channel_rate)
-        audio_decim = int(channel_rate // audio_rate)
+        channel_decim = if_rate // channel_rate
+        audio_decim = channel_rate // audio_rate
 
         chan_taps = filter.optfir.low_pass(1.0,          # Filter gain
-                                           if_rate, 	 # Sample rate
+                                           if_rate,      # Sample rate
                                            channel_pass, # One sided modulation bandwidth
                                            channel_stop, # One sided channel bandwidth
-                                           0.1, 	 # Passband ripple
-                                           60) 	         # Stopband attenuation
+                                           0.1,          # Passband ripple
+                                           60)           # Stopband attenuation
 
         chan = filter.freq_xlating_fir_filter_ccf(
             channel_decim, # Decimation rate
             chan_taps,     # Filter taps
-            0.0, 	   # Offset frequency
+            0.0,           # Offset frequency
             if_rate)       # Sample rate
 
         rfsql = analog.pwr_squelch_cc(
             options.rf_squelch,    # Power threshold
             125.0/channel_rate,    # Time constant
             int(channel_rate/20),  # 50ms rise/fall
-            False)		   # Zero, not gate output
+            False)                 # Zero, not gate output
 
         agc = analog.agc_cc(1.0/channel_rate,  # Time constant
-                            1.0,     	       # Reference power
-                            1.0)	       # Gain
+                            1.0,               # Reference power
+                            1.0)               # Gain
 
         demod = demod(channel_rate, audio_decim)
 
@@ -188,8 +189,8 @@
 
         if options.output_rate != audio_rate:
             out_lcm = gru.lcm(audio_rate, options.output_rate)
-            out_interp = int(out_lcm // audio_rate)
-            out_decim = int(out_lcm // options.output_rate)
+            out_interp = out_lcm // audio_rate
+            out_decim = out_lcm // options.output_rate
             rsamp = filter.rational_resampler_fff(out_interp, out_decim)
             self.connect(tail, rsamp)
             tail = rsamp
diff -uNr gnuradio-3.8.0.0/gr-uhd/examples/c++/tag_source_demo.h gnuradio-maint-3.8/gr-uhd/examples/c++/tag_source_demo.h
--- gnuradio-3.8.0.0/gr-uhd/examples/c++/tag_source_demo.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-uhd/examples/c++/tag_source_demo.h	2020-01-05 09:47:33.000000000 +0700
@@ -109,10 +109,11 @@
             _do_new_burst = false;
             _samps_left_in_burst = _samps_per_burst;
 
-            if (pmt::is_null(_length_tag_key))
+            if (pmt::is_null(_length_tag_key)) {
                 this->make_sob_tag(this->nitems_written(0));
-            else
+            } else {
 #if 1
+                (void)_samp_rate; // avoid unused variable warning
                 this->make_length_tag(this->nitems_written(0), _samps_left_in_burst);
 #else
                 // Test usrp_sink's ability to cancel remainder of burst if new length_tag
@@ -123,6 +124,7 @@
                 this->make_length_tag(this->nitems_written(0),
                                       uint64_t(1.1 * _samp_rate * _cycle_duration));
 #endif
+            }
             this->make_time_tag(this->nitems_written(0));
 
             _time_fracs += _cycle_duration;
diff -uNr gnuradio-3.8.0.0/gr-uhd/grc/gen_uhd_usrp_blocks.py gnuradio-maint-3.8/gr-uhd/grc/gen_uhd_usrp_blocks.py
--- gnuradio-3.8.0.0/gr-uhd/grc/gen_uhd_usrp_blocks.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-uhd/grc/gen_uhd_usrp_blocks.py	2020-01-05 09:47:33.000000000 +0700
@@ -144,10 +144,10 @@
                 ${'%'} if stream_args:
                 args=${'$'}{stream_args},
                 ${'%'} endif
-                ${'%'} if stream_chans:
+                ${'%'} if eval(stream_chans):
                 channels=${'$'}{stream_chans},
                 ${'%'} else:
-                channels=range(${'$'}{nchan}),
+                channels=list(range(0,${'$'}{nchan})),
                 ${'%'} endif
             ),
             ${'%'} if len_tag_name:
@@ -220,8 +220,10 @@
     % if sourk == 'source':
     -   ${'$'}{'set_rx_agc(True, ${n})' if context.get('rx_agc${n}')() == 'Enabled' else ''}
     -   ${'$'}{'set_rx_agc(False, ${n})' if context.get('rx_agc${n}')() == 'Disabled' else ''}
-    -   ${'$'}{'set_gain(${'$'}{${'gain' + str(n)}}, ${n})' if not bool(eval(context.get('norm_gain${n}')())) and context.get('rx_agc${n}')() != 'Enabled' else ''}
-    -   ${'$'}{'set_normalized_gain(${'$'}{${'gain' + str(n)}}, ${n})' if bool(eval(context.get('norm_gain${n}')())) and context.get('rx_agc${n}')() != 'Enabled' else ''}
+    -   |
+        ${'%'} if context.get('rx_agc${n}')() != 'Enabled':
+        self.${'$'}{id}.set_${'$'}{'normalized_' if bool(eval(context.get('norm_gain${n}')())) else ''}gain(${'$'}{${'gain' + str(n)}}, ${n})
+        ${'%'} endif
     % else:
     -   self.${'$'}{id}.set_${'$'}{'normalized_' if bool(eval(context.get('norm_gain${n}')())) else ''}gain(${'$'}{${'gain' + str(n)}}, ${n})
     % endif
diff -uNr gnuradio-3.8.0.0/gr-uhd/lib/usrp_block_impl.cc gnuradio-maint-3.8/gr-uhd/lib/usrp_block_impl.cc
--- gnuradio-3.8.0.0/gr-uhd/lib/usrp_block_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-uhd/lib/usrp_block_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -238,7 +238,7 @@
         } else {
             return false;
         }
-    } catch (pmt::wrong_type w) {
+    } catch (pmt::wrong_type& w) {
         return false;
     }
     return true;
diff -uNr gnuradio-3.8.0.0/gr-utils/octave/write_complex_binary.m gnuradio-maint-3.8/gr-utils/octave/write_complex_binary.m
--- gnuradio-3.8.0.0/gr-utils/octave/write_complex_binary.m	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-utils/octave/write_complex_binary.m	2020-01-05 09:47:33.000000000 +0700
@@ -26,7 +26,7 @@
   %%  open filename and write data to it
   %%  Format is interleaved float IQ e.g. each
   %%  I,Q 32-bit float IQIQIQ....
-  %%  This is compatabile with read_complex_binary()
+  %%  This is compatible with read_complex_binary()
   %%
 
   m = nargchk (2,2,nargin);
diff -uNr gnuradio-3.8.0.0/gr-utils/python/modtool/cli/add.py gnuradio-maint-3.8/gr-utils/python/modtool/cli/add.py
--- gnuradio-3.8.0.0/gr-utils/python/modtool/cli/add.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-utils/python/modtool/cli/add.py	2020-01-05 09:47:33.000000000 +0700
@@ -124,10 +124,17 @@
         click.secho("For GNU Radio components the FSF is added as copyright holder",
                     fg='cyan')
 
+
 def get_arglist(self):
     """ Get the argument list of the block to be added """
     if self.info['arglist'] is not None:
-        self.info['arglist'] = click.prompt(click.style('Enter valid argument list, including default arguments: \n', fg='cyan'), prompt_suffix='')
+        self.info['arglist'] = click.prompt(click.style(
+            'Enter valid argument list, including default arguments: \n',
+            fg='cyan'),
+                                            prompt_suffix='',
+                                            default='',
+                                            show_default=False)
+
 
 def get_py_qa(self):
     """ Get a boolean value for addition of py_qa """
diff -uNr gnuradio-3.8.0.0/gr-utils/python/modtool/cli/base.py gnuradio-maint-3.8/gr-utils/python/modtool/cli/base.py
--- gnuradio-3.8.0.0/gr-utils/python/modtool/cli/base.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-utils/python/modtool/cli/base.py	2020-01-05 09:47:33.000000000 +0700
@@ -122,7 +122,11 @@
 
 def cli_input(msg):
     """ Returns enhanced input """
-    return input(click.style(msg, fg='cyan'))
+    if sys.version_info[0] < 3:
+        in_func = raw_input
+    else:
+        in_func = input
+    return in_func(click.style(msg, fg='cyan'))
 
 
 def common_params(func):
diff -uNr gnuradio-3.8.0.0/gr-utils/python/modtool/core/add.py gnuradio-maint-3.8/gr-utils/python/modtool/core/add.py
--- gnuradio-3.8.0.0/gr-utils/python/modtool/core/add.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-utils/python/modtool/core/add.py	2020-01-05 09:47:33.000000000 +0700
@@ -67,6 +67,8 @@
             raise ModToolException('Programming language not specified.')
         if self.info['lang'] not in self.language_candidates:
             raise ModToolException('Invalid programming language.')
+        if self.info['blocktype'] == 'tagged_stream' and self.info['lang'] == 'python':
+            raise ModToolException('Tagged Stream Blocks for Python currently unsupported')            
         if self.info['blockname'] is None:
             raise ModToolException('Blockname not specified.')
         if not re.match('[a-zA-Z0-9_]+', self.info['blockname']):
@@ -127,10 +129,10 @@
 
     def run(self):
         """ Go, go, go. """
-        # This portion will be covered by the CLI
-        if not self.cli:
-            self.validate()
-            self.assign()
+
+        # Some validation covered by the CLI - validate all parameters here
+        self.validate()
+        self.assign()
 
         has_swig = (
                 self.info['lang'] == 'cpp'
diff -uNr gnuradio-3.8.0.0/gr-utils/python/modtool/core/rename.py gnuradio-maint-3.8/gr-utils/python/modtool/core/rename.py
--- gnuradio-3.8.0.0/gr-utils/python/modtool/core/rename.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-utils/python/modtool/core/rename.py	2020-01-05 09:47:33.000000000 +0700
@@ -175,7 +175,7 @@
         if not os.path.isfile(filename):
             return False
         else:
-            logger.info("In '{}' renaming occurences of '{}' to '{}'".format(filename, old, new))
+            logger.info("In '{}' renaming occurrences of '{}' to '{}'".format(filename, old, new))
 
         with open(filename) as f:
             cfile = f.read()
diff -uNr gnuradio-3.8.0.0/gr-utils/python/modtool/templates/templates.py gnuradio-maint-3.8/gr-utils/python/modtool/templates/templates.py
--- gnuradio-3.8.0.0/gr-utils/python/modtool/templates/templates.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-utils/python/modtool/templates/templates.py	2020-01-05 09:47:33.000000000 +0700
@@ -453,11 +453,16 @@
 #include <gnuradio/attributes.h>
 #include <boost/test/unit_test.hpp>
 
-BOOST_AUTO_TEST_CASE(test_${blockname}_t1)
-{
-    // Put test here
-}
+namespace gr {
+  namespace ${modname} {
 
+    BOOST_AUTO_TEST_CASE(test_${blockname}_t1)
+    {
+      // Put test here
+    }
+
+  } /* namespace ${modname} */
+} /* namespace gr */
 '''
 
 # C++ file for QA
@@ -550,11 +555,11 @@
   imports: import ${modname}
   make: ${modname}.${blockname}(${strip_arg_types_grc(arglist)})
 
-#  Make one 'parameters' list entry for every Parameter you want settable from the GUI.
-#     Sub-entries of dictionary:
+#  Make one 'parameters' list entry for every parameter you want settable from the GUI.
+#     Keys include:
 #     * id (makes the value accessible as \$keyname, e.g. in the make entry)
-#     * label
-#     * dtype 
+#     * label (label shown in the GUI)
+#     * dtype (e.g. int, float, complex, byte, short, xxx_vector, ...)
 parameters:
 - id: ...
   label: ...
@@ -563,27 +568,29 @@
   label: ...
   dtype: ...
 
-#  Make one 'inputs' list entry per input. Sub-entries of dictionary:
+#  Make one 'inputs' list entry per input and one 'outputs' list entry per output.
+#  Keys include:
 #      * label (an identifier for the GUI)
-#      * domain
-#      * dtype
-#      * vlen
-#      * optional (set to 1 for optional inputs) 
+#      * domain (optional - stream or message. Default is stream)
+#      * dtype (e.g. int, float, complex, byte, short, xxx_vector, ...)
+#      * vlen (optional - data stream vector length. Default is 1)
+#      * optional (optional - set to 1 for optional inputs. Default is 0)
 inputs:
 - label: ...
   domain: ...
   dtype: ...
   vlen: ...
+  optional: ...
 
-#  Make one 'outputs' list entry per output. Sub-entries of dictionary:
-#      * label (an identifier for the GUI)
-#      * dtype
-#      * vlen
-#      * optional (set to 1 for optional inputs) 
+outputs:
 - label: ...
   domain: ...
-  dtype: ... #!-- e.g. int, float, complex, byte, short, xxx_vector, ...--
+  dtype: ...
+  vlen: ...
+  optional: ...
 
+#  'file_format' specifies the version of the GRC yml format used in the file
+#  and should usually not be changed.
 file_format: 1
 '''
 
diff -uNr gnuradio-3.8.0.0/gr-utils/python/modtool/tools/util_functions.py gnuradio-maint-3.8/gr-utils/python/modtool/tools/util_functions.py
--- gnuradio-3.8.0.0/gr-utils/python/modtool/tools/util_functions.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-utils/python/modtool/tools/util_functions.py	2020-01-05 09:47:33.000000000 +0700
@@ -143,8 +143,12 @@
 def ask_yes_no(question, default):
     """ Asks a binary question. Returns True for yes, False for no.
     default is given as a boolean. """
+    if sys.version_info[0] < 3:
+        in_func = raw_input
+    else:
+        in_func = input
     question += {True: ' [Y/n] ', False: ' [y/N] '}[default]
-    if input(question).lower() != {True: 'n', False: 'y'}[default]:
+    if in_func(question).lower() != {True: 'n', False: 'y'}[default]:
         return default
     else:
         return not default
diff -uNr gnuradio-3.8.0.0/gr-vocoder/examples/cvsd_audio_loopback.py gnuradio-maint-3.8/gr-vocoder/examples/cvsd_audio_loopback.py
--- gnuradio-3.8.0.0/gr-vocoder/examples/cvsd_audio_loopback.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-vocoder/examples/cvsd_audio_loopback.py	2020-01-05 09:47:33.000000000 +0700
@@ -52,15 +52,15 @@
     tb.connect(enc, dec, s2f, decim, sink_scale, sink)
 
     if 0: # debug
-        tb.conect(src, blocks.file_sink(gr.sizeof_float, "source.dat"))
-        tb.conect(src_scale, blocks.file_sink(gr.sizeof_float, "src_scale.dat"))
-        tb.conect(interp, blocks.file_sink(gr.sizeof_float, "interp.dat"))
-        tb.conect(f2s, blocks.file_sink(gr.sizeof_short, "f2s.dat"))
-        tb.conect(enc, blocks.file_sink(gr.sizeof_char,  "enc.dat"))
-        tb.conect(dec, blocks.file_sink(gr.sizeof_short, "dec.dat"))
-        tb.conect(s2f, blocks.file_sink(gr.sizeof_float, "s2f.dat"))
-        tb.conect(decim, blocks.file_sink(gr.sizeof_float, "decim.dat"))
-        tb.conect(sink_scale, blocks.file_sink(gr.sizeof_float, "sink_scale.dat"))
+        tb.connect(src, blocks.file_sink(gr.sizeof_float, "source.dat"))
+        tb.connect(src_scale, blocks.file_sink(gr.sizeof_float, "src_scale.dat"))
+        tb.connect(interp, blocks.file_sink(gr.sizeof_float, "interp.dat"))
+        tb.connect(f2s, blocks.file_sink(gr.sizeof_short, "f2s.dat"))
+        tb.connect(enc, blocks.file_sink(gr.sizeof_char,  "enc.dat"))
+        tb.connect(dec, blocks.file_sink(gr.sizeof_short, "dec.dat"))
+        tb.connect(s2f, blocks.file_sink(gr.sizeof_float, "s2f.dat"))
+        tb.connect(decim, blocks.file_sink(gr.sizeof_float, "decim.dat"))
+        tb.connect(sink_scale, blocks.file_sink(gr.sizeof_float, "sink_scale.dat"))
 
     return tb
 
diff -uNr gnuradio-3.8.0.0/gr-vocoder/include/gnuradio/vocoder/freedv_api.h gnuradio-maint-3.8/gr-vocoder/include/gnuradio/vocoder/freedv_api.h
--- gnuradio-3.8.0.0/gr-vocoder/include/gnuradio/vocoder/freedv_api.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-vocoder/include/gnuradio/vocoder/freedv_api.h	2020-01-05 09:47:33.000000000 +0700
@@ -25,11 +25,17 @@
 
 #include <gnuradio/vocoder/api.h>
 
+// version >=0.9.1 contains fixes that doesn't require "extern C"
+// between 0.8.1 and 0.9.1 the build fail
+#ifdef CODEC2_LEGACY
 extern "C" {
+#endif
 #include <codec2/codec2.h>
 #include <codec2/freedv_api.h>
 #include <codec2/modem_stats.h>
+#ifdef CODEC2_LEGACY
 }
+#endif
 
 namespace gr {
 namespace vocoder {
diff -uNr gnuradio-3.8.0.0/gr-zeromq/lib/pub_msg_sink_impl.cc gnuradio-maint-3.8/gr-zeromq/lib/pub_msg_sink_impl.cc
--- gnuradio-3.8.0.0/gr-zeromq/lib/pub_msg_sink_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-zeromq/lib/pub_msg_sink_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -73,7 +73,11 @@
     zmq::message_t zmsg(s.size());
 
     memcpy(zmsg.data(), s.c_str(), s.size());
+#if USE_NEW_CPPZMQ_SEND_RECV
+    d_socket->send(zmsg, zmq::send_flags::none);
+#else
     d_socket->send(zmsg);
+#endif
 }
 
 } /* namespace zeromq */
diff -uNr gnuradio-3.8.0.0/gr-zeromq/lib/pub_msg_sink_impl.h gnuradio-maint-3.8/gr-zeromq/lib/pub_msg_sink_impl.h
--- gnuradio-3.8.0.0/gr-zeromq/lib/pub_msg_sink_impl.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-zeromq/lib/pub_msg_sink_impl.h	2020-01-05 09:47:33.000000000 +0700
@@ -23,8 +23,8 @@
 #ifndef INCLUDED_ZEROMQ_PUB_MSG_SINK_IMPL_H
 #define INCLUDED_ZEROMQ_PUB_MSG_SINK_IMPL_H
 
+#include "zmq_common_impl.h"
 #include <gnuradio/zeromq/pub_msg_sink.h>
-#include <zmq.hpp>
 
 namespace gr {
 namespace zeromq {
diff -uNr gnuradio-3.8.0.0/gr-zeromq/lib/pub_sink_impl.h gnuradio-maint-3.8/gr-zeromq/lib/pub_sink_impl.h
--- gnuradio-3.8.0.0/gr-zeromq/lib/pub_sink_impl.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-zeromq/lib/pub_sink_impl.h	2020-01-05 09:47:33.000000000 +0700
@@ -24,7 +24,6 @@
 #define INCLUDED_ZEROMQ_PUB_SINK_IMPL_H
 
 #include <gnuradio/zeromq/pub_sink.h>
-#include <zmq.hpp>
 
 #include "base_impl.h"
 
diff -uNr gnuradio-3.8.0.0/gr-zeromq/lib/pull_source_impl.h gnuradio-maint-3.8/gr-zeromq/lib/pull_source_impl.h
--- gnuradio-3.8.0.0/gr-zeromq/lib/pull_source_impl.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-zeromq/lib/pull_source_impl.h	2020-01-05 09:47:33.000000000 +0700
@@ -24,7 +24,6 @@
 #define INCLUDED_ZEROMQ_PULL_SOURCE_IMPL_H
 
 #include <gnuradio/zeromq/pull_source.h>
-#include <zmq.hpp>
 
 #include "base_impl.h"
 
diff -uNr gnuradio-3.8.0.0/gr-zeromq/lib/push_msg_sink_impl.cc gnuradio-maint-3.8/gr-zeromq/lib/push_msg_sink_impl.cc
--- gnuradio-3.8.0.0/gr-zeromq/lib/push_msg_sink_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-zeromq/lib/push_msg_sink_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -75,7 +75,11 @@
     zmq::message_t zmsg(s.size());
 
     memcpy(zmsg.data(), s.c_str(), s.size());
+#if USE_NEW_CPPZMQ_SEND_RECV
+    d_socket->send(zmsg, zmq::send_flags::none);
+#else
     d_socket->send(zmsg);
+#endif
 }
 
 } /* namespace zeromq */
diff -uNr gnuradio-3.8.0.0/gr-zeromq/lib/push_msg_sink_impl.h gnuradio-maint-3.8/gr-zeromq/lib/push_msg_sink_impl.h
--- gnuradio-3.8.0.0/gr-zeromq/lib/push_msg_sink_impl.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-zeromq/lib/push_msg_sink_impl.h	2020-01-05 09:47:33.000000000 +0700
@@ -23,8 +23,8 @@
 #ifndef INCLUDED_ZEROMQ_PUSH_MSG_SINK_IMPL_H
 #define INCLUDED_ZEROMQ_PUSH_MSG_SINK_IMPL_H
 
+#include "zmq_common_impl.h"
 #include <gnuradio/zeromq/push_msg_sink.h>
-#include <zmq.hpp>
 
 namespace gr {
 namespace zeromq {
diff -uNr gnuradio-3.8.0.0/gr-zeromq/lib/push_sink_impl.h gnuradio-maint-3.8/gr-zeromq/lib/push_sink_impl.h
--- gnuradio-3.8.0.0/gr-zeromq/lib/push_sink_impl.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-zeromq/lib/push_sink_impl.h	2020-01-05 09:47:33.000000000 +0700
@@ -24,7 +24,6 @@
 #define INCLUDED_ZEROMQ_PUSH_SINK_IMPL_H
 
 #include <gnuradio/zeromq/push_sink.h>
-#include <zmq.hpp>
 
 #include "base_impl.h"
 
diff -uNr gnuradio-3.8.0.0/gr-zeromq/lib/rep_msg_sink_impl.cc gnuradio-maint-3.8/gr-zeromq/lib/rep_msg_sink_impl.cc
--- gnuradio-3.8.0.0/gr-zeromq/lib/rep_msg_sink_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-zeromq/lib/rep_msg_sink_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -117,7 +117,11 @@
                 std::string s = sb.str();
                 zmq::message_t zmsg(s.size());
                 memcpy(zmsg.data(), s.c_str(), s.size());
+#if USE_NEW_CPPZMQ_SEND_RECV
+                d_socket->send(zmsg, zmq::send_flags::none);
+#else
                 d_socket->send(zmsg);
+#endif
             } // if req
         }     // while !empty
 
diff -uNr gnuradio-3.8.0.0/gr-zeromq/lib/req_source_impl.cc gnuradio-maint-3.8/gr-zeromq/lib/req_source_impl.cc
--- gnuradio-3.8.0.0/gr-zeromq/lib/req_source_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-zeromq/lib/req_source_impl.cc	2020-01-05 09:47:33.000000000 +0700
@@ -77,7 +77,11 @@
                 uint32_t req_len = noutput_items - done;
                 zmq::message_t request(sizeof(uint32_t));
                 memcpy((void*)request.data(), &req_len, sizeof(uint32_t));
+#if USE_NEW_CPPZMQ_SEND_RECV
+                d_socket->send(request, zmq::send_flags::none);
+#else
                 d_socket->send(request);
+#endif
 
                 d_req_pending = true;
             }
diff -uNr gnuradio-3.8.0.0/gr-zeromq/lib/req_source_impl.h gnuradio-maint-3.8/gr-zeromq/lib/req_source_impl.h
--- gnuradio-3.8.0.0/gr-zeromq/lib/req_source_impl.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-zeromq/lib/req_source_impl.h	2020-01-05 09:47:33.000000000 +0700
@@ -24,7 +24,6 @@
 #define INCLUDED_ZEROMQ_REQ_SOURCE_IMPL_H
 
 #include <gnuradio/zeromq/req_source.h>
-#include <zmq.hpp>
 
 #include "base_impl.h"
 
diff -uNr gnuradio-3.8.0.0/gr-zeromq/lib/sub_source_impl.h gnuradio-maint-3.8/gr-zeromq/lib/sub_source_impl.h
--- gnuradio-3.8.0.0/gr-zeromq/lib/sub_source_impl.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-zeromq/lib/sub_source_impl.h	2020-01-05 09:47:33.000000000 +0700
@@ -24,7 +24,6 @@
 #define INCLUDED_ZEROMQ_SUB_SOURCE_IMPL_H
 
 #include <gnuradio/zeromq/sub_source.h>
-#include <zmq.hpp>
 
 #include "base_impl.h"
 
diff -uNr gnuradio-3.8.0.0/gr-zeromq/lib/tag_headers.cc gnuradio-maint-3.8/gr-zeromq/lib/tag_headers.cc
--- gnuradio-3.8.0.0/gr-zeromq/lib/tag_headers.cc	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-zeromq/lib/tag_headers.cc	2020-01-05 09:47:33.000000000 +0700
@@ -20,9 +20,9 @@
  * Boston, MA 02110-1301, USA.
  */
 
+#include "zmq_common_impl.h"
 #include <gnuradio/block.h>
 #include <gnuradio/io_signature.h>
-#include <zmq.hpp>
 #include <cstring>
 #include <sstream>
 
diff -uNr gnuradio-3.8.0.0/gr-zeromq/lib/tag_headers.h gnuradio-maint-3.8/gr-zeromq/lib/tag_headers.h
--- gnuradio-3.8.0.0/gr-zeromq/lib/tag_headers.h	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/gr-zeromq/lib/tag_headers.h	2020-01-05 09:47:33.000000000 +0700
@@ -23,9 +23,9 @@
 #ifndef ZEROMQ_TAG_HEADERS_H
 #define ZEROMQ_TAG_HEADERS_H
 
+#include "zmq_common_impl.h"
 #include <gnuradio/block.h>
 #include <gnuradio/io_signature.h>
-#include <zmq.hpp>
 #include <cstring>
 #include <sstream>
 
diff -uNr gnuradio-3.8.0.0/grc/core/FlowGraph.py gnuradio-maint-3.8/grc/core/FlowGraph.py
--- gnuradio-3.8.0.0/grc/core/FlowGraph.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/grc/core/FlowGraph.py	2020-01-05 09:47:33.000000000 +0700
@@ -226,6 +226,7 @@
                 variable_block.rewrite()
                 value = eval(variable_block.value, namespace, variable_block.namespace)
                 namespace[variable_block.name] = value
+                self.namespace.update(namespace) # rewrite on subsequent blocks depends on an updated self.namespace 
             except TypeError: #Type Errors may happen, but that desn't matter as they are displayed in the gui
                 pass
             except Exception:
@@ -381,8 +382,7 @@
 
             block.import_data(**block_data)
 
-        self.rewrite()  # TODO: Figure out why this has to be called twice to populate bus ports correctly
-        self.rewrite()  # evaluate stuff like nports before adding connections
+        self.rewrite() 
 
         # build the connections
         def verify_and_get_port(key, block, dir):
diff -uNr gnuradio-3.8.0.0/grc/core/blocks/block.py gnuradio-maint-3.8/grc/core/blocks/block.py
--- gnuradio-3.8.0.0/grc/core/blocks/block.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/grc/core/blocks/block.py	2020-01-05 09:47:33.000000000 +0700
@@ -207,6 +207,7 @@
     def _rewrite_nports(self, ports):
         for port in ports:
             if hasattr(port, 'master_port'):  # Not a master port and no left-over clones
+                port.dtype = port.master_port.dtype
                 continue
             nports = port.multiplicity
             for clone in port.clones[nports-1:]:
diff -uNr gnuradio-3.8.0.0/grc/core/blocks/embedded_python.py gnuradio-maint-3.8/grc/core/blocks/embedded_python.py
--- gnuradio-3.8.0.0/grc/core/blocks/embedded_python.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/grc/core/blocks/embedded_python.py	2020-01-05 09:47:33.000000000 +0700
@@ -149,10 +149,10 @@
     def _update_params(self, params_in_src):
         param_factory = self.parent_platform.make_param
         params = {}
-        for param in list(self.params):
-            if hasattr(param, '__epy_param__'):
-                params[param.key] = param
-                del self.params[param.key]
+        for key, value in self.params.copy().items():
+            if hasattr(value, '__epy_param__'):
+                params[key] = value
+                del self.params[key]
 
         for id_, value in params_in_src:
             try:
diff -uNr gnuradio-3.8.0.0/grc/core/generator/cpp_templates/flow_graph.hpp.mako gnuradio-maint-3.8/grc/core/generator/cpp_templates/flow_graph.hpp.mako
--- gnuradio-3.8.0.0/grc/core/generator/cpp_templates/flow_graph.hpp.mako	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/grc/core/generator/cpp_templates/flow_graph.hpp.mako	2020-01-05 09:47:33.000000000 +0700
@@ -92,8 +92,8 @@
 % if not generate_options.startswith('hb'):
     top_block_sptr tb;
 % endif
-	${class_name}(${param_str});
-	~${class_name}();
+    ${class_name}(${param_str});
+    ~${class_name}();
 
 % for var in parameters + variables:
     ${var.vtype} get_${var.name} () const;
diff -uNr gnuradio-3.8.0.0/grc/core/generator/flow_graph.py.mako gnuradio-maint-3.8/grc/core/generator/flow_graph.py.mako
--- gnuradio-3.8.0.0/grc/core/generator/flow_graph.py.mako	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/grc/core/generator/flow_graph.py.mako	2020-01-05 09:47:33.000000000 +0700
@@ -190,18 +190,18 @@
         % if blk_make:
         ${ indent(blk_make.strip('\n')) }
         % endif
-##         % if 'alias' in blk.params and blk.params['alias'].get_evaluated():
-##         (self.${blk.name}).set_block_alias("${blk.params['alias'].get_evaluated()}")
-##         % endif
-##         % if 'affinity' in blk.params and blk.params['affinity'].get_evaluated():
-##         (self.${blk.name}).set_processor_affinity(${blk.params['affinity'].get_evaluated()})
-##         % endif
-##         % if len(blk.sources) > 0 and 'minoutbuf' in blk.params and int(blk.params['minoutbuf'].get_evaluated()) > 0:
-##         (self.${blk.name}).set_min_output_buffer(${blk.params['minoutbuf'].get_evaluated()})
-##         % endif
-##         % if len(blk.sources) > 0 and 'maxoutbuf' in blk.params and int(blk.params['maxoutbuf'].get_evaluated()) > 0:
-##         (self.${blk.name}).set_max_output_buffer(${blk.params['maxoutbuf'].get_evaluated()})
-##         % endif
+        % if 'alias' in blk.params and blk.params['alias'].get_evaluated():
+        self.${blk.name}.set_block_alias("${blk.params['alias'].get_evaluated()}")
+        % endif
+        % if 'affinity' in blk.params and blk.params['affinity'].get_evaluated():
+        self.${blk.name}.set_processor_affinity(${blk.params['affinity'].get_evaluated()})
+        % endif
+        % if len(blk.sources) > 0 and 'minoutbuf' in blk.params and int(blk.params['minoutbuf'].get_evaluated()) > 0:
+        self.${blk.name}.set_min_output_buffer(${blk.params['minoutbuf'].get_evaluated()})
+        % endif
+        % if len(blk.sources) > 0 and 'maxoutbuf' in blk.params and int(blk.params['maxoutbuf'].get_evaluated()) > 0:
+        self.${blk.name}.set_max_output_buffer(${blk.params['maxoutbuf'].get_evaluated()})
+        % endif
         % endfor
 
 ##########################################################
diff -uNr gnuradio-3.8.0.0/grc/core/utils/extract_docs.py gnuradio-maint-3.8/grc/core/utils/extract_docs.py
--- gnuradio-3.8.0.0/grc/core/utils/extract_docs.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/grc/core/utils/extract_docs.py	2020-01-05 09:47:33.000000000 +0700
@@ -198,7 +198,7 @@
         """ Receive response from worker's stdout """
         for line in iter(self._worker.stdout.readline, ''):
             try:
-                key, cmd, args = json.loads(line.decode('utf-8'), encoding='utf-8')
+                key, cmd, args = json.loads(line.decode('utf-8'))
                 if key != self.AUTH_CODE:
                     raise ValueError('Got wrong auth code')
                 return cmd, args
@@ -268,7 +268,7 @@
     # flush out to signal the main process we are ready for new commands
     sys.stdout.flush()
     for line in iter(sys.stdin.readline, ''):
-        code, cmd, args = json.loads(line, encoding='utf-8')
+        code, cmd, args = json.loads(line)
         try:
             if cmd == 'query':
                 key, imports, make = args
diff -uNr gnuradio-3.8.0.0/grc/gui/Application.py gnuradio-maint-3.8/grc/gui/Application.py
--- gnuradio-3.8.0.0/grc/gui/Application.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/grc/gui/Application.py	2020-01-05 09:47:33.000000000 +0700
@@ -686,6 +686,7 @@
             # Import the old data and mark the current as not saved
             new_flow_graph.import_data(previous.export_data())
             flow_graph_update(new_flow_graph)
+            page.state_cache.save_new_state(new_flow_graph.export_data())
             page.saved = False
         elif action == Actions.FLOW_GRAPH_SCREEN_CAPTURE:
             file_path, background_transparent = FileDialogs.SaveScreenShot(main, page.file_path).run()
diff -uNr gnuradio-3.8.0.0/grc/gui/PropsDialog.py gnuradio-maint-3.8/grc/gui/PropsDialog.py
--- gnuradio-3.8.0.0/grc/gui/PropsDialog.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/grc/gui/PropsDialog.py	2020-01-05 09:47:33.000000000 +0700
@@ -212,11 +212,12 @@
         buf.delete(buf.get_start_iter(), buf.get_end_iter())
         pos = buf.get_end_iter()
 
-        # Add link to wiki page for this block, at the top
-        note = "Wiki Page for this Block: "
-        prefix = self._config.wiki_block_docs_url_prefix
-        suffix = self._block.label.replace(" ", "_")
-        buf.insert(pos, note + prefix + suffix + '\n\n')
+        # Add link to wiki page for this block, at the top, as long as it's not an OOT block
+        if self._block.category[0] == "Core":
+            note = "Wiki Page for this Block: "
+            prefix = self._config.wiki_block_docs_url_prefix
+            suffix = self._block.label.replace(" ", "_")
+            buf.insert(pos, note + prefix + suffix + '\n\n')
 
         docstrings = self._block.documentation.copy()
         if not docstrings:
diff -uNr gnuradio-3.8.0.0/grc/gui/canvas/block.py gnuradio-maint-3.8/grc/gui/canvas/block.py
--- gnuradio-3.8.0.0/grc/gui/canvas/block.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/grc/gui/canvas/block.py	2020-01-05 09:47:33.000000000 +0700
@@ -327,6 +327,17 @@
             ))
         return tuple(extent)
 
+    def get_extents_comment(self):
+        x, y = self.coordinate
+        if not self._comment_layout:
+            return x, y, x, y
+        if self.is_horizontal():
+            y += self.height + BLOCK_LABEL_PADDING
+        else:
+            x += self.height + BLOCK_LABEL_PADDING
+        w, h = self._comment_layout.get_pixel_size()
+        return x, y, x + w, y + h
+
     ##############################################
     # Controller Modify
     ##############################################
diff -uNr gnuradio-3.8.0.0/grc/gui/canvas/flowgraph.py gnuradio-maint-3.8/grc/gui/canvas/flowgraph.py
--- gnuradio-3.8.0.0/grc/gui/canvas/flowgraph.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/grc/gui/canvas/flowgraph.py	2020-01-05 09:47:33.000000000 +0700
@@ -755,8 +755,6 @@
 
     def _handle_mouse_motion_move(self, coordinate):
         # only continue if mouse-over stuff is enabled (just the auto-hide port label stuff for now)
-        if not Actions.TOGGLE_AUTO_HIDE_PORT_LABELS.get_active():
-            return
         redraw = False
         for element in self._elements_to_draw:
             over_element = element.what_is_selected(coordinate)
@@ -772,6 +770,8 @@
             if self.element_under_mouse:
                 redraw |= self.element_under_mouse.mouse_out() or False
                 self.element_under_mouse = None
+        if not Actions.TOGGLE_AUTO_HIDE_PORT_LABELS.get_active():
+            return
         if redraw:
             # self.create_labels()
             self.create_shapes()
@@ -804,9 +804,15 @@
         return redraw
 
     def get_extents(self):
-        extent = 100000, 100000, 0, 0
-        for element in self._elements_to_draw:
-            extent = (min_or_max(xy, e_xy) for min_or_max, xy, e_xy in zip(
-                (min, min, max, max), extent, element.get_extents()
-            ))
+        show_comments = Actions.TOGGLE_SHOW_BLOCK_COMMENTS.get_active()
+        def sub_extents():
+            for element in self._elements_to_draw:
+                yield element.get_extents()
+                if element.is_block and show_comments and element.enabled:
+                    yield element.get_extents_comment()
+
+        extent = 10000000, 10000000, 0, 0
+        cmps = (min, min, max, max)
+        for sub_extent in sub_extents():
+            extent = [cmp(xy, e_xy) for cmp, xy, e_xy in zip(cmps, extent, sub_extent)]
         return tuple(extent)
diff -uNr gnuradio-3.8.0.0/grc/tests/test_block_flags.py gnuradio-maint-3.8/grc/tests/test_block_flags.py
--- gnuradio-3.8.0.0/grc/tests/test_block_flags.py	2019-08-10 04:15:36.000000000 +0700
+++ gnuradio-maint-3.8/grc/tests/test_block_flags.py	2020-01-05 09:47:33.000000000 +0700
@@ -26,4 +26,4 @@
     f.set(u'b')
     assert isinstance(f, Flags)
 
-    assert str(f) == 'a, b'
+    assert f.data == {'a', 'b'}
