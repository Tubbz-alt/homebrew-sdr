diff -uNrp a/.clang-tidy b/.clang-tidy
--- a/.clang-tidy	1970-01-01 07:00:00.000000000 +0700
+++ b/.clang-tidy	2019-10-20 04:31:39.000000000 +0700
@@ -0,0 +1,10 @@
+---
+Checks:          '-*,misc-throw-by-value-catch-by-reference,misc-static-assert,readability-container-size-empty'
+# Not in here: modernize-use-emplace, since that basically broke all things it touched
+WarningsAsErrors: ''
+HeaderFilterRegex: '\.(cc|c|cpp|h|hpp)$'
+AnalyzeTemporaryDtors: false
+FormatStyle:     file
+CheckOptions:
+...
+
diff -uNrp a/cmake/Modules/FindLOG4CPP.cmake b/cmake/Modules/FindLOG4CPP.cmake
--- a/cmake/Modules/FindLOG4CPP.cmake	2019-08-10 04:15:36.000000000 +0700
+++ b/cmake/Modules/FindLOG4CPP.cmake	2019-10-20 04:31:39.000000000 +0700
@@ -12,15 +12,15 @@ if (LOG4CPP_INCLUDE_DIR)
 endif ()
 
 find_path(LOG4CPP_INCLUDE_DIR log4cpp/Category.hh
-  /opt/local/include
-  /usr/local/include
   /usr/include
+  /usr/local/include
+  /opt/local/include
 )
 
 set(LOG4CPP_NAMES log4cpp)
 find_library(LOG4CPP_LIBRARY
   NAMES ${LOG4CPP_NAMES}
-  PATHS /usr/lib /usr/local/lib /opt/local/lib
+  PATHS /usr/lib /usr/lib64 /usr/local/lib  /usr/local/lib64 /opt/local/lib /opt/local/lib64
 )
 
 
diff -uNrp a/cmake/Modules/FindQwt.cmake b/cmake/Modules/FindQwt.cmake
--- a/cmake/Modules/FindQwt.cmake	2019-08-10 04:15:36.000000000 +0700
+++ b/cmake/Modules/FindQwt.cmake	2019-10-20 04:31:39.000000000 +0700
@@ -29,7 +29,7 @@ find_path(QWT_INCLUDE_DIRS
 )
 
 find_library (QWT_LIBRARIES
-  NAMES ${PC_QWT_LIBRARIES} qwt6-${QWT_QT_VERSION} qwt-${QWT_QT_VERSION}
+  NAMES ${PC_QWT_LIBRARIES} qwt6-${QWT_QT_VERSION} qwt-${QWT_QT_VERSION} qwt
   HINTS
   ${PC_QWT_LIBDIR}
   ${CMAKE_INSTALL_PREFIX}/lib
diff -uNrp a/gnuradio-runtime/apps/gnuradio-config-info.cc b/gnuradio-runtime/apps/gnuradio-config-info.cc
--- a/gnuradio-runtime/apps/gnuradio-config-info.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/apps/gnuradio-config-info.cc	2019-10-20 04:31:39.000000000 +0700
@@ -61,7 +61,7 @@ int main(int argc, char** argv)
         return 1;
     }
 
-    if (vm.size() == 0 || vm.count("help")) {
+    if (vm.empty() || vm.count("help")) {
         std::cout << desc << std::endl;
         return 1;
     }
diff -uNrp a/gnuradio-runtime/include/gnuradio/basic_block.h b/gnuradio-runtime/include/gnuradio/basic_block.h
--- a/gnuradio-runtime/include/gnuradio/basic_block.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/include/gnuradio/basic_block.h	2019-10-20 04:31:39.000000000 +0700
@@ -38,9 +38,7 @@
 #include <map>
 #include <string>
 
-#ifdef GR_CTRLPORT
 #include <gnuradio/rpcregisterhelpers.h>
-#endif
 
 namespace gr {
 
@@ -91,7 +89,7 @@ protected:
     bool d_rpc_set;
 
     msg_queue_map_t msg_queue;
-    std::vector<boost::any> d_rpc_vars; // container for all RPC variables
+    std::vector<rpcbasic_sptr> d_rpc_vars; // container for all RPC variables
 
     basic_block(void) {} // allows pure virtual interface sub-classes
 
diff -uNrp a/gnuradio-runtime/include/gnuradio/block_gateway.h b/gnuradio-runtime/include/gnuradio/block_gateway.h
--- a/gnuradio-runtime/include/gnuradio/block_gateway.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/include/gnuradio/block_gateway.h	2019-10-20 04:31:39.000000000 +0700
@@ -310,7 +310,11 @@ protected:
 
     bool has_msg_handler(pmt::pmt_t which_port)
     {
-        return (d_msg_handlers_feval.find(which_port) != d_msg_handlers_feval.end());
+        if (d_msg_handlers_feval.find(which_port) != d_msg_handlers_feval.end()) {
+            return true;
+        } else {
+            return gr::basic_block::has_msg_handler(which_port);
+        }
     }
 
     void dispatch_msg(pmt::pmt_t which_port, pmt::pmt_t msg)
diff -uNrp a/gnuradio-runtime/include/gnuradio/block_registry.h b/gnuradio-runtime/include/gnuradio/block_registry.h
--- a/gnuradio-runtime/include/gnuradio/block_registry.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/include/gnuradio/block_registry.h	2019-10-20 04:31:39.000000000 +0700
@@ -25,6 +25,7 @@
 
 #include <gnuradio/api.h>
 #include <gnuradio/basic_block.h>
+#include <gnuradio/thread/thread.h>
 #include <map>
 
 namespace gr {
diff -uNrp a/gnuradio-runtime/include/gnuradio/pycallback_object.h b/gnuradio-runtime/include/gnuradio/pycallback_object.h
--- a/gnuradio-runtime/include/gnuradio/pycallback_object.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/include/gnuradio/pycallback_object.h	2019-10-20 04:31:39.000000000 +0700
@@ -150,7 +150,7 @@ private:
         return (dummy);
     };
 
-    std::vector<boost::any> d_rpc_vars; // container for all RPC variables
+    std::vector<rpcbasic_sptr> d_rpc_vars; // container for all RPC variables
     std::string d_name;
     int d_id;
 };
diff -uNrp a/gnuradio-runtime/include/gnuradio/rpcserver_aggregator.h b/gnuradio-runtime/include/gnuradio/rpcserver_aggregator.h
--- a/gnuradio-runtime/include/gnuradio/rpcserver_aggregator.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/include/gnuradio/rpcserver_aggregator.h	2019-10-20 04:31:39.000000000 +0700
@@ -60,8 +60,8 @@ private:
         }
 
         void operator()(T& x) { x->i()->registerConfigureCallback(id, callback); }
-        const std::string& id;
-        const Tcallback& callback;
+        const std::string id;
+        const Tcallback callback;
     };
 
     template <class T, typename Tcallback>
@@ -69,7 +69,7 @@ private:
         unregisterConfigureCallback_f(const std::string& _id) : id(_id) { ; }
 
         void operator()(T& x) { x->i()->unregisterConfigureCallback(id); }
-        const std::string& id;
+        const std::string id;
     };
 
     template <class T, typename Tcallback>
@@ -81,8 +81,8 @@ private:
         }
 
         void operator()(T& x) { x->i()->registerQueryCallback(id, callback); }
-        const std::string& id;
-        const Tcallback& callback;
+        const std::string id;
+        const Tcallback callback;
     };
 
     template <class T, typename Tcallback>
@@ -90,7 +90,7 @@ private:
         unregisterQueryCallback_f(const std::string& _id) : id(_id) { ; }
 
         void operator()(T& x) { x->i()->unregisterQueryCallback(id); }
-        const std::string& id;
+        const std::string id;
     };
 
 
@@ -103,8 +103,8 @@ private:
         }
 
         void operator()(T& x) { x->i()->registerHandlerCallback(id, callback); }
-        const std::string& id;
-        const Tcallback& callback;
+        const std::string id;
+        const Tcallback callback;
     };
 
     template <class T, typename Tcallback>
@@ -112,7 +112,7 @@ private:
         unregisterHandlerCallback_f(const std::string& _id) : id(_id) { ; }
 
         void operator()(T& x) { x->i()->unregisterHandlerCallback(id); }
-        const std::string& id;
+        const std::string id;
     };
 
 
diff -uNrp a/gnuradio-runtime/include/gnuradio/tag_checker.h b/gnuradio-runtime/include/gnuradio/tag_checker.h
--- a/gnuradio-runtime/include/gnuradio/tag_checker.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/include/gnuradio/tag_checker.h	2019-10-20 04:31:39.000000000 +0700
@@ -41,7 +41,7 @@ public:
     {
         d_tags = tags;
         std::sort(d_tags.begin(), d_tags.end(), &gr::tag_t::offset_compare);
-        if (d_tags.size() > 0) {
+        if (!d_tags.empty()) {
             d_has_next_tag = true;
             d_next_tag = tags[0];
         }
diff -uNrp a/gnuradio-runtime/include/gnuradio/thrift_application_base.h b/gnuradio-runtime/include/gnuradio/thrift_application_base.h
--- a/gnuradio-runtime/include/gnuradio/thrift_application_base.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/include/gnuradio/thrift_application_base.h	2019-10-20 04:31:39.000000000 +0700
@@ -53,13 +53,13 @@ class thrift_application_base_impl
 {
 public:
     thrift_application_base_impl()
-        : d_application_initilized(false), d_endpointStr(""), d_start_thrift_thread()
+        : d_application_initialized(false), d_endpointStr(""), d_start_thrift_thread()
     {
         ;
     }
 
     // Used to ensure the Thrift runtime is initialized on the first call to ::i().
-    bool d_application_initilized;
+    bool d_application_initialized;
     // Stores the generated endpoint string after the Thrift runtime has initialized.
     std::string d_endpointStr;
     // Thread to execute the Thrift runtime's blocking serve() function.
@@ -212,7 +212,7 @@ void thrift_application_base<TserverBase
         static_cast<unsigned int>(gr::prefs::singleton()->get_long(
             "thrift", "init_attempts", d_default_max_init_attempts));
 
-    if (!p_impl->d_application_initilized) {
+    if (!p_impl->d_application_initialized) {
         p_impl->d_start_thrift_thread.reset((new gr::thread::thread(
             boost::bind(&thrift_application_base::start_thrift, d_application))));
 
@@ -230,7 +230,7 @@ void thrift_application_base<TserverBase
                     "timeout waiting to port number might have failed?");
         }
 
-        p_impl->d_application_initilized = true;
+        p_impl->d_application_initialized = true;
     }
 }
 
@@ -254,7 +254,7 @@ void thrift_application_base<TserverBase
 template <typename TserverBase, typename TserverClass>
 TserverBase* thrift_application_base<TserverBase, TserverClass>::i()
 {
-    if (!p_impl->d_application_initilized) {
+    if (!p_impl->d_application_initialized) {
         start_application();
     }
     return d_application->i_impl();
diff -uNrp a/gnuradio-runtime/lib/block.cc b/gnuradio-runtime/lib/block.cc
--- a/gnuradio-runtime/lib/block.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/lib/block.cc	2019-10-20 04:31:39.000000000 +0700
@@ -667,26 +667,26 @@ void block::setup_pc_rpc()
     d_pc_rpc_set = true;
 #if defined(GR_CTRLPORT) && defined(GR_PERFORMANCE_COUNTERS)
 #include <gnuradio/rpcregisterhelpers.h>
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_trigger<block>(alias(),
                                              "reset_perf_counters",
                                              &block::reset_perf_counters,
                                              "Reset the Performance Counters",
-                                             RPC_PRIVLVL_MIN)));
+                                             RPC_PRIVLVL_MIN));
 
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, float>(alias(),
-                                                              "noutput_items",
-                                                              &block::pc_noutput_items,
-                                                              pmt::mp(0),
-                                                              pmt::mp(32768),
-                                                              pmt::mp(0),
-                                                              "",
-                                                              "noutput items",
-                                                              RPC_PRIVLVL_MIN,
-                                                              DISPTIME | DISPOPTSTRIP)));
+    d_rpc_vars.emplace_back(
+        new rpcbasic_register_get<block, float>(alias(),
+                                                "noutput_items",
+                                                &block::pc_noutput_items,
+                                                pmt::mp(0),
+                                                pmt::mp(32768),
+                                                pmt::mp(0),
+                                                "",
+                                                "noutput items",
+                                                RPC_PRIVLVL_MIN,
+                                                DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<block, float>(alias(),
                                                 "avg noutput_items",
                                                 &block::pc_noutput_items_avg,
@@ -696,9 +696,9 @@ void block::setup_pc_rpc()
                                                 "",
                                                 "Average noutput items",
                                                 RPC_PRIVLVL_MIN,
-                                                DISPTIME | DISPOPTSTRIP)));
+                                                DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<block, float>(alias(),
                                                 "var noutput_items",
                                                 &block::pc_noutput_items_var,
@@ -708,45 +708,45 @@ void block::setup_pc_rpc()
                                                 "",
                                                 "Var. noutput items",
                                                 RPC_PRIVLVL_MIN,
-                                                DISPTIME | DISPOPTSTRIP)));
+                                                DISPTIME | DISPOPTSTRIP));
+
+    d_rpc_vars.emplace_back(
+        new rpcbasic_register_get<block, float>(alias(),
+                                                "nproduced",
+                                                &block::pc_nproduced,
+                                                pmt::mp(0),
+                                                pmt::mp(32768),
+                                                pmt::mp(0),
+                                                "",
+                                                "items produced",
+                                                RPC_PRIVLVL_MIN,
+                                                DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, float>(alias(),
-                                                              "nproduced",
-                                                              &block::pc_nproduced,
-                                                              pmt::mp(0),
-                                                              pmt::mp(32768),
-                                                              pmt::mp(0),
-                                                              "",
-                                                              "items produced",
-                                                              RPC_PRIVLVL_MIN,
-                                                              DISPTIME | DISPOPTSTRIP)));
-
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, float>(alias(),
-                                                              "avg nproduced",
-                                                              &block::pc_nproduced_avg,
-                                                              pmt::mp(0),
-                                                              pmt::mp(32768),
-                                                              pmt::mp(0),
-                                                              "",
-                                                              "Average items produced",
-                                                              RPC_PRIVLVL_MIN,
-                                                              DISPTIME | DISPOPTSTRIP)));
-
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, float>(alias(),
-                                                              "var nproduced",
-                                                              &block::pc_nproduced_var,
-                                                              pmt::mp(0),
-                                                              pmt::mp(32768),
-                                                              pmt::mp(0),
-                                                              "",
-                                                              "Var. items produced",
-                                                              RPC_PRIVLVL_MIN,
-                                                              DISPTIME | DISPOPTSTRIP)));
+    d_rpc_vars.emplace_back(
+        new rpcbasic_register_get<block, float>(alias(),
+                                                "avg nproduced",
+                                                &block::pc_nproduced_avg,
+                                                pmt::mp(0),
+                                                pmt::mp(32768),
+                                                pmt::mp(0),
+                                                "",
+                                                "Average items produced",
+                                                RPC_PRIVLVL_MIN,
+                                                DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
+        new rpcbasic_register_get<block, float>(alias(),
+                                                "var nproduced",
+                                                &block::pc_nproduced_var,
+                                                pmt::mp(0),
+                                                pmt::mp(32768),
+                                                pmt::mp(0),
+                                                "",
+                                                "Var. items produced",
+                                                RPC_PRIVLVL_MIN,
+                                                DISPTIME | DISPOPTSTRIP));
+
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<block, float>(alias(),
                                                 "work time",
                                                 &block::pc_work_time,
@@ -756,9 +756,9 @@ void block::setup_pc_rpc()
                                                 "",
                                                 "clock cycles in call to work",
                                                 RPC_PRIVLVL_MIN,
-                                                DISPTIME | DISPOPTSTRIP)));
+                                                DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<block, float>(alias(),
                                                 "avg work time",
                                                 &block::pc_work_time_avg,
@@ -768,9 +768,9 @@ void block::setup_pc_rpc()
                                                 "",
                                                 "Average clock cycles in call to work",
                                                 RPC_PRIVLVL_MIN,
-                                                DISPTIME | DISPOPTSTRIP)));
+                                                DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<block, float>(alias(),
                                                 "var work time",
                                                 &block::pc_work_time_var,
@@ -780,9 +780,9 @@ void block::setup_pc_rpc()
                                                 "",
                                                 "Var. clock cycles in call to work",
                                                 RPC_PRIVLVL_MIN,
-                                                DISPTIME | DISPOPTSTRIP)));
+                                                DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<block, float>(alias(),
                                                 "total work time",
                                                 &block::pc_work_time_total,
@@ -792,9 +792,9 @@ void block::setup_pc_rpc()
                                                 "",
                                                 "Total clock cycles in calls to work",
                                                 RPC_PRIVLVL_MIN,
-                                                DISPTIME | DISPOPTSTRIP)));
+                                                DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(new rpcbasic_register_get<block, float>(
+    d_rpc_vars.emplace_back(new rpcbasic_register_get<block, float>(
         alias(),
         "avg throughput",
         &block::pc_throughput_avg,
@@ -804,85 +804,79 @@ void block::setup_pc_rpc()
         "items/s",
         "Average items throughput in call to work",
         RPC_PRIVLVL_MIN,
-        DISPTIME | DISPOPTSTRIP)));
+        DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, std::vector<float>>(
-            alias(),
-            "input \% full",
-            &block::pc_input_buffers_full,
-            pmt::make_f32vector(0, 0),
-            pmt::make_f32vector(0, 1),
-            pmt::make_f32vector(0, 0),
-            "",
-            "how full input buffers are",
-            RPC_PRIVLVL_MIN,
-            DISPTIME | DISPOPTSTRIP)));
-
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, std::vector<float>>(
-            alias(),
-            "avg input \% full",
-            &block::pc_input_buffers_full_avg,
-            pmt::make_f32vector(0, 0),
-            pmt::make_f32vector(0, 1),
-            pmt::make_f32vector(0, 0),
-            "",
-            "Average of how full input buffers are",
-            RPC_PRIVLVL_MIN,
-            DISPTIME | DISPOPTSTRIP)));
-
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, std::vector<float>>(
-            alias(),
-            "var input \% full",
-            &block::pc_input_buffers_full_var,
-            pmt::make_f32vector(0, 0),
-            pmt::make_f32vector(0, 1),
-            pmt::make_f32vector(0, 0),
-            "",
-            "Var. of how full input buffers are",
-            RPC_PRIVLVL_MIN,
-            DISPTIME | DISPOPTSTRIP)));
-
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, std::vector<float>>(
-            alias(),
-            "output \% full",
-            &block::pc_output_buffers_full,
-            pmt::make_f32vector(0, 0),
-            pmt::make_f32vector(0, 1),
-            pmt::make_f32vector(0, 0),
-            "",
-            "how full output buffers are",
-            RPC_PRIVLVL_MIN,
-            DISPTIME | DISPOPTSTRIP)));
-
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, std::vector<float>>(
-            alias(),
-            "avg output \% full",
-            &block::pc_output_buffers_full_avg,
-            pmt::make_f32vector(0, 0),
-            pmt::make_f32vector(0, 1),
-            pmt::make_f32vector(0, 0),
-            "",
-            "Average of how full output buffers are",
-            RPC_PRIVLVL_MIN,
-            DISPTIME | DISPOPTSTRIP)));
-
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<block, std::vector<float>>(
-            alias(),
-            "var output \% full",
-            &block::pc_output_buffers_full_var,
-            pmt::make_f32vector(0, 0),
-            pmt::make_f32vector(0, 1),
-            pmt::make_f32vector(0, 0),
-            "",
-            "Var. of how full output buffers are",
-            RPC_PRIVLVL_MIN,
-            DISPTIME | DISPOPTSTRIP)));
+    d_rpc_vars.emplace_back(new rpcbasic_register_get<block, std::vector<float>>(
+        alias(),
+        "input \% full",
+        &block::pc_input_buffers_full,
+        pmt::make_f32vector(0, 0),
+        pmt::make_f32vector(0, 1),
+        pmt::make_f32vector(0, 0),
+        "",
+        "how full input buffers are",
+        RPC_PRIVLVL_MIN,
+        DISPTIME | DISPOPTSTRIP));
+
+    d_rpc_vars.emplace_back(new rpcbasic_register_get<block, std::vector<float>>(
+        alias(),
+        "avg input \% full",
+        &block::pc_input_buffers_full_avg,
+        pmt::make_f32vector(0, 0),
+        pmt::make_f32vector(0, 1),
+        pmt::make_f32vector(0, 0),
+        "",
+        "Average of how full input buffers are",
+        RPC_PRIVLVL_MIN,
+        DISPTIME | DISPOPTSTRIP));
+
+    d_rpc_vars.emplace_back(new rpcbasic_register_get<block, std::vector<float>>(
+        alias(),
+        "var input \% full",
+        &block::pc_input_buffers_full_var,
+        pmt::make_f32vector(0, 0),
+        pmt::make_f32vector(0, 1),
+        pmt::make_f32vector(0, 0),
+        "",
+        "Var. of how full input buffers are",
+        RPC_PRIVLVL_MIN,
+        DISPTIME | DISPOPTSTRIP));
+
+    d_rpc_vars.emplace_back(new rpcbasic_register_get<block, std::vector<float>>(
+        alias(),
+        "output \% full",
+        &block::pc_output_buffers_full,
+        pmt::make_f32vector(0, 0),
+        pmt::make_f32vector(0, 1),
+        pmt::make_f32vector(0, 0),
+        "",
+        "how full output buffers are",
+        RPC_PRIVLVL_MIN,
+        DISPTIME | DISPOPTSTRIP));
+
+    d_rpc_vars.emplace_back(new rpcbasic_register_get<block, std::vector<float>>(
+        alias(),
+        "avg output \% full",
+        &block::pc_output_buffers_full_avg,
+        pmt::make_f32vector(0, 0),
+        pmt::make_f32vector(0, 1),
+        pmt::make_f32vector(0, 0),
+        "",
+        "Average of how full output buffers are",
+        RPC_PRIVLVL_MIN,
+        DISPTIME | DISPOPTSTRIP));
+
+    d_rpc_vars.emplace_back(new rpcbasic_register_get<block, std::vector<float>>(
+        alias(),
+        "var output \% full",
+        &block::pc_output_buffers_full_var,
+        pmt::make_f32vector(0, 0),
+        pmt::make_f32vector(0, 1),
+        pmt::make_f32vector(0, 0),
+        "",
+        "Var. of how full output buffers are",
+        RPC_PRIVLVL_MIN,
+        DISPTIME | DISPOPTSTRIP));
 #endif /* defined(GR_CTRLPORT) && defined(GR_PERFORMANCE_COUNTERS) */
 }
 
diff -uNrp a/gnuradio-runtime/lib/block_detail.cc b/gnuradio-runtime/lib/block_detail.cc
--- a/gnuradio-runtime/lib/block_detail.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/lib/block_detail.cc	2019-10-20 04:31:39.000000000 +0700
@@ -231,9 +231,8 @@ void block_detail::set_processor_affinit
     if (threaded) {
         try {
             gr::thread::thread_bind_to_processor(thread, mask);
-        } catch (std::runtime_error e) {
+        } catch (std::runtime_error& e) {
             std::cerr << "set_processor_affinity: invalid mask." << std::endl;
-            ;
         }
     }
 }
diff -uNrp a/gnuradio-runtime/lib/block_executor.cc b/gnuradio-runtime/lib/block_executor.cc
--- a/gnuradio-runtime/lib/block_executor.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/lib/block_executor.cc	2019-10-20 04:31:39.000000000 +0700
@@ -124,10 +124,11 @@ static bool propagate_tags(block::tag_pr
             d->get_tags_in_range(
                 rtags, i, start_nitems_read[i], d->nitems_read(i), block_id);
 
-            if (rtags.size() == 0)
+            if (rtags.empty()) {
                 continue;
+            }
 
-            if (out_buf.size() == 0) {
+            if (out_buf.empty()) {
                 out_buf.reserve(d->noutputs());
                 for (int o = 0; o < d->noutputs(); o++)
                     out_buf.push_back(d->output(o));
@@ -176,8 +177,9 @@ static bool propagate_tags(block::tag_pr
                 d->get_tags_in_range(
                     rtags, i, start_nitems_read[i], d->nitems_read(i), block_id);
 
-                if (rtags.size() == 0)
+                if (rtags.empty()) {
                     continue;
+                }
 
                 out_buf = d->output(i);
 
diff -uNrp a/gnuradio-runtime/lib/flowgraph.cc b/gnuradio-runtime/lib/flowgraph.cc
--- a/gnuradio-runtime/lib/flowgraph.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/lib/flowgraph.cc	2019-10-20 04:31:39.000000000 +0700
@@ -328,7 +328,7 @@ std::vector<basic_block_vector_t> flowgr
     basic_block_vector_t blocks = calc_used_blocks();
     basic_block_vector_t graph;
 
-    while (blocks.size() > 0) {
+    while (!blocks.empty()) {
         graph = calc_reachable_blocks(blocks[0], blocks);
         assert(graph.size());
         result.push_back(topological_sort(graph));
@@ -432,7 +432,7 @@ basic_block_vector_t flowgraph::sort_sou
 
 bool flowgraph::source_p(basic_block_sptr block)
 {
-    return (calc_upstream_edges(block).size() == 0);
+    return calc_upstream_edges(block).empty();
 }
 
 void flowgraph::topological_dfs_visit(basic_block_sptr block,
@@ -491,6 +491,7 @@ std::string dot_graph_fg(flowgraph_sptr 
 {
     basic_block_vector_t blocks = fg->calc_used_blocks();
     edge_vector_t edges = fg->edges();
+    msg_edge_vector_t msg_edges = fg->msg_edges();
 
     std::stringstream out;
 
@@ -498,7 +499,7 @@ std::string dot_graph_fg(flowgraph_sptr 
 
     // Define nodes and set labels
     for (basic_block_viter_t block = blocks.begin(); block != blocks.end(); ++block) {
-        out << (*block)->unique_id() << " [ label=\"" << (*block)->name() << "\" ]"
+        out << (*block)->unique_id() << " [ label=\"" << (*block)->alias() << "\" ]"
             << std::endl;
     }
 
@@ -508,6 +509,11 @@ std::string dot_graph_fg(flowgraph_sptr 
             << edge->dst().block()->unique_id() << std::endl;
     }
 
+    for (msg_edge_viter_t edge = msg_edges.begin(); edge != msg_edges.end(); edge++) {
+        out << edge->src().block()->unique_id() << " -> "
+            << edge->dst().block()->unique_id() << " [color=blue]" << std::endl;
+    }
+
     out << "}" << std::endl;
 
     return out.str();
diff -uNrp a/gnuradio-runtime/lib/hier_block2.cc b/gnuradio-runtime/lib/hier_block2.cc
--- a/gnuradio-runtime/lib/hier_block2.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/lib/hier_block2.cc	2019-10-20 04:31:39.000000000 +0700
@@ -171,9 +171,10 @@ int hier_block2::max_output_buffer(size_
 void hier_block2::set_max_output_buffer(int max_output_buffer)
 {
     if (output_signature()->max_streams() > 0) {
-        if (d_detail->d_max_output_buffer.size() == 0)
+        if (d_detail->d_max_output_buffer.empty()) {
             throw std::length_error("hier_block2::set_max_output_buffer(int): out_sig "
                                     "greater than zero, buff_vect isn't");
+        }
         for (int idx = 0; idx < output_signature()->max_streams(); idx++) {
             d_detail->d_max_output_buffer[idx] = max_output_buffer;
         }
@@ -182,10 +183,10 @@ void hier_block2::set_max_output_buffer(
 
 void hier_block2::set_max_output_buffer(size_t port, int max_output_buffer)
 {
-    if (port >= d_detail->d_max_output_buffer.size())
+    if (port >= d_detail->d_max_output_buffer.size()) {
         throw std::invalid_argument(
             "hier_block2::set_max_output_buffer(size_t,int): port out of range.");
-    else {
+    } else {
         d_detail->d_max_output_buffer[port] = max_output_buffer;
     }
 }
@@ -201,9 +202,10 @@ int hier_block2::min_output_buffer(size_
 void hier_block2::set_min_output_buffer(int min_output_buffer)
 {
     if (output_signature()->max_streams() > 0) {
-        if (d_detail->d_min_output_buffer.size() == 0)
+        if (d_detail->d_min_output_buffer.empty()) {
             throw std::length_error("hier_block2::set_min_output_buffer(int): out_sig "
                                     "greater than zero, buff_vect isn't");
+        }
         for (int idx = 0; idx < output_signature()->max_streams(); idx++) {
             d_detail->d_min_output_buffer[idx] = min_output_buffer;
         }
@@ -222,8 +224,9 @@ void hier_block2::set_min_output_buffer(
 
 bool hier_block2::all_min_output_buffer_p(void)
 {
-    if (!d_detail->d_min_output_buffer.size())
+    if (d_detail->d_min_output_buffer.empty()) {
         return false;
+    }
     for (size_t idx = 1; idx < d_detail->d_min_output_buffer.size(); idx++) {
         if (d_detail->d_min_output_buffer[0] != d_detail->d_min_output_buffer[idx])
             return false;
@@ -232,7 +235,7 @@ bool hier_block2::all_min_output_buffer_
 }
 bool hier_block2::all_max_output_buffer_p(void)
 {
-    if (!d_detail->d_max_output_buffer.size())
+    if (d_detail->d_max_output_buffer.empty())
         return false;
     for (size_t idx = 1; idx < d_detail->d_max_output_buffer.size(); idx++) {
         if (d_detail->d_max_output_buffer[0] != d_detail->d_max_output_buffer[idx])
diff -uNrp a/gnuradio-runtime/lib/hier_block2_detail.cc b/gnuradio-runtime/lib/hier_block2_detail.cc
--- a/gnuradio-runtime/lib/hier_block2_detail.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/lib/hier_block2_detail.cc	2019-10-20 04:31:39.000000000 +0700
@@ -288,7 +288,7 @@ void hier_block2_detail::disconnect(basi
         }
     }
 
-    if (edges.size() == 0) {
+    if (edges.empty()) {
         std::stringstream msg;
         msg << "cannot disconnect block " << block << ", not found";
         throw std::invalid_argument(msg.str());
@@ -560,7 +560,7 @@ void hier_block2_detail::flatten_aux(fla
     edge_vector_t edges = d_fg->edges();
     msg_edge_vector_t msg_edges = d_fg->msg_edges();
     edge_viter_t p;
-    msg_edge_viter_t q, u;
+    msg_edge_viter_t q;
 
     // Only run setup_rpc if ControlPort config param is enabled.
     bool ctrlport_on = prefs::singleton()->get_bool("ControlPort", "on", false);
@@ -784,7 +784,7 @@ void hier_block2_detail::flatten_aux(fla
     // Now add the list of connected input blocks
     std::stringstream msg;
     for (unsigned int i = 0; i < d_inputs.size(); i++) {
-        if (d_inputs[i].size() == 0) {
+        if (d_inputs[i].empty()) {
             msg << "In hierarchical block " << d_owner->name() << ", input " << i
                 << " is not connected internally";
             throw std::runtime_error(msg.str());
diff -uNrp a/gnuradio-runtime/lib/io_signature.cc b/gnuradio-runtime/lib/io_signature.cc
--- a/gnuradio-runtime/lib/io_signature.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/lib/io_signature.cc	2019-10-20 04:31:39.000000000 +0700
@@ -79,8 +79,9 @@ io_signature::io_signature(int min_strea
     if (min_streams < 0 || (max_streams != IO_INFINITE && max_streams < min_streams))
         throw std::invalid_argument("gr::io_signature(1)");
 
-    if (sizeof_stream_items.size() < 1)
+    if (sizeof_stream_items.empty()) {
         throw std::invalid_argument("gr::io_signature(2)");
+    }
 
     for (size_t i = 0; i < sizeof_stream_items.size(); i++) {
         if (max_streams != 0 && sizeof_stream_items[i] < 1)
diff -uNrp a/gnuradio-runtime/lib/logger.cc b/gnuradio-runtime/lib/logger.cc
--- a/gnuradio-runtime/lib/logger.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/lib/logger.cc	2019-10-20 04:31:39.000000000 +0700
@@ -157,7 +157,7 @@ logger_ptr logger_get_logger(std::string
 
 bool logger_load_config(const std::string& config_filename)
 {
-    if (config_filename.size() != 0) {
+    if (!config_filename.empty()) {
         try {
             log4cpp::PropertyConfigurator::configure(config_filename);
             return true;
@@ -343,7 +343,7 @@ bool configure_default_loggers(gr::logge
     GR_LOG_GETLOGGER(LOG, "gr_log." + name);
     GR_LOG_SET_LEVEL(LOG, log_level);
 
-    if (log_file.size() > 0) {
+    if (!log_file.empty()) {
         if (log_file == "stdout") {
             GR_LOG_SET_CONSOLE_APPENDER(LOG, "stdout", "gr::log :%p: %c{1} - %m%n");
         } else if (log_file == "stderr") {
@@ -356,7 +356,7 @@ bool configure_default_loggers(gr::logge
 
     GR_LOG_GETLOGGER(DLOG, "gr_log_debug." + name);
     GR_LOG_SET_LEVEL(DLOG, debug_level);
-    if (debug_file.size() > 0) {
+    if (!debug_file.empty()) {
         if (debug_file == "stdout") {
             GR_LOG_SET_CONSOLE_APPENDER(DLOG, "stdout", "gr::debug :%p: %c{1} - %m%n");
         } else if (debug_file == "stderr") {
@@ -376,7 +376,7 @@ bool update_logger_alias(const std::stri
     std::string debug_file = p->get_string("LOG", "debug_file", "");
 
     GR_LOG_GETLOGGER(LOG, "gr_log." + name);
-    if (log_file.size() > 0) {
+    if (!log_file.empty()) {
         if (log_file == "stdout") {
             boost::format str("gr::log :%%p: %1% - %%m%%n");
             GR_LOG_SET_CONSOLE_APPENDER(LOG, "stdout", boost::str(str % alias));
diff -uNrp a/gnuradio-runtime/lib/prefs.cc b/gnuradio-runtime/lib/prefs.cc
--- a/gnuradio-runtime/lib/prefs.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/lib/prefs.cc	2019-10-20 04:31:39.000000000 +0700
@@ -110,7 +110,7 @@ void prefs::_read_files(const std::vecto
                     std::string value = o.value[0];
                     d_config_map[section][key] = value;
                 }
-            } catch (std::exception e) {
+            } catch (std::exception& e) {
                 std::cerr << "WARNING: Config file '" << fname
                           << "' failed to parse:" << std::endl;
                 std::cerr << e.what() << std::endl;
@@ -243,7 +243,7 @@ bool prefs::get_bool(const std::string& 
 {
     if (has_option(section, option)) {
         std::string str = get_string(section, option, "");
-        if (str == "") {
+        if (str.empty()) {
             return default_val;
         }
         std::transform(str.begin(), str.end(), str.begin(), ::tolower);
@@ -281,7 +281,7 @@ long prefs::get_long(const std::string& 
 {
     if (has_option(section, option)) {
         std::string str = get_string(section, option, "");
-        if (str == "") {
+        if (str.empty()) {
             return default_val;
         }
         std::stringstream sstr(str);
@@ -316,7 +316,7 @@ double prefs::get_double(const std::stri
 {
     if (has_option(section, option)) {
         std::string str = get_string(section, option, "");
-        if (str == "") {
+        if (str.empty()) {
             return default_val;
         }
         std::stringstream sstr(str);
diff -uNrp a/gnuradio-runtime/lib/top_block.cc b/gnuradio-runtime/lib/top_block.cc
--- a/gnuradio-runtime/lib/top_block.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/lib/top_block.cc	2019-10-20 04:31:39.000000000 +0700
@@ -109,14 +109,14 @@ void top_block::setup_rpc()
         return;
 
     // Triggers
-    d_rpc_vars.push_back(rpcbasic_sptr(new rpcbasic_register_trigger<top_block>(
-        alias(), "stop", &top_block::stop, "Stop the flowgraph", RPC_PRIVLVL_MIN)));
+    d_rpc_vars.emplace_back(new rpcbasic_register_trigger<top_block>(
+        alias(), "stop", &top_block::stop, "Stop the flowgraph", RPC_PRIVLVL_MIN));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(new rpcbasic_register_trigger<top_block>(
-        alias(), "lock", &top_block::lock, "Lock the flowgraph", RPC_PRIVLVL_MIN)));
+    d_rpc_vars.emplace_back(new rpcbasic_register_trigger<top_block>(
+        alias(), "lock", &top_block::lock, "Lock the flowgraph", RPC_PRIVLVL_MIN));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(new rpcbasic_register_trigger<top_block>(
-        alias(), "unlock", &top_block::unlock, "Unock the flowgraph", RPC_PRIVLVL_MIN)));
+    d_rpc_vars.emplace_back(new rpcbasic_register_trigger<top_block>(
+        alias(), "unlock", &top_block::unlock, "Unock the flowgraph", RPC_PRIVLVL_MIN));
 
     // Getters
     add_rpc_variable(rpcbasic_sptr(
diff -uNrp a/gnuradio-runtime/lib/tpb_thread_body.cc b/gnuradio-runtime/lib/tpb_thread_body.cc
--- a/gnuradio-runtime/lib/tpb_thread_body.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gnuradio-runtime/lib/tpb_thread_body.cc	2019-10-20 04:31:39.000000000 +0700
@@ -68,7 +68,7 @@ tpb_thread_body::tpb_thread_body(block_s
     GR_LOG_GETLOGGER(LOG, "gr_log.tpb_thread_body");
     GR_LOG_SET_LEVEL(LOG, log_level);
     GR_CONFIG_LOGGER(config_file);
-    if (log_file.size() > 0) {
+    if (!log_file.empty()) {
         if (log_file == "stdout") {
             GR_LOG_SET_CONSOLE_APPENDER(LOG, "stdout", "gr::log :%p: %c{1} - %m%n");
         } else if (log_file == "stderr") {
@@ -79,7 +79,7 @@ tpb_thread_body::tpb_thread_body(block_s
     }
 
     // Set thread affinity if it was set before fg was started.
-    if (block->processor_affinity().size() > 0) {
+    if (!block->processor_affinity().empty()) {
         gr::thread::thread_bind_to_processor(d->thread, block->processor_affinity());
     }
 
diff -uNrp a/gr-analog/python/analog/fm_demod.py b/gr-analog/python/analog/fm_demod.py
--- a/gr-analog/python/analog/fm_demod.py	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-analog/python/analog/fm_demod.py	2019-10-20 04:31:39.000000000 +0700
@@ -110,5 +110,4 @@ class demod_200kf3e_cf(fm_demod_cf):
         fm_demod_cf.__init__(self, channel_rate, audio_decim,
                              75000,  # Deviation
                              15000,  # Audio passband
-                             16000,  # Audio stopband
-                             20.0)   # Audio gain
+                             16000)  # Audio stopband
diff -uNrp a/gr-analog/python/analog/wfm_rcv_fmdet.py b/gr-analog/python/analog/wfm_rcv_fmdet.py
--- a/gr-analog/python/analog/wfm_rcv_fmdet.py	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-analog/python/analog/wfm_rcv_fmdet.py	2019-10-20 04:31:39.000000000 +0700
@@ -115,7 +115,7 @@ class wfm_rcv_fmdet(gr.hier_block2):
                                       stereo_carrier_filter_coeffs)
 
             # carrier is twice the picked off carrier so arrange to do
-            # a commplex multiply
+            # a complex multiply
             self.stereo_carrier_generator = blocks.multiply_cc();
 
             # Pick off the rds signal
diff -uNrp a/gr-analog/python/analog/wfm_rcv_pll.py b/gr-analog/python/analog/wfm_rcv_pll.py
--- a/gr-analog/python/analog/wfm_rcv_pll.py	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-analog/python/analog/wfm_rcv_pll.py	2019-10-20 04:31:39.000000000 +0700
@@ -106,7 +106,7 @@ class wfm_rcv_pll(gr.hier_block2):
             self.stereo_carrier_filter = \
                 filter.fir_filter_fcc(audio_decimation, stereo_carrier_filter_coeffs)
 
-            # carrier is twice the picked off carrier so arrange to do a commplex multiply
+            # carrier is twice the picked off carrier so arrange to do a complex multiply
 
             self.stereo_carrier_generator = blocks.multiply_cc();
 
diff -uNrp a/gr-audio/lib/jack/jack_sink.cc b/gr-audio/lib/jack/jack_sink.cc
--- a/gr-audio/lib/jack/jack_sink.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-audio/lib/jack/jack_sink.cc	2019-10-20 04:31:39.000000000 +0700
@@ -99,7 +99,6 @@ jack_sink::jack_sink(int sampling_rate, 
           "audio_jack_sink", io_signature::make(0, 0, 0), io_signature::make(0, 0, 0)),
       d_sampling_rate(sampling_rate),
       d_device_name(device_name.empty() ? default_device_name() : device_name),
-      d_ok_to_block(ok_to_block),
       d_jack_client(0),
       d_portcount(0),
       d_jack_output_port(),
diff -uNrp a/gr-audio/lib/jack/jack_sink.h b/gr-audio/lib/jack/jack_sink.h
--- a/gr-audio/lib/jack/jack_sink.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-audio/lib/jack/jack_sink.h	2019-10-20 04:31:39.000000000 +0700
@@ -52,7 +52,6 @@ class jack_sink : public sink
 
     unsigned int d_sampling_rate;
     std::string d_device_name;
-    bool d_ok_to_block;
 
     jack_client_t* d_jack_client;
     static const int MAX_PORTS = 10;
diff -uNrp a/gr-audio/lib/jack/jack_source.cc b/gr-audio/lib/jack/jack_source.cc
--- a/gr-audio/lib/jack/jack_source.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-audio/lib/jack/jack_source.cc	2019-10-20 04:31:39.000000000 +0700
@@ -101,7 +101,6 @@ jack_source::jack_source(int sampling_ra
           "audio_jack_source", io_signature::make(0, 0, 0), io_signature::make(0, 0, 0)),
       d_sampling_rate(sampling_rate),
       d_device_name(device_name.empty() ? default_device_name() : device_name),
-      d_ok_to_block(ok_to_block),
       d_jack_client(0),
       d_portcount(0),
       d_jack_input_port(),
diff -uNrp a/gr-audio/lib/jack/jack_source.h b/gr-audio/lib/jack/jack_source.h
--- a/gr-audio/lib/jack/jack_source.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-audio/lib/jack/jack_source.h	2019-10-20 04:31:39.000000000 +0700
@@ -52,7 +52,6 @@ class jack_source : public source
 
     unsigned int d_sampling_rate;
     std::string d_device_name;
-    bool d_ok_to_block;
 
     jack_client_t* d_jack_client;
     static const int MAX_PORTS = 10;
diff -uNrp a/gr-blocks/lib/ctrlport_probe2_b_impl.cc b/gr-blocks/lib/ctrlport_probe2_b_impl.cc
--- a/gr-blocks/lib/ctrlport_probe2_b_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/ctrlport_probe2_b_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -116,7 +116,7 @@ void ctrlport_probe2_b_impl::setup_rpc()
 {
 #ifdef GR_CTRLPORT
     int len = static_cast<int>(d_len);
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe2_b, std::vector<signed char>>(
             alias(),
             d_id.c_str(),
@@ -127,9 +127,9 @@ void ctrlport_probe2_b_impl::setup_rpc()
             "volts",
             d_desc.c_str(),
             RPC_PRIVLVL_MIN,
-            d_disp_mask)));
+            d_disp_mask));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe2_b, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_b::length,
@@ -139,9 +139,9 @@ void ctrlport_probe2_b_impl::setup_rpc()
                                                           "samples",
                                                           "get vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_set<ctrlport_probe2_b, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_b::set_length,
@@ -151,7 +151,7 @@ void ctrlport_probe2_b_impl::setup_rpc()
                                                           "samples",
                                                           "set vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 #endif /* GR_CTRLPORT */
 }
 
diff -uNrp a/gr-blocks/lib/ctrlport_probe2_c_impl.cc b/gr-blocks/lib/ctrlport_probe2_c_impl.cc
--- a/gr-blocks/lib/ctrlport_probe2_c_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/ctrlport_probe2_c_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -116,7 +116,7 @@ void ctrlport_probe2_c_impl::setup_rpc()
 {
 #ifdef GR_CTRLPORT
     int len = static_cast<int>(d_len);
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe2_c, std::vector<std::complex<float>>>(
             alias(),
             d_id.c_str(),
@@ -127,9 +127,9 @@ void ctrlport_probe2_c_impl::setup_rpc()
             "volts",
             d_desc.c_str(),
             RPC_PRIVLVL_MIN,
-            d_disp_mask | DISPOPTCPLX)));
+            d_disp_mask | DISPOPTCPLX));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe2_c, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_c::length,
@@ -139,9 +139,9 @@ void ctrlport_probe2_c_impl::setup_rpc()
                                                           "samples",
                                                           "get vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_set<ctrlport_probe2_c, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_c::set_length,
@@ -151,7 +151,7 @@ void ctrlport_probe2_c_impl::setup_rpc()
                                                           "samples",
                                                           "set vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 #endif /* GR_CTRLPORT */
 }
 
diff -uNrp a/gr-blocks/lib/ctrlport_probe2_f_impl.cc b/gr-blocks/lib/ctrlport_probe2_f_impl.cc
--- a/gr-blocks/lib/ctrlport_probe2_f_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/ctrlport_probe2_f_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -116,8 +116,8 @@ void ctrlport_probe2_f_impl::setup_rpc()
 {
 #ifdef GR_CTRLPORT
     int len = static_cast<int>(d_len);
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<ctrlport_probe2_f, std::vector<float>>(
+    d_rpc_vars.emplace_back(
+        new rpcbasic_register_get<ctrlport_probe2_f, std::vector<float>>(
             alias(),
             d_id.c_str(),
             &ctrlport_probe2_f::get,
@@ -130,9 +130,9 @@ void ctrlport_probe2_f_impl::setup_rpc()
             "volts",
             d_desc.c_str(),
             RPC_PRIVLVL_MIN,
-            d_disp_mask)));
+            d_disp_mask));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe2_f, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_f::length,
@@ -142,9 +142,9 @@ void ctrlport_probe2_f_impl::setup_rpc()
                                                           "samples",
                                                           "get vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_set<ctrlport_probe2_f, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_f::set_length,
@@ -154,7 +154,7 @@ void ctrlport_probe2_f_impl::setup_rpc()
                                                           "samples",
                                                           "set vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 #endif /* GR_CTRLPORT */
 }
 
diff -uNrp a/gr-blocks/lib/ctrlport_probe2_i_impl.cc b/gr-blocks/lib/ctrlport_probe2_i_impl.cc
--- a/gr-blocks/lib/ctrlport_probe2_i_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/ctrlport_probe2_i_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -115,8 +115,8 @@ void ctrlport_probe2_i_impl::setup_rpc()
 {
 #ifdef GR_CTRLPORT
     int len = static_cast<int>(d_len);
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<ctrlport_probe2_i, std::vector<int>>(
+    d_rpc_vars.emplace_back(
+        new rpcbasic_register_get<ctrlport_probe2_i, std::vector<int>>(
             alias(),
             d_id.c_str(),
             &ctrlport_probe2_i::get,
@@ -126,9 +126,9 @@ void ctrlport_probe2_i_impl::setup_rpc()
             "volts",
             d_desc.c_str(),
             RPC_PRIVLVL_MIN,
-            d_disp_mask)));
+            d_disp_mask));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe2_i, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_i::length,
@@ -138,9 +138,9 @@ void ctrlport_probe2_i_impl::setup_rpc()
                                                           "samples",
                                                           "get vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_set<ctrlport_probe2_i, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_i::set_length,
@@ -150,7 +150,7 @@ void ctrlport_probe2_i_impl::setup_rpc()
                                                           "samples",
                                                           "set vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 #endif /* GR_CTRLPORT */
 }
 
diff -uNrp a/gr-blocks/lib/ctrlport_probe2_s_impl.cc b/gr-blocks/lib/ctrlport_probe2_s_impl.cc
--- a/gr-blocks/lib/ctrlport_probe2_s_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/ctrlport_probe2_s_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -115,8 +115,8 @@ void ctrlport_probe2_s_impl::setup_rpc()
 {
 #ifdef GR_CTRLPORT
     int len = static_cast<int>(d_len);
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<ctrlport_probe2_s, std::vector<short>>(
+    d_rpc_vars.emplace_back(
+        new rpcbasic_register_get<ctrlport_probe2_s, std::vector<short>>(
             alias(),
             d_id.c_str(),
             &ctrlport_probe2_s::get,
@@ -126,9 +126,9 @@ void ctrlport_probe2_s_impl::setup_rpc()
             "volts",
             d_desc.c_str(),
             RPC_PRIVLVL_MIN,
-            d_disp_mask)));
+            d_disp_mask));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe2_s, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_s::length,
@@ -138,9 +138,9 @@ void ctrlport_probe2_s_impl::setup_rpc()
                                                           "samples",
                                                           "get vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_set<ctrlport_probe2_s, int>(alias(),
                                                           "length",
                                                           &ctrlport_probe2_s::set_length,
@@ -150,7 +150,7 @@ void ctrlport_probe2_s_impl::setup_rpc()
                                                           "samples",
                                                           "set vector length",
                                                           RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+                                                          DISPNULL));
 #endif /* GR_CTRLPORT */
 }
 
diff -uNrp a/gr-blocks/lib/ctrlport_probe_c_impl.cc b/gr-blocks/lib/ctrlport_probe_c_impl.cc
--- a/gr-blocks/lib/ctrlport_probe_c_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/ctrlport_probe_c_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -81,7 +81,7 @@ int ctrlport_probe_c_impl::work(int nout
 void ctrlport_probe_c_impl::setup_rpc()
 {
 #ifdef GR_CTRLPORT
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe_c, std::vector<std::complex<float>>>(
             alias(),
             d_id.c_str(),
@@ -92,7 +92,7 @@ void ctrlport_probe_c_impl::setup_rpc()
             "volts",
             d_desc.c_str(),
             RPC_PRIVLVL_MIN,
-            DISPXY | DISPOPTSCATTER)));
+            DISPXY | DISPOPTSCATTER));
 #endif /* GR_CTRLPORT */
 }
 
diff -uNrp a/gr-blocks/lib/file_meta_source_impl.cc b/gr-blocks/lib/file_meta_source_impl.cc
--- a/gr-blocks/lib/file_meta_source_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/file_meta_source_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -258,7 +258,7 @@ bool file_meta_source_impl::open(const s
     bool ret = true;
     if (d_state == STATE_DETACHED) {
         std::string s;
-        if (hdr_filename == "")
+        if (hdr_filename.empty())
             s = filename + ".hdr";
         else
             s = hdr_filename;
diff -uNrp a/gr-blocks/lib/multiply_matrix_impl.cc b/gr-blocks/lib/multiply_matrix_impl.cc
--- a/gr-blocks/lib/multiply_matrix_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/multiply_matrix_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -212,7 +212,7 @@ typename multiply_matrix<T>::sptr
 multiply_matrix<T>::make(std::vector<std::vector<T>> A,
                          gr::block::tag_propagation_policy_t tag_propagation_policy)
 {
-    if (A.empty() || A[0].size() == 0) {
+    if (A.empty() || A[0].empty()) {
         throw std::invalid_argument("matrix A has invalid dimensions.");
     }
     return gnuradio::get_initial_sptr(
diff -uNrp a/gr-blocks/lib/mute_impl.cc b/gr-blocks/lib/mute_impl.cc
--- a/gr-blocks/lib/mute_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/mute_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2004,2010,2013,2018 Free Software Foundation, Inc.
+ * Copyright 2004,2010,2013,2018,2019 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -28,6 +28,7 @@
 #include "mute_impl.h"
 #include <gnuradio/io_signature.h>
 #include <string.h>
+#include <algorithm>
 
 namespace gr {
 namespace blocks {
@@ -66,7 +67,7 @@ int mute_impl<T>::work(int noutput_items
     int size = noutput_items;
 
     if (d_mute) {
-        memset(optr, 0, noutput_items * sizeof(T));
+        std::fill_n(optr, noutput_items, 0);
     } else {
         while (size >= 8) {
             *optr++ = *iptr++;
diff -uNrp a/gr-blocks/lib/nop_impl.cc b/gr-blocks/lib/nop_impl.cc
--- a/gr-blocks/lib/nop_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/nop_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -69,19 +69,18 @@ int nop_impl::general_work(int noutput_i
 void nop_impl::setup_rpc()
 {
 #ifdef GR_CTRLPORT
-    d_rpc_vars.push_back(
-        rpcbasic_sptr(new rpcbasic_register_get<nop, int>(alias(),
-                                                          "test",
-                                                          &nop::ctrlport_test,
-                                                          pmt::mp(-256),
-                                                          pmt::mp(255),
-                                                          pmt::mp(0),
-                                                          "",
-                                                          "Simple testing variable",
-                                                          RPC_PRIVLVL_MIN,
-                                                          DISPNULL)));
+    d_rpc_vars.emplace_back(new rpcbasic_register_get<nop, int>(alias(),
+                                                                "test",
+                                                                &nop::ctrlport_test,
+                                                                pmt::mp(-256),
+                                                                pmt::mp(255),
+                                                                pmt::mp(0),
+                                                                "",
+                                                                "Simple testing variable",
+                                                                RPC_PRIVLVL_MIN,
+                                                                DISPNULL));
 
-    d_rpc_vars.push_back(
+    d_rpc_vars.emplace_back(
         rpcbasic_sptr(new rpcbasic_register_set<nop, int>(alias(),
                                                           "test",
                                                           &nop::set_ctrlport_test,
diff -uNrp a/gr-blocks/lib/qa_gr_flowgraph.cc b/gr-blocks/lib/qa_gr_flowgraph.cc
--- a/gr-blocks/lib/qa_gr_flowgraph.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/qa_gr_flowgraph.cc	2019-10-20 04:31:39.000000000 +0700
@@ -269,8 +269,8 @@ BOOST_AUTO_TEST_CASE(t15_clear)
 
     fg->clear();
 
-    BOOST_REQUIRE(fg->edges().size() == 0);
-    BOOST_REQUIRE(fg->calc_used_blocks().size() == 0);
+    BOOST_REQUIRE(fg->edges().empty());
+    BOOST_REQUIRE(fg->calc_used_blocks().empty());
 }
 
 BOOST_AUTO_TEST_CASE(t16_partition)
diff -uNrp a/gr-blocks/lib/tag_debug_impl.cc b/gr-blocks/lib/tag_debug_impl.cc
--- a/gr-blocks/lib/tag_debug_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/tag_debug_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -71,7 +71,7 @@ void tag_debug_impl::set_display(bool d)
 
 void tag_debug_impl::set_key_filter(const std::string& key_filter)
 {
-    if (key_filter == "")
+    if (key_filter.empty())
         d_filter = pmt::PMT_NIL;
     else
         d_filter = pmt::intern(key_filter);
@@ -104,7 +104,7 @@ int tag_debug_impl::work(int noutput_ite
         else
             get_tags_in_range(d_tags, i, abs_N, end_N, d_filter);
 
-        if (d_tags.size() > 0) {
+        if (!d_tags.empty()) {
             toprint = true;
         }
 
diff -uNrp a/gr-blocks/lib/tag_gate_impl.cc b/gr-blocks/lib/tag_gate_impl.cc
--- a/gr-blocks/lib/tag_gate_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/tag_gate_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -64,7 +64,7 @@ void tag_gate_impl::set_propagation(bool
 
 void tag_gate_impl::set_single_key(const std::string& single_key)
 {
-    if (single_key == "") {
+    if (single_key.empty()) {
         d_single_key = pmt::PMT_NIL;
         d_single_key_set = false;
     } else {
diff -uNrp a/gr-blocks/lib/tagged_file_sink_impl.cc b/gr-blocks/lib/tagged_file_sink_impl.cc
--- a/gr-blocks/lib/tagged_file_sink_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/tagged_file_sink_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -94,7 +94,7 @@ int tagged_file_sink_impl::work(int nout
     // Look for a time tag and initialize d_timeval.
     std::vector<tag_t> time_tags_outer;
     get_tags_in_range(time_tags_outer, 0, start_N, end_N, tkey);
-    if (time_tags_outer.size() > 0) {
+    if (!time_tags_outer.empty()) {
         const tag_t tag = time_tags_outer[0];
         uint64_t offset = tag.offset;
         pmt::pmt_t time = tag.value;
@@ -122,7 +122,7 @@ int tagged_file_sink_impl::work(int nout
                     std::vector<tag_t> time_tags;
                     // get_tags_in_range(time_tags, 0, d_last_N, N, gr_tags::key_time);
                     get_tags_in_range(time_tags, 0, d_last_N, N, tkey);
-                    if (time_tags.size() > 0) {
+                    if (!time_tags.empty()) {
                         const tag_t tag = time_tags[time_tags.size() - 1];
 
                         uint64_t time_nitems = tag.offset;
diff -uNrp a/gr-blocks/lib/tagged_stream_align_impl.cc b/gr-blocks/lib/tagged_stream_align_impl.cc
--- a/gr-blocks/lib/tagged_stream_align_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/tagged_stream_align_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -72,7 +72,7 @@ int tagged_stream_align_impl::general_wo
     } else {
         get_tags_in_range(
             tags, 0, nitems_read(0), nitems_read(0) + ninput_items[0], d_lengthtag);
-        if (tags.size() > 0) {
+        if (!tags.empty()) {
             d_have_sync = true;
             consume_each(tags[0].offset - nitems_read(0));
         } else {
diff -uNrp a/gr-blocks/lib/throttle_impl.cc b/gr-blocks/lib/throttle_impl.cc
--- a/gr-blocks/lib/throttle_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/throttle_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -116,7 +116,7 @@ int throttle_impl::work(int noutput_item
 void throttle_impl::setup_rpc()
 {
 #ifdef GR_CTRLPORT
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<throttle, double>(alias(),
                                                     "sample_rate",
                                                     &throttle::sample_rate,
@@ -126,9 +126,9 @@ void throttle_impl::setup_rpc()
                                                     "Hz",
                                                     "Sample Rate",
                                                     RPC_PRIVLVL_MIN,
-                                                    DISPTIME | DISPOPTSTRIP)));
+                                                    DISPTIME | DISPOPTSTRIP));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_set<throttle, double>(alias(),
                                                     "sample_rate",
                                                     &throttle::set_sample_rate,
@@ -138,7 +138,7 @@ void throttle_impl::setup_rpc()
                                                     "Hz",
                                                     "Sample Rate",
                                                     RPC_PRIVLVL_MIN,
-                                                    DISPTIME | DISPOPTSTRIP)));
+                                                    DISPTIME | DISPOPTSTRIP));
 #endif /* GR_CTRLPORT */
 }
 
diff -uNrp a/gr-blocks/lib/udp_sink_impl.cc b/gr-blocks/lib/udp_sink_impl.cc
--- a/gr-blocks/lib/udp_sink_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/udp_sink_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -70,7 +70,7 @@ void udp_sink_impl::connect(const std::s
         disconnect();
 
     std::string s_port = (boost::format("%d") % port).str();
-    if (host.size() > 0) {
+    if (!host.empty()) {
         boost::asio::ip::udp::resolver resolver(d_io_service);
         boost::asio::ip::udp::resolver::query query(
             host, s_port, boost::asio::ip::resolver_query_base::passive);
diff -uNrp a/gr-blocks/lib/udp_source_impl.cc b/gr-blocks/lib/udp_source_impl.cc
--- a/gr-blocks/lib/udp_source_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/udp_source_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -84,7 +84,7 @@ void udp_source_impl::connect(const std:
     std::string s_port;
     s_port = (boost::format("%d") % d_port).str();
 
-    if (host.size() > 0) {
+    if (!host.empty()) {
         boost::asio::ip::udp::resolver resolver(d_io_service);
         boost::asio::ip::udp::resolver::query query(
             d_host, s_port, boost::asio::ip::resolver_query_base::passive);
diff -uNrp a/gr-blocks/lib/vector_source_impl.cc b/gr-blocks/lib/vector_source_impl.cc
--- a/gr-blocks/lib/vector_source_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/lib/vector_source_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -57,7 +57,7 @@ vector_source_impl<T>::vector_source_imp
       d_vlen(vlen),
       d_tags(tags)
 {
-    if (tags.size() == 0) {
+    if (tags.empty()) {
         d_settags = 0;
     } else {
         d_settags = 1;
@@ -79,7 +79,7 @@ void vector_source_impl<T>::set_data(con
     d_data = data;
     d_tags = tags;
     rewind();
-    if (tags.size() == 0) {
+    if (tags.empty()) {
         d_settags = false;
     } else {
         d_settags = true;
diff -uNrp a/gr-blocks/python/blocks/qa_python_message_passing.py b/gr-blocks/python/blocks/qa_python_message_passing.py
--- a/gr-blocks/python/blocks/qa_python_message_passing.py	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-blocks/python/blocks/qa_python_message_passing.py	2019-10-20 04:31:39.000000000 +0700
@@ -103,13 +103,7 @@ class test_python_message_passing(gr_uni
         self.assertEqual('in_port' in pmt.to_python(msg_cons.message_ports_in()), True)
 
         # Run to verify message passing
-        self.tb.start()
-
-        # Wait for all messages to be sent
-        while msg_gen.msg_ctr < num_msgs:
-            time.sleep(0.5)
-        self.tb.stop()
-        self.tb.wait()
+        self.tb.run()
 
         # Verify that the message consumer got all the messages
         self.assertEqual(num_msgs, len(msg_cons.msg_list))
diff -uNrp a/gr-digital/lib/burst_shaper_impl.cc b/gr-digital/lib/burst_shaper_impl.cc
--- a/gr-digital/lib/burst_shaper_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-digital/lib/burst_shaper_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2015,2018 Free Software Foundation, Inc.
+ * Copyright 2015,2018,2019 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -28,6 +28,7 @@
 #include <gnuradio/io_signature.h>
 #include <volk/volk.h>
 #include <boost/format.hpp>
+#include <algorithm>
 
 namespace gr {
 namespace digital {
@@ -220,7 +221,7 @@ template <class T>
 void burst_shaper_impl<T>::write_padding(T*& dst, int& nwritten, int nspace)
 {
     int nprocess = std::min(d_limit - d_index, nspace);
-    std::memset(dst, 0x00, nprocess * sizeof(T));
+    std::fill_n(dst, nprocess, 0x00);
     dst += nprocess;
     nwritten += nprocess;
     d_index += nprocess;
diff -uNrp a/gr-digital/lib/constellation.cc b/gr-digital/lib/constellation.cc
--- a/gr-digital/lib/constellation.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-digital/lib/constellation.cc	2019-10-20 04:31:39.000000000 +0700
@@ -69,7 +69,7 @@ constellation::constellation(std::vector
             d_constellation[i] = d_constellation[i] * d_scalefactor;
         }
     }
-    if (pre_diff_code.size() == 0)
+    if (pre_diff_code.empty())
         d_apply_pre_diff_code = false;
     else if (pre_diff_code.size() != constsize)
         throw std::runtime_error(
@@ -307,7 +307,7 @@ void constellation::set_soft_dec_lut(con
     d_lut_scale = powf(2.0, static_cast<float>(precision));
 }
 
-bool constellation::has_soft_dec_lut() { return d_soft_dec_lut.size() > 0; }
+bool constellation::has_soft_dec_lut() { return !d_soft_dec_lut.empty(); }
 
 std::vector<std::vector<float>> constellation::soft_dec_lut() { return d_soft_dec_lut; }
 
diff -uNrp a/gr-digital/lib/costas_loop_cc_impl.cc b/gr-digital/lib/costas_loop_cc_impl.cc
--- a/gr-digital/lib/costas_loop_cc_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-digital/lib/costas_loop_cc_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -180,7 +180,7 @@ int costas_loop_cc_impl::work(int noutpu
                       pmt::intern("phase_est"));
 
     for (int i = 0; i < noutput_items; i++) {
-        if (tags.size() > 0) {
+        if (!tags.empty()) {
             if (tags[0].offset - nitems_read(0) == (size_t)i) {
                 d_phase = (float)pmt::to_double(tags[0].value);
                 tags.erase(tags.begin());
diff -uNrp a/gr-digital/lib/fll_band_edge_cc_impl.cc b/gr-digital/lib/fll_band_edge_cc_impl.cc
--- a/gr-digital/lib/fll_band_edge_cc_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-digital/lib/fll_band_edge_cc_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -226,7 +226,6 @@ int fll_band_edge_cc_impl::work(int nout
     float error;
     gr_complex nco_out;
     gr_complex out_upper, out_lower;
-    gr_complex out_uppersse, out_lowersse;
 
     for (i = 0; i < noutput_items; i++) {
         nco_out = gr_expj(d_phase);
diff -uNrp a/gr-digital/lib/hdlc_framer_pb_impl.cc b/gr-digital/lib/hdlc_framer_pb_impl.cc
--- a/gr-digital/lib/hdlc_framer_pb_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-digital/lib/hdlc_framer_pb_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -114,7 +114,7 @@ int hdlc_framer_pb_impl::work(int noutpu
     // partial packets., but if we're to preserve tag boundaries
     // this is much, much simpler.
     int oidx = 0;
-    while (d_leftovers.size() > 0) {
+    while (!d_leftovers.empty()) {
         if ((size_t)noutput_items < (oidx + d_leftovers[0].size()))
             return oidx;
         memcpy(out + oidx, &d_leftovers[0][0], d_leftovers[0].size());
diff -uNrp a/gr-digital/lib/msk_timing_recovery_cc_impl.cc b/gr-digital/lib/msk_timing_recovery_cc_impl.cc
--- a/gr-digital/lib/msk_timing_recovery_cc_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-digital/lib/msk_timing_recovery_cc_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -133,7 +133,7 @@ int msk_timing_recovery_cc_impl::general
 
     while (oidx < noutput_items && iidx < ninp) {
         // check to see if there's a tag to reset the timing estimate
-        if (tags.size() > 0) {
+        if (!tags.empty()) {
             int offset = tags[0].offset - nitems_read(0);
             if ((offset >= iidx) && (offset < (iidx + d_sps))) {
                 float center = (float)pmt::to_double(tags[0].value);
diff -uNrp a/gr-digital/lib/ofdm_chanest_vcvc_impl.cc b/gr-digital/lib/ofdm_chanest_vcvc_impl.cc
--- a/gr-digital/lib/ofdm_chanest_vcvc_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-digital/lib/ofdm_chanest_vcvc_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -60,8 +60,8 @@ ofdm_chanest_vcvc_impl::ofdm_chanest_vcv
       d_n_data_syms(n_data_symbols),
       d_n_sync_syms(1),
       d_eq_noise_red_len(eq_noise_red_len),
-      d_ref_sym((sync_symbol2.size() && !force_one_sync_symbol) ? sync_symbol2
-                                                                : sync_symbol1),
+      d_ref_sym((!sync_symbol2.empty() && !force_one_sync_symbol) ? sync_symbol2
+                                                                  : sync_symbol1),
       d_corr_v(sync_symbol2),
       d_known_symbol_diffs(0, 0),
       d_new_symbol_diffs(0, 0),
@@ -84,7 +84,7 @@ ofdm_chanest_vcvc_impl::ofdm_chanest_vcv
     }
 
     // Sanity checks
-    if (sync_symbol2.size()) {
+    if (!sync_symbol2.empty()) {
         if (sync_symbol1.size() != sync_symbol2.size()) {
             throw std::invalid_argument("sync symbols must have equal length.");
         }
@@ -149,7 +149,7 @@ int ofdm_chanest_vcvc_impl::get_carr_off
                                             const gr_complex* sync_sym2)
 {
     int carr_offset = 0;
-    if (d_corr_v.size()) {
+    if (!d_corr_v.empty()) {
         // Use Schmidl & Cox method
         float Bg_max = 0;
         // g here is 2g in the paper
diff -uNrp a/gr-digital/lib/ofdm_equalizer_base.cc b/gr-digital/lib/ofdm_equalizer_base.cc
--- a/gr-digital/lib/ofdm_equalizer_base.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-digital/lib/ofdm_equalizer_base.cc	2019-10-20 04:31:39.000000000 +0700
@@ -57,7 +57,7 @@ ofdm_equalizer_1d_pilots::ofdm_equalizer
     if (input_is_shifted) {
         fft_shift_width = fft_len / 2;
     }
-    if (!occupied_carriers.size()) {
+    if (occupied_carriers.empty()) {
         std::fill(d_occupied_carriers.begin(), d_occupied_carriers.end(), true);
     } else {
         for (unsigned i = 0; i < occupied_carriers.size(); i++) {
@@ -73,7 +73,7 @@ ofdm_equalizer_1d_pilots::ofdm_equalizer
             }
         }
     }
-    if (pilot_carriers.size()) {
+    if (!pilot_carriers.empty()) {
         for (unsigned i = 0; i < pilot_carriers.size(); i++) {
             if (pilot_carriers[i].size() != pilot_symbols[i].size()) {
                 throw std::invalid_argument("pilot carriers and -symbols do not match.");
diff -uNrp a/gr-digital/lib/pfb_clock_sync_ccf_impl.cc b/gr-digital/lib/pfb_clock_sync_ccf_impl.cc
--- a/gr-digital/lib/pfb_clock_sync_ccf_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-digital/lib/pfb_clock_sync_ccf_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -68,7 +68,7 @@ pfb_clock_sync_ccf_impl::pfb_clock_sync_
       d_error(0),
       d_out_idx(0)
 {
-    if (taps.size() == 0)
+    if (taps.empty())
         throw std::runtime_error("pfb_clock_sync_ccf: please specify a filter.\n");
 
     // Let scheduler adjust our relative_rate.
@@ -382,7 +382,7 @@ int pfb_clock_sync_ccf_impl::general_wor
 
     // produce output as long as we can and there are enough input samples
     while (i < noutput_items) {
-        if (tags.size() > 0) {
+        if (!tags.empty()) {
             size_t offset = tags[0].offset - nitems_read(0);
             if ((offset >= (size_t)count) && (offset < (size_t)(count + d_sps))) {
                 float center = (float)pmt::to_double(tags[0].value);
diff -uNrp a/gr-digital/lib/pfb_clock_sync_fff_impl.cc b/gr-digital/lib/pfb_clock_sync_fff_impl.cc
--- a/gr-digital/lib/pfb_clock_sync_fff_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-digital/lib/pfb_clock_sync_fff_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -65,7 +65,7 @@ pfb_clock_sync_fff_impl::pfb_clock_sync_
       d_error(0),
       d_out_idx(0)
 {
-    if (taps.size() == 0)
+    if (taps.empty())
         throw std::runtime_error("pfb_clock_sync_fff: please specify a filter.\n");
 
     // Let scheduler adjust our relative_rate.
diff -uNrp a/gr-digital/lib/timing_error_detector.cc b/gr-digital/lib/timing_error_detector.cc
--- a/gr-digital/lib/timing_error_detector.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-digital/lib/timing_error_detector.cc	2019-10-20 04:31:39.000000000 +0700
@@ -232,11 +232,9 @@ void timing_error_detector::sync_reset()
     d_input_derivative.assign(d_error_depth, gr_complex(0.0f, 0.0f));
 
     if (d_constellation) {
-        std::deque<gr_complex>::iterator it;
-        d_decision.clear();
-        for (it = d_input.begin(); it != d_input.end(); ++it)
-            d_decision.push_back(gr_complex(0.0f, 0.0f));
-        // d_decision.push_back(slice(*it));
+        d_decision.assign(d_input.size(), gr_complex(0.0f, 0.0f));
+        // for (it = d_input.begin(); it != d_input.end(); ++it)
+        //   d_decision.push_back(slice(*it));
     }
 
     sync_reset_input_clock();
diff -uNrp a/gr-dtv/lib/atsc/atsc_field_sync_mux_impl.cc b/gr-dtv/lib/atsc/atsc_field_sync_mux_impl.cc
--- a/gr-dtv/lib/atsc/atsc_field_sync_mux_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-dtv/lib/atsc/atsc_field_sync_mux_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -29,8 +29,6 @@
 namespace gr {
 namespace dtv {
 
-static const int N_SAVED_SYMBOLS = 12;
-
 atsc_field_sync_mux::sptr atsc_field_sync_mux::make()
 {
     return gnuradio::get_initial_sptr(new atsc_field_sync_mux_impl());
diff -uNrp a/gr-dtv/lib/atsc/atsc_trellis_encoder_impl.cc b/gr-dtv/lib/atsc/atsc_trellis_encoder_impl.cc
--- a/gr-dtv/lib/atsc/atsc_trellis_encoder_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-dtv/lib/atsc/atsc_trellis_encoder_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -34,9 +34,6 @@ static const int DIBITS_PER_BYTE = 4;
 #define SEGOF(x) ((x) / ((SEGMENT_SIZE + 1) * DIBITS_PER_BYTE))
 #define SYMOF(x) (((x) % ((SEGMENT_SIZE + 1) * DIBITS_PER_BYTE)) - 4)
 
-/* How many separate Trellis encoders / Viterbi decoders run in parallel */
-static const int NCODERS = 12;
-
 #define ENCODER_SEG_BUMP 4
 
 /* A Segment sync symbol is an 8VSB +5,-5,-5,+5 sequence that occurs at
@@ -83,7 +80,7 @@ void atsc_trellis_encoder_impl::encode(a
     assert(sizeof(in_copy) == sizeof(in[0].data) * NCODERS);
     assert(sizeof(out_copy) == sizeof(out[0].data) * NCODERS);
 
-    // copy input into continguous temporary buffer
+    // copy input into contiguous temporary buffer
     for (int i = 0; i < NCODERS; i++) {
         assert(in[i].pli.regular_seg_p());
         plinfo::sanity_check(in[i].pli);
@@ -112,7 +109,7 @@ void atsc_trellis_encoder_impl::encode(a
 }
 
 /*
- * This code expects contiguous arrrays. Use it as is, it computes
+ * This code expects contiguous arrays. Use it as is, it computes
  * the correct answer. Maybe someday, when we've run out of better
  * things to do, rework to avoid the copying in encode.
  */
diff -uNrp a/gr-dtv/lib/atsc/atsc_trellis_encoder_impl.h b/gr-dtv/lib/atsc/atsc_trellis_encoder_impl.h
--- a/gr-dtv/lib/atsc/atsc_trellis_encoder_impl.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-dtv/lib/atsc/atsc_trellis_encoder_impl.h	2019-10-20 04:31:39.000000000 +0700
@@ -33,6 +33,7 @@ class atsc_trellis_encoder_impl : public
 private:
     bool debug;
 
+    /* How many separate Trellis encoders / Viterbi decoders run in parallel */
     static const int NCODERS = 12;
     static const int SEGMENT_SIZE = ATSC_MPEG_RS_ENCODED_LENGTH;
     static const int INPUT_SIZE = (SEGMENT_SIZE * 12);
diff -uNrp a/gr-dtv/lib/dvbt/dvbt_convolutional_deinterleaver_impl.cc b/gr-dtv/lib/dvbt/dvbt_convolutional_deinterleaver_impl.cc
--- a/gr-dtv/lib/dvbt/dvbt_convolutional_deinterleaver_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-dtv/lib/dvbt/dvbt_convolutional_deinterleaver_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -110,7 +110,7 @@ int dvbt_convolutional_deinterleaver_imp
                             nread + (noutput_items * d_I * d_blocks),
                             pmt::string_to_symbol("superframe_start"));
 
-    if (tags.size()) {
+    if (!tags.empty()) {
         if (tags[0].offset - nread) {
             consume_each(tags[0].offset - nread);
             return (0);
diff -uNrp a/gr-dtv/lib/dvbt/dvbt_demod_reference_signals_impl.cc b/gr-dtv/lib/dvbt/dvbt_demod_reference_signals_impl.cc
--- a/gr-dtv/lib/dvbt/dvbt_demod_reference_signals_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-dtv/lib/dvbt/dvbt_demod_reference_signals_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -116,7 +116,7 @@ int dvbt_demod_reference_signals_impl::i
     this->get_tags_in_range(
         tags, 0, nread, nread + nitems, pmt::string_to_symbol("sync_start"));
 
-    return tags.size() ? 1 : 0;
+    return !tags.empty() ? 1 : 0;
 }
 
 int dvbt_demod_reference_signals_impl::general_work(
diff -uNrp a/gr-dtv/lib/dvbt/dvbt_ofdm_sym_acquisition_impl.cc b/gr-dtv/lib/dvbt/dvbt_ofdm_sym_acquisition_impl.cc
--- a/gr-dtv/lib/dvbt/dvbt_ofdm_sym_acquisition_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-dtv/lib/dvbt/dvbt_ofdm_sym_acquisition_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -409,7 +409,7 @@ int dvbt_ofdm_sym_acquisition_impl::gene
             send_sync_start();
             d_initial_acquisition = 0;
 
-            // Restart wit a half number so that we'll not end up with the same situation
+            // Restart with a half number so that we'll not end up with the same situation
             // This will prevent peak_detect to not detect anything
             d_to_consume = d_to_consume / 2;
             d_consumed += d_to_consume;
diff -uNrp a/gr-dtv/lib/dvbt/dvbt_reference_signals_impl.h b/gr-dtv/lib/dvbt/dvbt_reference_signals_impl.h
--- a/gr-dtv/lib/dvbt/dvbt_reference_signals_impl.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-dtv/lib/dvbt/dvbt_reference_signals_impl.h	2019-10-20 04:31:39.000000000 +0700
@@ -218,7 +218,7 @@ public:
      * TODO
      * ETSI EN 300 744 Clause 4.5. \n
      * Extract data from a set of carriers using pilot signals. \n
-     * This is doing frequency correcton, equalization. \n
+     * This is doing frequency correction, equalization. \n
      */
     int parse_input(const gr_complex* in,
                     gr_complex* out,
diff -uNrp a/gr-dtv/lib/dvbt/dvbt_viterbi_decoder_impl.cc b/gr-dtv/lib/dvbt/dvbt_viterbi_decoder_impl.cc
--- a/gr-dtv/lib/dvbt/dvbt_viterbi_decoder_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-dtv/lib/dvbt/dvbt_viterbi_decoder_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -644,7 +644,7 @@ int dvbt_viterbi_decoder_impl::general_w
                                 nread + (nblocks * d_nsymbols),
                                 pmt::string_to_symbol("superframe_start"));
 
-        if (tags.size()) {
+        if (!tags.empty()) {
             d_init = 0;
 
 #ifdef DTV_SSE2
diff -uNrp a/gr-fec/lib/conv_bit_corr_bb_impl.h b/gr-fec/lib/conv_bit_corr_bb_impl.h
--- a/gr-fec/lib/conv_bit_corr_bb_impl.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-fec/lib/conv_bit_corr_bb_impl.h	2019-10-20 04:31:39.000000000 +0700
@@ -64,7 +64,7 @@ private:
     std::vector<int> get_corr()
     {
         std::vector<int> bits;
-        if (d_correlator.size() < 1) {
+        if (d_correlator.empty()) {
             return bits;
         }
         for (size_t i = 0; i < d_correlator[0].size(); i++) {
diff -uNrp a/gr-fec/lib/generic_decoder.cc b/gr-fec/lib/generic_decoder.cc
--- a/gr-fec/lib/generic_decoder.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-fec/lib/generic_decoder.cc	2019-10-20 04:31:39.000000000 +0700
@@ -45,7 +45,7 @@ generic_decoder::generic_decoder(std::st
 
     GR_LOG_GETLOGGER(LOG, "gr_log." + alias());
     GR_LOG_SET_LEVEL(LOG, log_level);
-    if (log_file.size() > 0) {
+    if (!log_file.empty()) {
         if (log_file == "stdout") {
             GR_LOG_SET_CONSOLE_APPENDER(LOG, "stdout", "gr::log :%p: %c{1} - %m%n");
         } else if (log_file == "stderr") {
diff -uNrp a/gr-fec/lib/generic_encoder.cc b/gr-fec/lib/generic_encoder.cc
--- a/gr-fec/lib/generic_encoder.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-fec/lib/generic_encoder.cc	2019-10-20 04:31:39.000000000 +0700
@@ -45,7 +45,7 @@ generic_encoder::generic_encoder(std::st
 
     GR_LOG_GETLOGGER(LOG, "gr_log." + alias());
     GR_LOG_SET_LEVEL(LOG, log_level);
-    if (log_file.size() > 0) {
+    if (!log_file.empty()) {
         if (log_file == "stdout") {
             GR_LOG_SET_CONSOLE_APPENDER(LOG, "stdout", "gr::log :%p: %c{1} - %m%n");
         } else if (log_file == "stderr") {
diff -uNrp a/gr-fec/lib/tpc_decoder.cc b/gr-fec/lib/tpc_decoder.cc
--- a/gr-fec/lib/tpc_decoder.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-fec/lib/tpc_decoder.cc	2019-10-20 04:31:39.000000000 +0700
@@ -703,7 +703,7 @@ float tpc_decoder::constant_log_map(cons
 {
     // Return maximum of delta1 and delta2
     // and in correction value if |delta1-delta2| < TVALUE
-    register float diff;
+    float diff;
     diff = delta2 - delta1;
 
     if (diff > TVALUE)
diff -uNrp a/gr-fft/include/gnuradio/fft/fft_vcc.h b/gr-fft/include/gnuradio/fft/fft_vcc.h
--- a/gr-fft/include/gnuradio/fft/fft_vcc.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-fft/include/gnuradio/fft/fft_vcc.h	2019-10-20 04:31:39.000000000 +0700
@@ -51,7 +51,7 @@ namespace fft {
  * \f$N-1\f$.
  *
  * \b Note, that due to the underlying FFTW library, the output of a FFT
- * followed by an IFFT (or the other way arround) will be scaled i.e.
+ * followed by an IFFT (or the other way around) will be scaled i.e.
  * \f$FFT\{ \, IFFT\{x\} \,\} =  N \cdot x \neq x\f$.
  *
  * \see http://www.fftw.org/faq/section3.html#whyscaled
diff -uNrp a/gr-fft/include/gnuradio/fft/fft_vfc.h b/gr-fft/include/gnuradio/fft/fft_vfc.h
--- a/gr-fft/include/gnuradio/fft/fft_vfc.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-fft/include/gnuradio/fft/fft_vfc.h	2019-10-20 04:31:39.000000000 +0700
@@ -51,7 +51,7 @@ namespace fft {
  * \f$N-1\f$.
  *
  * \b Note, that due to the underlying FFTW library, the output of a FFT
- * followed by an IFFT (or the other way arround) will be scaled i.e.
+ * followed by an IFFT (or the other way around) will be scaled i.e.
  * \f$FFT\{ \, IFFT\{x\} \,\} =  N \cdot x \neq x\f$.
  *
  * \see http://www.fftw.org/faq/section3.html#whyscaled
diff -uNrp a/gr-fft/include/gnuradio/fft/window.h b/gr-fft/include/gnuradio/fft/window.h
--- a/gr-fft/include/gnuradio/fft/window.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-fft/include/gnuradio/fft/window.h	2019-10-20 04:31:39.000000000 +0700
@@ -177,7 +177,7 @@ public:
     static std::vector<float> blackman_harris(int ntaps, int atten = 92);
 
     /*!
-     * Alias to gr::fft::window::blakcman_harris.
+     * Alias to gr::fft::window::blackman_harris.
      */
     static std::vector<float> blackmanharris(int ntaps, int atten = 92);
 
diff -uNrp a/gr-fft/lib/ctrlport_probe_psd_impl.cc b/gr-fft/lib/ctrlport_probe_psd_impl.cc
--- a/gr-fft/lib/ctrlport_probe_psd_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-fft/lib/ctrlport_probe_psd_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -137,7 +137,7 @@ void ctrlport_probe_psd_impl::setup_rpc(
 {
 #ifdef GR_CTRLPORT
     int len = static_cast<int>(d_len);
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe_psd, std::vector<std::complex<float>>>(
             alias(),
             d_id.c_str(),
@@ -148,9 +148,9 @@ void ctrlport_probe_psd_impl::setup_rpc(
             "dB",
             d_desc.c_str(),
             RPC_PRIVLVL_MIN,
-            DISPXY | DISPOPTSCATTER)));
+            DISPXY | DISPOPTSCATTER));
 
-    d_rpc_vars.push_back(rpcbasic_sptr(
+    d_rpc_vars.emplace_back(
         new rpcbasic_register_get<ctrlport_probe_psd, int>(alias(),
                                                            "length",
                                                            &ctrlport_probe_psd::length,
@@ -160,13 +160,13 @@ void ctrlport_probe_psd_impl::setup_rpc(
                                                            "samples",
                                                            "get vector length",
                                                            RPC_PRIVLVL_MIN,
-                                                           DISPNULL)));
+                                                           DISPNULL));
 
-//      d_rpc_vars.push_back(
-//        rpcbasic_sptr(new rpcbasic_register_set<ctrlport_probe_psd, int>(
+//      d_rpc_vars.emplace_back(
+//        new rpcbasic_register_set<ctrlport_probe_psd, int>(
 //          alias(), "length", &ctrlport_probe_psd::set_length,
 //          pmt::mp(1), pmt::mp(10*len), pmt::mp(len),
-//          "samples", "set vector length", RPC_PRIVLVL_MIN, DISPNULL)));
+//          "samples", "set vector length", RPC_PRIVLVL_MIN, DISPNULL));
 #endif /* GR_CTRLPORT */
 }
 
diff -uNrp a/gr-fft/lib/fft_vcc_fftw.cc b/gr-fft/lib/fft_vcc_fftw.cc
--- a/gr-fft/lib/fft_vcc_fftw.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-fft/lib/fft_vcc_fftw.cc	2019-10-20 04:31:39.000000000 +0700
@@ -67,7 +67,7 @@ int fft_vcc_fftw::nthreads() const { ret
 
 bool fft_vcc_fftw::set_window(const std::vector<float>& window)
 {
-    if (window.size() == 0 || window.size() == d_fft_size) {
+    if (window.empty() || window.size() == d_fft_size) {
         d_window = window;
         return true;
     } else
@@ -89,7 +89,7 @@ int fft_vcc_fftw::work(int noutput_items
     while (count++ < noutput_items) {
 
         // copy input into optimally aligned buffer
-        if (d_window.size()) {
+        if (!d_window.empty()) {
             gr_complex* dst = d_fft->get_inbuf();
             if (!d_forward && d_shift) {
                 unsigned int offset = (!d_forward && d_shift) ? (d_fft_size / 2) : 0;
diff -uNrp a/gr-fft/lib/fft_vfc_fftw.cc b/gr-fft/lib/fft_vfc_fftw.cc
--- a/gr-fft/lib/fft_vfc_fftw.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-fft/lib/fft_vfc_fftw.cc	2019-10-20 04:31:39.000000000 +0700
@@ -62,7 +62,7 @@ int fft_vfc_fftw::nthreads() const { ret
 
 bool fft_vfc_fftw::set_window(const std::vector<float>& window)
 {
-    if (window.size() == 0 || window.size() == d_fft_size) {
+    if (window.empty() || window.size() == d_fft_size) {
         d_window = window;
         return true;
     } else
@@ -83,7 +83,7 @@ int fft_vfc_fftw::work(int noutput_items
     while (count++ < noutput_items) {
 
         // copy input into optimally aligned buffer
-        if (d_window.size()) {
+        if (!d_window.empty()) {
             gr_complex* dst = d_fft->get_inbuf();
             for (unsigned int i = 0; i < d_fft_size; i++) // apply window
                 dst[i] = in[i] * d_window[i];
diff -uNrp a/gr-filter/grc/filter_pfb_channelizer.block.yml b/gr-filter/grc/filter_pfb_channelizer.block.yml
--- a/gr-filter/grc/filter_pfb_channelizer.block.yml	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-filter/grc/filter_pfb_channelizer.block.yml	2019-10-20 04:31:39.000000000 +0700
@@ -53,7 +53,8 @@ templates:
             ${taps},
             ${osr},
             ${atten})
-        self.${id}.set_channel_map(${ch_map})\nself.${id}.declare_sample_delay(${samp_delay})
+        self.${id}.set_channel_map(${ch_map})
+        self.${id}.declare_sample_delay(${samp_delay})
     callbacks:
     - set_taps(${taps})
     - set_channel_map(${ch_map})
diff -uNrp a/gr-filter/lib/fft_filter.cc b/gr-filter/lib/fft_filter.cc
--- a/gr-filter/lib/fft_filter.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-filter/lib/fft_filter.cc	2019-10-20 04:31:39.000000000 +0700
@@ -168,7 +168,7 @@ int fft_filter_fff::filter(int nitems, c
         dec_ctr = (j - d_nsamples);
 
         // stash the tail
-        if (d_tail.size()) {
+        if (!d_tail.empty()) {
             memcpy(&d_tail[0],
                    d_invfft->get_outbuf() + d_nsamples,
                    tailsize() * sizeof(float));
@@ -315,7 +315,7 @@ int fft_filter_ccc::filter(int nitems, c
         dec_ctr = (j - d_nsamples);
 
         // stash the tail
-        if (d_tail.size()) {
+        if (!d_tail.empty()) {
             memcpy(&d_tail[0],
                    d_invfft->get_outbuf() + d_nsamples,
                    tailsize() * sizeof(gr_complex));
@@ -464,7 +464,7 @@ int fft_filter_ccf::filter(int nitems, c
         dec_ctr = (j - d_nsamples);
 
         // stash the tail
-        if (d_tail.size()) {
+        if (!d_tail.empty()) {
             memcpy(&d_tail[0],
                    d_invfft->get_outbuf() + d_nsamples,
                    tailsize() * sizeof(gr_complex));
diff -uNrp a/gr-filter/lib/fir_filter.cc b/gr-filter/lib/fir_filter.cc
--- a/gr-filter/lib/fir_filter.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-filter/lib/fir_filter.cc	2019-10-20 04:31:39.000000000 +0700
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2004,2010,2012,2018 Free Software Foundation, Inc.
+ * Copyright 2004,2010,2012,2018,2019 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -80,7 +80,7 @@ void fir_filter<IN_T, OUT_T, TAP_T>::set
     for (int i = 0; i < d_naligned; i++) {
         d_aligned_taps[i] =
             (TAP_T*)volk_malloc((d_ntaps + d_naligned - 1) * sizeof(TAP_T), d_align);
-        memset(d_aligned_taps[i], 0, sizeof(TAP_T) * (d_ntaps + d_naligned - 1));
+        std::fill_n(d_aligned_taps[i], d_ntaps + d_naligned - 1, 0);
         for (unsigned int j = 0; j < d_ntaps; j++)
             d_aligned_taps[i][i + j] = d_taps[j];
     }
diff -uNrp a/gr-filter/lib/fir_filter_with_buffer.cc b/gr-filter/lib/fir_filter_with_buffer.cc
--- a/gr-filter/lib/fir_filter_with_buffer.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-filter/lib/fir_filter_with_buffer.cc	2019-10-20 04:31:39.000000000 +0700
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2010,2012 Free Software Foundation, Inc.
+ * Copyright 2010,2012,2019 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -242,7 +242,7 @@ void fir_filter_with_buffer_ccc::set_tap
     // allocated space.
     d_buffer_ptr = (gr_complex*)volk_malloc(
         (2 * (d_ntaps + d_naligned)) * sizeof(gr_complex), d_align);
-    memset(d_buffer_ptr, 0, 2 * (d_ntaps + d_naligned) * sizeof(gr_complex));
+    std::fill_n(d_buffer_ptr, 2 * (d_ntaps + d_naligned), 0);
     d_buffer = d_buffer_ptr + d_naligned;
 
     // Allocate aligned taps
@@ -250,7 +250,7 @@ void fir_filter_with_buffer_ccc::set_tap
     for (int i = 0; i < d_naligned; i++) {
         d_aligned_taps[i] = (gr_complex*)volk_malloc(
             (d_ntaps + d_naligned - 1) * sizeof(gr_complex), d_align);
-        memset(d_aligned_taps[i], 0, sizeof(gr_complex) * (d_ntaps + d_naligned - 1));
+        std::fill_n(d_aligned_taps[i], d_ntaps + d_naligned - 1, 0);
         for (unsigned int j = 0; j < d_ntaps; j++)
             d_aligned_taps[i][i + j] = d_taps[j];
     }
@@ -386,7 +386,7 @@ void fir_filter_with_buffer_ccf::set_tap
     // allocated space.
     d_buffer_ptr = (gr_complex*)volk_malloc(
         (2 * (d_ntaps + d_naligned)) * sizeof(gr_complex), d_align);
-    memset(d_buffer_ptr, 0, 2 * (d_ntaps + d_naligned) * sizeof(gr_complex));
+    std::fill_n(d_buffer_ptr, 2 * (d_ntaps + d_naligned), 0);
     d_buffer = d_buffer_ptr + d_naligned;
 
     // Allocate aligned taps
diff -uNrp a/gr-filter/lib/interp_fir_filter_impl.cc b/gr-filter/lib/interp_fir_filter_impl.cc
--- a/gr-filter/lib/interp_fir_filter_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-filter/lib/interp_fir_filter_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -55,7 +55,7 @@ interp_fir_filter_impl<IN_T, OUT_T, TAP_
         throw std::out_of_range("interp_fir_filter_impl: interpolation must be > 0\n");
     }
 
-    if (taps.size() == 0) {
+    if (taps.empty()) {
         throw std::runtime_error("interp_fir_filter_impl: no filter taps provided.\n");
     }
 
diff -uNrp a/gr-filter/lib/pfb_channelizer_ccf_impl.cc b/gr-filter/lib/pfb_channelizer_ccf_impl.cc
--- a/gr-filter/lib/pfb_channelizer_ccf_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-filter/lib/pfb_channelizer_ccf_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -125,7 +125,7 @@ void pfb_channelizer_ccf_impl::set_chann
 {
     gr::thread::scoped_lock guard(d_mutex);
 
-    if (map.size() > 0) {
+    if (!map.empty()) {
         unsigned int max = (unsigned int)*std::max_element(map.begin(), map.end());
         if (max >= d_nfilts) {
             throw std::invalid_argument(
diff -uNrp a/gr-filter/lib/pfb_synthesizer_ccf_impl.cc b/gr-filter/lib/pfb_synthesizer_ccf_impl.cc
--- a/gr-filter/lib/pfb_synthesizer_ccf_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-filter/lib/pfb_synthesizer_ccf_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2010,2012,2014 Free Software Foundation, Inc.
+ * Copyright 2010,2012,2014,2019 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -27,6 +27,7 @@
 #include "pfb_synthesizer_ccf_impl.h"
 #include <gnuradio/io_signature.h>
 #include <cstdio>
+#include <algorithm>
 
 namespace gr {
 namespace filter {
@@ -72,7 +73,7 @@ pfb_synthesizer_ccf_impl::pfb_synthesize
 
     // Create the IFFT to handle the input channel rotations
     d_fft = new fft::fft_complex(d_twox * d_numchans, false);
-    memset(d_fft->get_inbuf(), 0, d_twox * d_numchans * sizeof(gr_complex));
+    std::fill_n(d_fft->get_inbuf(), d_twox * d_numchans, 0);
 
     set_output_multiple(d_numchans);
 }
@@ -213,7 +214,7 @@ void pfb_synthesizer_ccf_impl::set_chann
 {
     gr::thread::scoped_lock guard(d_mutex);
 
-    if (map.size() > 0) {
+    if (!map.empty()) {
         int max = *std::max_element(map.begin(), map.end());
         int min = *std::min_element(map.begin(), map.end());
         if ((max >= static_cast<int>(d_twox * d_numchans)) || (min < 0)) {
@@ -223,7 +224,7 @@ void pfb_synthesizer_ccf_impl::set_chann
         d_channel_map = map;
 
         // Zero out fft buffer so that unused channels are always 0
-        memset(d_fft->get_inbuf(), 0, d_twox * d_numchans * sizeof(gr_complex));
+        std::fill_n(d_fft->get_inbuf(), d_twox * d_numchans, 0);
     }
 }
 
diff -uNrp a/gr-filter/lib/pm_remez.cc b/gr-filter/lib/pm_remez.cc
--- a/gr-filter/lib/pm_remez.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-filter/lib/pm_remez.cc	2019-10-20 04:31:39.000000000 +0700
@@ -821,7 +821,7 @@ std::vector<double> pm_remez(int order,
     for (int i = 0; i < numbands; i++)
         weight[i] = 1.0;
 
-    if (arg_weight.size() != 0) {
+    if (!arg_weight.empty()) {
         if ((int)arg_weight.size() != numbands)
             punt("gr_remez: need one weight for each band [=length(band)/2]");
         for (int i = 0; i < numbands; i++)
diff -uNrp a/gr-filter/lib/qa_fir_filter_with_buffer.cc b/gr-filter/lib/qa_fir_filter_with_buffer.cc
--- a/gr-filter/lib/qa_fir_filter_with_buffer.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-filter/lib/qa_fir_filter_with_buffer.cc	2019-10-20 04:31:39.000000000 +0700
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2010,2012 Free Software Foundation, Inc.
+ * Copyright 2010,2012,2019 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -32,6 +32,7 @@
 #include <boost/test/unit_test.hpp>
 #include <cmath>
 #include <cstring>
+#include <algorithm>
 
 using std::vector;
 
@@ -201,7 +202,7 @@ void test_decimate(unsigned int decimate
         (gr_complex*)volk_malloc(OUTPUT_LEN * sizeof(gr_complex), align);
     tap_type* taps = (gr_complex*)volk_malloc(MAX_TAPS * sizeof(gr_complex), align);
 
-    memset(dline, 0, INPUT_LEN * sizeof(i_type));
+    std::fill_n(dline, INPUT_LEN, 0);
 
     for (int n = 0; n <= MAX_TAPS; n++) {
         for (int ol = 0; ol <= OUTPUT_LEN; ol++) {
@@ -211,7 +212,7 @@ void test_decimate(unsigned int decimate
             random_complex(taps, MAX_TAPS);
 
             // compute expected output values
-            memset(dline, 0, INPUT_LEN * sizeof(i_type));
+            std::fill_n(dline, INPUT_LEN, 0);
             for (int o = 0; o < (int)(ol / decimate); o++) {
                 // use an actual delay line for this test
                 for (int dd = 0; dd < (int)decimate; dd++) {
@@ -228,7 +229,7 @@ void test_decimate(unsigned int decimate
                 new kernel::fir_filter_with_buffer_ccc(f1_taps);
 
             // zero the output, then do the filtering
-            memset(actual_output, 0, OUTPUT_LEN * sizeof(o_type));
+            std::fill_n(actual_output, OUTPUT_LEN, 0);
             f1->filterNdec(actual_output, input, ol / decimate, decimate);
 
             // check results
@@ -302,7 +303,7 @@ void test_decimate(unsigned int decimate
         (gr_complex*)volk_malloc(OUTPUT_LEN * sizeof(gr_complex), align);
     tap_type* taps = (float*)volk_malloc(MAX_TAPS * sizeof(float), align);
 
-    memset(dline, 0, INPUT_LEN * sizeof(i_type));
+    std::fill_n(dline, INPUT_LEN, 0);
 
     for (int n = 0; n <= MAX_TAPS; n++) {
         for (int ol = 0; ol <= OUTPUT_LEN; ol++) {
@@ -312,7 +313,7 @@ void test_decimate(unsigned int decimate
             random_floats(taps, MAX_TAPS);
 
             // compute expected output values
-            memset(dline, 0, INPUT_LEN * sizeof(i_type));
+            std::fill_n(dline, INPUT_LEN, 0);
             for (int o = 0; o < (int)(ol / decimate); o++) {
                 // use an actual delay line for this test
                 for (int dd = 0; dd < (int)decimate; dd++) {
@@ -329,7 +330,7 @@ void test_decimate(unsigned int decimate
                 new kernel::fir_filter_with_buffer_ccf(f1_taps);
 
             // zero the output, then do the filtering
-            memset(actual_output, 0, OUTPUT_LEN * sizeof(gr_complex));
+            std::fill_n(actual_output, OUTPUT_LEN, 0);
             f1->filterNdec(actual_output, input, ol / decimate, decimate);
 
             // check results
diff -uNrp a/gr-filter/python/filter/design/filter_design.py b/gr-filter/python/filter/design/filter_design.py
--- a/gr-filter/python/filter/design/filter_design.py	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-filter/python/filter/design/filter_design.py	2019-10-20 04:31:39.000000000 +0700
@@ -33,16 +33,26 @@ from optparse import OptionParser
 from gnuradio import filter
 
 try:
-    import numpy
-    from numpy.fft import fftpack
-    from scipy import poly1d, signal
+    import numpy as np
 except ImportError:
-    raise SystemExit('Please install SciPy to run this script (https://www.scipy.org)')
+    raise SystemExit('Please install NumPy to run this script (https://www.np.org/)')
 
 try:
-    import numpy as np
+    from numpy.fft import fftpack as fft_detail
 except ImportError:
-    raise SystemExit('Please install NumPy to run this script (https://www.numpy.org/)')
+
+    print('Could not import fftpack, trying pocketfft')
+    # Numpy changed fft implementation in version 1.17
+    # from fftpack to pocketfft
+    try:
+        from numpy.fft import pocketfft as fft_detail
+    except ImportError:
+        raise SystemExit('Could not import fft implementation of numpy')
+    
+try:
+    from scipy import poly1d, signal
+except ImportError:
+    raise SystemExit('Please install SciPy to run this script (https://www.scipy.org)')
 
 try:
     from PyQt5 import Qt, QtCore, QtWidgets
@@ -950,10 +960,10 @@ class gr_plot_filter(QtGui.QMainWindow):
     def iir_plot_all(self,z,p,k):
         self.b,self.a = signal.zpk2tf(z,p,k)
         w,h = signal.freqz(self.b,self.a)
-        self.fftdB = 20 * numpy.log10 (abs(h))
+        self.fftdB = 20 * np.log10 (abs(h))
         self.freq = w / max(w)
-        self.fftDeg = numpy.unwrap(numpy.arctan2(numpy.imag(h),numpy.real(h)))
-        self.groupDelay = -numpy.diff(self.fftDeg)
+        self.fftDeg = np.unwrap(np.arctan2(np.imag(h),np.real(h)))
+        self.groupDelay = -np.diff(self.fftDeg)
         self.phaseDelay = -self.fftDeg[1:] / self.freq[1:]
         if self.gridview:
             self.set_mfmagresponse()
@@ -985,17 +995,17 @@ class gr_plot_filter(QtGui.QMainWindow):
 
     def get_fft(self, fs, taps, Npts):
         Ts = 1.0 / fs
-        fftpts = fftpack.fft(taps, Npts)
-        self.freq = numpy.arange(0, fs, 1.0 / (Npts*Ts))
+        fftpts = fft_detail.fft(taps, Npts)
+        self.freq = np.arange(0, fs, 1.0 / (Npts*Ts))
         with warnings.catch_warnings(record=True) as w:
             warnings.simplefilter("always")
-            self.fftdB = 20.0*numpy.log10(abs(fftpts))
+            self.fftdB = 20.0*np.log10(abs(fftpts))
             if any(self.fftdB == float('-inf')):
                 sys.stderr.write('Filter design failed (taking log10 of 0).\n')
-                self.fftdB = numpy.zeros([len(fftpts)])
+                self.fftdB = np.zeros([len(fftpts)])
 
-        self.fftDeg = numpy.unwrap(numpy.angle(fftpts))
-        self.groupDelay = -numpy.diff(self.fftDeg)
+        self.fftDeg = np.unwrap(np.angle(fftpts))
+        self.groupDelay = -np.diff(self.fftDeg)
         self.phaseDelay = -self.fftDeg[1:] / self.freq[1:]
 
     def update_time_curves(self):
@@ -1014,14 +1024,14 @@ class gr_plot_filter(QtGui.QMainWindow):
 
         if self.mttaps:
             if(type(self.taps[0]) == scipy.complex128):
-                self.mtimecurve_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+                self.mtimecurve_stems.setData(np.repeat(np.arange(ntaps), 2),
                                                 np.dstack((np.zeros(self.taps.real.shape[0], dtype=int),
                                                         self.taps.real)).flatten())
 
-                self.mtimecurve.setData(numpy.arange(ntaps), self.taps.real)
+                self.mtimecurve.setData(np.arange(ntaps), self.taps.real)
 
 
-                self.mtimecurve_i_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+                self.mtimecurve_i_stems.setData(np.repeat(np.arange(ntaps), 2),
                                                 np.dstack((np.zeros(self.taps.imag.shape[0], dtype=int),
                                                             self.taps.imag)).flatten())
 
@@ -1062,15 +1072,15 @@ class gr_plot_filter(QtGui.QMainWindow):
         else:
             stepres = self.step_response(self.taps)
 
-        if(type(stepres[0]) == numpy.complex128):
-            self.steprescurve_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+        if(type(stepres[0]) == np.complex128):
+            self.steprescurve_stems.setData(np.repeat(np.arange(ntaps), 2),
                                             np.dstack((np.zeros(stepres.real.shape[0], dtype=int),
                                                        stepres.real)).flatten())
 
-            self.steprescurve.setData(numpy.arange(ntaps), stepres.real)
+            self.steprescurve.setData(np.arange(ntaps), stepres.real)
 
 
-            self.steprescurve_i_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+            self.steprescurve_i_stems.setData(np.repeat(np.arange(ntaps), 2),
                                               np.dstack((np.zeros(stepres.imag.shape[0], dtype=int),
                                                          stepres.imag)).flatten())
 
@@ -1085,15 +1095,15 @@ class gr_plot_filter(QtGui.QMainWindow):
             self.steprescurve_i.setData([],[])
 
         if self.mtstep:
-            if(type(stepres[0]) == numpy.complex128):
-                self.mtimecurve_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+            if(type(stepres[0]) == np.complex128):
+                self.mtimecurve_stems.setData(np.repeat(np.arange(ntaps), 2),
                                                 np.dstack((np.zeros(stepres.real.shape[0], dtype=int),
                                                         stepres.real)).flatten())
 
-                self.mtimecurve.setData(numpy.arange(ntaps), stepres.real)
+                self.mtimecurve.setData(np.arange(ntaps), stepres.real)
 
 
-                self.mtimecurve_i_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+                self.mtimecurve_i_stems.setData(np.repeat(np.arange(ntaps), 2),
                                                 np.dstack((np.zeros(stepres.imag.shape[0], dtype=int),
                                                             stepres.imag)).flatten())
 
@@ -1131,15 +1141,15 @@ class gr_plot_filter(QtGui.QMainWindow):
         else:
             impres = self.impulse_response(self.taps)
 
-        if(type(impres[0]) == numpy.complex128):
-            self.imprescurve_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+        if(type(impres[0]) == np.complex128):
+            self.imprescurve_stems.setData(np.repeat(np.arange(ntaps), 2),
                                            np.dstack((np.zeros(impres.real.shape[0], dtype=int),
                                                       impres.real)).flatten())
 
-            self.imprescurve.setData(numpy.arange(ntaps), impres.real)
+            self.imprescurve.setData(np.arange(ntaps), impres.real)
 
 
-            self.imprescurve_i_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+            self.imprescurve_i_stems.setData(np.repeat(np.arange(ntaps), 2),
                                              np.dstack((np.zeros(impres.imag.shape[0], dtype=int),
                                                         impres.imag)).flatten())
 
@@ -1150,15 +1160,15 @@ class gr_plot_filter(QtGui.QMainWindow):
                                                       impres)).flatten())
 
         if self.mtimpulse:
-            if(type(impres[0]) == numpy.complex128):
-                self.mtimecurve_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+            if(type(impres[0]) == np.complex128):
+                self.mtimecurve_stems.setData(np.repeat(np.arange(ntaps), 2),
                                             np.dstack((np.zeros(impres.real.shape[0], dtype=int),
                                                         impres.real)).flatten())
 
-                self.mtimecurve.setData(numpy.arange(ntaps), impres.real)
+                self.mtimecurve.setData(np.arange(ntaps), impres.real)
 
 
-                self.mtimecurve_i_stems.setData(np.repeat(numpy.arange(ntaps), 2),
+                self.mtimecurve_i_stems.setData(np.repeat(np.arange(ntaps), 2),
                                                 np.dstack((np.zeros(impres.imag.shape[0], dtype=int),
                                                             impres.imag)).flatten())
 
@@ -1639,7 +1649,7 @@ class gr_plot_filter(QtGui.QMainWindow):
 
     def update_fft(self, taps, params):
         self.params = params
-        self.taps = numpy.array(taps)
+        self.taps = np.array(taps)
         self.get_fft(self.params["fs"], self.taps, self.nfftpts)
 
     def set_mfoverlay(self):
@@ -1942,9 +1952,9 @@ class gr_plot_filter(QtGui.QMainWindow):
         length = len(b)
         if self.iir:
             length = 50
-        impulse = numpy.repeat(0., length)
+        impulse = np.repeat(0., length)
         impulse[0] = 1.
-        x = numpy.arange(0, length)
+        x = np.arange(0, length)
         response = signal.lfilter(b, a, impulse)
         return response
 
@@ -1952,11 +1962,11 @@ class gr_plot_filter(QtGui.QMainWindow):
         length = len(b)
         if self.iir:
             length = 50
-        impulse = numpy.repeat(0., length)
+        impulse = np.repeat(0., length)
         impulse[0] = 1.
-        x = numpy.arange(0, length)
+        x = np.arange(0, length)
         response = signal.lfilter(b, a, impulse)
-        step = numpy.cumsum(response)
+        step = np.cumsum(response)
         return step
 
     def update_fcoeff(self):
@@ -2192,7 +2202,7 @@ class gr_plot_filter(QtGui.QMainWindow):
 
     def draw_plots(self, taps, params):
         self.params = params
-        self.taps = numpy.array(taps)
+        self.taps = np.array(taps)
         if self.params:
             self.get_fft(self.params["fs"], self.taps, self.nfftpts)
             self.update_time_curves()
diff -uNrp a/gr-qtgui/grc/qtgui_edit_box_msg.block.yml b/gr-qtgui/grc/qtgui_edit_box_msg.block.yml
--- a/gr-qtgui/grc/qtgui_edit_box_msg.block.yml	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/grc/qtgui_edit_box_msg.block.yml	2019-10-20 04:31:39.000000000 +0700
@@ -39,7 +39,7 @@ parameters:
     hide: part
 
 asserts:
-- ${(is_pair and is_static and len(key) > 0) or not (is_pair and is_static)}
+- ${(len(key) > 0) or not ((is_pair == 'True') and (is_static == 'True'))}
 
 inputs:
 -   domain: message
diff -uNrp a/gr-qtgui/grc/qtgui_tab_widget.block.yml b/gr-qtgui/grc/qtgui_tab_widget.block.yml
--- a/gr-qtgui/grc/qtgui_tab_widget.block.yml	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/grc/qtgui_tab_widget.block.yml	2019-10-20 04:31:39.000000000 +0700
@@ -1,6 +1,6 @@
 id: qtgui_tab_widget
 label: QT GUI Tab Widget
-flags: [ python ]
+flags: [show_id, python ]
 
 parameters:
 -   id: num_tabs
diff -uNrp a/gr-qtgui/include/gnuradio/qtgui/form_menus.h b/gr-qtgui/include/gnuradio/qtgui/form_menus.h
--- a/gr-qtgui/include/gnuradio/qtgui/form_menus.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/include/gnuradio/qtgui/form_menus.h	2019-10-20 04:31:39.000000000 +0700
@@ -700,7 +700,6 @@ public slots:
 
 private:
     QList<QAction*> d_act;
-    OtherAction* d_other;
     QActionGroup* d_grp;
 };
 
@@ -807,7 +806,6 @@ public slots:
 
 private:
     QList<QAction*> d_act;
-    OtherAction* d_other;
     QActionGroup* d_grp;
     float d_off, d_high, d_medium, d_low;
 };
@@ -929,7 +927,6 @@ public slots:
 private:
     QList<QAction*> d_act;
     QActionGroup* d_grp;
-    int d_which;
 };
 
 
@@ -1078,7 +1075,6 @@ public slots:
 private:
     QActionGroup* d_grp;
     QList<QAction*> d_act;
-    OtherDualAction* d_other;
     QColor d_max_value, d_min_value;
     int d_which;
 };
diff -uNrp a/gr-qtgui/include/gnuradio/qtgui/freq_sink_c.h b/gr-qtgui/include/gnuradio/qtgui/freq_sink_c.h
--- a/gr-qtgui/include/gnuradio/qtgui/freq_sink_c.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/include/gnuradio/qtgui/freq_sink_c.h	2019-10-20 04:31:39.000000000 +0700
@@ -45,7 +45,7 @@ namespace qtgui {
  * This is a QT-based graphical sink the takes set of a complex
  * streams and plots the PSD. Each signal is plotted with a
  * different color, and the \a set_title and \a set_color
- * functions can be used to change the lable and color for a given
+ * functions can be used to change the label and color for a given
  * input number.
  *
  * The sink supports plotting streaming complex data or
diff -uNrp a/gr-qtgui/include/gnuradio/qtgui/freq_sink_f.h b/gr-qtgui/include/gnuradio/qtgui/freq_sink_f.h
--- a/gr-qtgui/include/gnuradio/qtgui/freq_sink_f.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/include/gnuradio/qtgui/freq_sink_f.h	2019-10-20 04:31:39.000000000 +0700
@@ -45,7 +45,7 @@ namespace qtgui {
  * This is a QT-based graphical sink the takes set of a floating
  * point streams and plots the PSD. Each signal is plotted with a
  * different color, and the \a set_title and \a set_color
- * functions can be used to change the lable and color for a given
+ * functions can be used to change the label and color for a given
  * input number.
  *
  * The sink supports plotting streaming float data or
diff -uNrp a/gr-qtgui/include/gnuradio/qtgui/plot_raster.h b/gr-qtgui/include/gnuradio/qtgui/plot_raster.h
--- a/gr-qtgui/include/gnuradio/qtgui/plot_raster.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/include/gnuradio/qtgui/plot_raster.h	2019-10-20 04:31:39.000000000 +0700
@@ -69,11 +69,6 @@ public:
 
     virtual int rtti() const;
 
-    virtual void draw(QPainter* p,
-                      const QwtScaleMap& xMap,
-                      const QwtScaleMap& yMap,
-                      const QRect& rect) const;
-
 protected:
 #if QWT_VERSION < 0x060000
     QImage renderImage(const QwtScaleMap& xMap,
diff -uNrp a/gr-qtgui/include/gnuradio/qtgui/plot_waterfall.h b/gr-qtgui/include/gnuradio/qtgui/plot_waterfall.h
--- a/gr-qtgui/include/gnuradio/qtgui/plot_waterfall.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/include/gnuradio/qtgui/plot_waterfall.h	2019-10-20 04:31:39.000000000 +0700
@@ -64,11 +64,6 @@ public:
 
     virtual int rtti() const;
 
-    virtual void draw(QPainter* p,
-                      const QwtScaleMap& xMap,
-                      const QwtScaleMap& yMap,
-                      const QRect& rect) const;
-
 protected:
 #if QWT_VERSION < 0x060000
     QImage renderImage(const QwtScaleMap& xMap,
diff -uNrp a/gr-qtgui/include/gnuradio/qtgui/time_raster_sink_b.h b/gr-qtgui/include/gnuradio/qtgui/time_raster_sink_b.h
--- a/gr-qtgui/include/gnuradio/qtgui/time_raster_sink_b.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/include/gnuradio/qtgui/time_raster_sink_b.h	2019-10-20 04:31:39.000000000 +0700
@@ -98,7 +98,7 @@ public:
 
     virtual void set_update_time(double t) = 0;
     virtual void set_title(const std::string& title) = 0;
-    virtual void set_line_label(unsigned int which, const std::string& lable) = 0;
+    virtual void set_line_label(unsigned int which, const std::string& label) = 0;
     virtual void set_line_color(unsigned int which, const std::string& color) = 0;
     virtual void set_line_width(unsigned int which, int width) = 0;
     virtual void set_line_style(unsigned int which, Qt::PenStyle style) = 0;
diff -uNrp a/gr-qtgui/include/gnuradio/qtgui/time_raster_sink_f.h b/gr-qtgui/include/gnuradio/qtgui/time_raster_sink_f.h
--- a/gr-qtgui/include/gnuradio/qtgui/time_raster_sink_f.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/include/gnuradio/qtgui/time_raster_sink_f.h	2019-10-20 04:31:39.000000000 +0700
@@ -94,7 +94,7 @@ public:
 
     virtual void set_update_time(double t) = 0;
     virtual void set_title(const std::string& title) = 0;
-    virtual void set_line_label(unsigned int which, const std::string& lable) = 0;
+    virtual void set_line_label(unsigned int which, const std::string& label) = 0;
     virtual void set_line_color(unsigned int which, const std::string& color) = 0;
     virtual void set_line_width(unsigned int which, int width) = 0;
     virtual void set_line_style(unsigned int which, Qt::PenStyle style) = 0;
diff -uNrp a/gr-qtgui/include/gnuradio/qtgui/time_sink_c.h b/gr-qtgui/include/gnuradio/qtgui/time_sink_c.h
--- a/gr-qtgui/include/gnuradio/qtgui/time_sink_c.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/include/gnuradio/qtgui/time_sink_c.h	2019-10-20 04:31:39.000000000 +0700
@@ -45,7 +45,7 @@ namespace qtgui {
  * streams and plots them in the time domain. For each signal, both
  * the signal's I and Q parts are plotted, and they are all plotted
  * with a different color, and the \a set_title and \a set_color
- * functions can be used to change the lable and color for a given
+ * functions can be used to change the label and color for a given
  * input number.
  *
  * The sink supports plotting streaming complex data or
diff -uNrp a/gr-qtgui/include/gnuradio/qtgui/time_sink_f.h b/gr-qtgui/include/gnuradio/qtgui/time_sink_f.h
--- a/gr-qtgui/include/gnuradio/qtgui/time_sink_f.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/include/gnuradio/qtgui/time_sink_f.h	2019-10-20 04:31:39.000000000 +0700
@@ -44,7 +44,7 @@ namespace qtgui {
  * This is a QT-based graphical sink the takes set of a float streams
  * and plots them in the time domain. Each signal is plotted with a
  * different color, and the \a set_title and \a set_color functions
- * can be used to change the lable and color for a given input number.
+ * can be used to change the label and color for a given input number.
  *
  * The sink supports plotting streaming float data or
  * messages. The message port is named "in". The two modes cannot
diff -uNrp a/gr-qtgui/lib/TimeDomainDisplayPlot.cc b/gr-qtgui/lib/TimeDomainDisplayPlot.cc
--- a/gr-qtgui/lib/TimeDomainDisplayPlot.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/TimeDomainDisplayPlot.cc	2019-10-20 04:31:39.000000000 +0700
@@ -260,7 +260,7 @@ void TimeDomainDisplayPlot::plotNewData(
             // Plot and attach any new tags found.
             // First test if this was a complex input where real/imag get
             // split here into two stream.
-            if (tags.size() > 0) {
+            if (!tags.empty()) {
                 bool cmplx = false;
                 unsigned int mult = d_nplots / tags.size();
                 if (mult == 2)
diff -uNrp a/gr-qtgui/lib/ber_sink_b_impl.cc b/gr-qtgui/lib/ber_sink_b_impl.cc
--- a/gr-qtgui/lib/ber_sink_b_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/ber_sink_b_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -109,7 +109,7 @@ ber_sink_b_impl::ber_sink_b_impl(std::ve
 
     if (curvenames.size() == (unsigned int)curves) {
         for (int j = 0; j < curves; j++) {
-            if (curvenames[j] != "") {
+            if (!curvenames[j].empty()) {
                 set_line_label(j, curvenames[j]);
             }
         }
diff -uNrp a/gr-qtgui/lib/const_sink_c_impl.cc b/gr-qtgui/lib/const_sink_c_impl.cc
--- a/gr-qtgui/lib/const_sink_c_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/const_sink_c_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -138,7 +138,7 @@ void const_sink_c_impl::initialize()
     d_main_gui = new ConstellationDisplayForm(numplots, d_parent);
     d_main_gui->setNPoints(d_size);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     // initialize update time to 10 times a second
@@ -364,7 +364,7 @@ void const_sink_c_impl::_test_trigger_ta
     uint64_t nr = nitems_read(d_trigger_channel);
     std::vector<gr::tag_t> tags;
     get_tags_in_range(tags, d_trigger_channel, nr, nr + nitems, d_trigger_tag_key);
-    if (tags.size() > 0) {
+    if (!tags.empty()) {
         d_triggered = true;
         trigger_index = tags[0].offset - nr;
         d_start = d_index + trigger_index;
diff -uNrp a/gr-qtgui/lib/edit_box_msg_impl.cc b/gr-qtgui/lib/edit_box_msg_impl.cc
--- a/gr-qtgui/lib/edit_box_msg_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/edit_box_msg_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -106,7 +106,7 @@ edit_box_msg_impl::edit_box_msg_impl(dat
             d_key->setFixedWidth(width);
 
             // Verify that a default key has been set or emit an error
-            if (key.size() == 0) {
+            if (key.empty()) {
                 throw std::runtime_error(
                     "When using static + pair mode, please set a default key.");
             }
@@ -118,7 +118,7 @@ edit_box_msg_impl::edit_box_msg_impl(dat
     }
 
     d_label = NULL;
-    if (label != "") {
+    if (!label.empty()) {
         d_label = new QLabel(QString(label.c_str()));
         d_vlayout->addWidget(d_label);
     }
@@ -481,7 +481,6 @@ void edit_box_msg_impl::edit_finished()
         std::vector<gr_complex> xv;
         QStringList text_list = text.split(",");
         bool even = false;
-        gr_complex c;
         float re, im;
         for (int i = 0; i < text_list.size(); ++i) {
             QString s = text_list.at(i);
@@ -492,7 +491,7 @@ void edit_box_msg_impl::edit_finished()
             if (conv_ok) {
                 if (even) {
                     im = t;
-                    xv.push_back(gr_complex(re, im));
+                    xv.emplace_back(re, im);
                     even = false;
                 } else {
                     re = t;
diff -uNrp a/gr-qtgui/lib/freq_sink_c_impl.cc b/gr-qtgui/lib/freq_sink_c_impl.cc
--- a/gr-qtgui/lib/freq_sink_c_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/freq_sink_c_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2012,2014-2015 Free Software Foundation, Inc.
+ * Copyright 2012,2014-2015,2019 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -33,6 +33,7 @@
 #include <volk/volk.h>
 
 #include <string.h>
+#include <algorithm>
 
 namespace gr {
 namespace qtgui {
@@ -111,7 +112,7 @@ freq_sink_c_impl::freq_sink_c_impl(int f
         d_magbufs.push_back(
             (double*)volk_malloc(d_fftsize * sizeof(double), volk_get_alignment()));
 
-        memset(d_residbufs[i], 0, d_fftsize * sizeof(gr_complex));
+        std::fill_n(d_residbufs[i], d_fftsize, 0);
         memset(d_magbufs[i], 0, d_fftsize * sizeof(double));
     }
 
@@ -119,7 +120,7 @@ freq_sink_c_impl::freq_sink_c_impl(int f
         (gr_complex*)volk_malloc(d_fftsize * sizeof(gr_complex), volk_get_alignment()));
     d_pdu_magbuf = (double*)volk_malloc(d_fftsize * sizeof(double), volk_get_alignment());
     d_magbufs.push_back(d_pdu_magbuf);
-    memset(d_residbufs[d_nconnections], 0, d_fftsize * sizeof(gr_complex));
+    std::fill_n(d_residbufs[d_nconnections], d_fftsize, 0);
     memset(d_pdu_magbuf, 0, d_fftsize * sizeof(double));
 
     buildwindow();
@@ -171,7 +172,7 @@ void freq_sink_c_impl::initialize()
     set_fft_size(d_fftsize);
     set_frequency_range(d_center_freq, d_bandwidth);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     set_output_multiple(d_fftsize);
@@ -387,7 +388,7 @@ void freq_sink_c_impl::_reset()
 
 void freq_sink_c_impl::fft(float* data_out, const gr_complex* data_in, int size)
 {
-    if (d_window.size()) {
+    if (!d_window.empty()) {
         volk_32fc_32f_multiply_32fc(d_fft->get_inbuf(), data_in, &d_window.front(), size);
     } else {
         memcpy(d_fft->get_inbuf(), data_in, sizeof(gr_complex) * size);
@@ -442,7 +443,7 @@ bool freq_sink_c_impl::fftresize()
             d_magbufs[i] =
                 (double*)volk_malloc(newfftsize * sizeof(double), volk_get_alignment());
 
-            memset(d_residbufs[i], 0, newfftsize * sizeof(gr_complex));
+            std::fill_n(d_residbufs[i], newfftsize, 0);
             memset(d_magbufs[i], 0, newfftsize * sizeof(double));
         }
 
@@ -529,7 +530,7 @@ void freq_sink_c_impl::_test_trigger_tag
     std::vector<gr::tag_t> tags;
     get_tags_in_range(
         tags, d_trigger_channel, nr + start, nr + start + nitems, d_trigger_tag_key);
-    if (tags.size() > 0) {
+    if (!tags.empty()) {
         d_triggered = true;
         d_index = tags[0].offset - nr;
         d_trigger_count = 0;
@@ -672,7 +673,7 @@ void freq_sink_c_impl::handle_pdus(pmt::
         size_t max = std::min(d_fftsize, static_cast<int>(len));
         for (int n = 0; n < nffts; n++) {
             // Clear in case (max-min) < d_fftsize
-            memset(d_residbufs[d_nconnections], 0x00, sizeof(gr_complex) * d_fftsize);
+            std::fill_n(d_residbufs[d_nconnections], d_fftsize, 0x00);
 
             // Copy in as much of the input samples as we can
             memcpy(
diff -uNrp a/gr-qtgui/lib/freq_sink_f_impl.cc b/gr-qtgui/lib/freq_sink_f_impl.cc
--- a/gr-qtgui/lib/freq_sink_f_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/freq_sink_f_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -172,7 +172,7 @@ void freq_sink_f_impl::initialize()
     set_fft_size(d_fftsize);
     set_frequency_range(d_center_freq, d_bandwidth);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     set_output_multiple(d_fftsize);
@@ -394,7 +394,7 @@ void freq_sink_f_impl::fft(float* data_o
     for (int i = 0; i < size; i++)
         dst[i] = data_in[i];
 
-    if (d_window.size()) {
+    if (!d_window.empty()) {
         volk_32fc_32f_multiply_32fc(d_fft->get_inbuf(), dst, &d_window.front(), size);
     }
 
@@ -533,7 +533,7 @@ void freq_sink_f_impl::_test_trigger_tag
     std::vector<gr::tag_t> tags;
     get_tags_in_range(
         tags, d_trigger_channel, nr + start, nr + start + nitems, d_trigger_tag_key);
-    if (tags.size() > 0) {
+    if (!tags.empty()) {
         d_triggered = true;
         d_index = tags[0].offset - nr;
         d_trigger_count = 0;
diff -uNrp a/gr-qtgui/lib/freqdisplayform.cc b/gr-qtgui/lib/freqdisplayform.cc
--- a/gr-qtgui/lib/freqdisplayform.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/freqdisplayform.cc	2019-10-20 04:31:39.000000000 +0700
@@ -423,7 +423,7 @@ void FreqDisplayForm::updateTrigger(gr::
     }
 
     // if tag mode, popup tag key box to set
-    if ((d_trig_tag_key == "") && (d_trig_mode == gr::qtgui::TRIG_MODE_TAG))
+    if ((d_trig_tag_key.empty()) && (d_trig_mode == gr::qtgui::TRIG_MODE_TAG))
         d_tr_tag_key_act->activate(QAction::Trigger);
 
     emit signalReplot();
diff -uNrp a/gr-qtgui/lib/histogram_sink_f_impl.cc b/gr-qtgui/lib/histogram_sink_f_impl.cc
--- a/gr-qtgui/lib/histogram_sink_f_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/histogram_sink_f_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -137,7 +137,7 @@ void histogram_sink_f_impl::initialize()
     d_main_gui->setNPoints(d_size);
     d_main_gui->setXaxis(d_xmin, d_xmax);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     // initialize update time to 10 times a second
diff -uNrp a/gr-qtgui/lib/numberdisplayform.cc b/gr-qtgui/lib/numberdisplayform.cc
--- a/gr-qtgui/lib/numberdisplayform.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/numberdisplayform.cc	2019-10-20 04:31:39.000000000 +0700
@@ -40,7 +40,7 @@ NumberDisplayForm::NumberDisplayForm(int
         d_min.push_back(+1e32);
         d_max.push_back(-1e32);
         d_label.push_back(new QLabel(QString("Data %1").arg(i)));
-        d_unit.push_back("");
+        d_unit.emplace_back("");
         d_factor.push_back(1);
         d_text_box.push_back(new QLabel(QString("0")));
 
diff -uNrp a/gr-qtgui/lib/plot_raster.cc b/gr-qtgui/lib/plot_raster.cc
--- a/gr-qtgui/lib/plot_raster.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/plot_raster.cc	2019-10-20 04:31:39.000000000 +0700
@@ -299,22 +299,3 @@ QwtInterval PlotTimeRaster::interval(Qt:
 }
 #endif
 
-/*!
-  \brief Draw the raster
-
-  \param painter Painter
-  \param xMap Maps x-values into pixel coordinates.
-  \param yMap Maps y-values into pixel coordinates.
-  \param canvasRect Contents rect of the canvas in painter coordinates
-
-  \sa setDisplayMode, renderImage,
-  QwtPlotRasterItem::draw, drawContourLines
-*/
-
-void PlotTimeRaster::draw(QPainter* painter,
-                          const QwtScaleMap& xMap,
-                          const QwtScaleMap& yMap,
-                          const QRect& canvasRect) const
-{
-    QwtPlotRasterItem::draw(painter, xMap, yMap, canvasRect);
-}
diff -uNrp a/gr-qtgui/lib/plot_waterfall.cc b/gr-qtgui/lib/plot_waterfall.cc
--- a/gr-qtgui/lib/plot_waterfall.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/plot_waterfall.cc	2019-10-20 04:31:39.000000000 +0700
@@ -280,22 +280,3 @@ QImage PlotWaterfall::renderImage(const 
     return image;
 }
 
-/*!
-  \brief Draw the spectrogram
-
-  \param painter Painter
-  \param xMap Maps x-values into pixel coordinates.
-  \param yMap Maps y-values into pixel coordinates.
-  \param canvasRect Contents rect of the canvas in painter coordinates
-
-  \sa setDisplayMode, renderImage,
-  QwtPlotRasterItem::draw, drawContourLines
-*/
-
-void PlotWaterfall::draw(QPainter* painter,
-                         const QwtScaleMap& xMap,
-                         const QwtScaleMap& yMap,
-                         const QRect& canvasRect) const
-{
-    QwtPlotRasterItem::draw(painter, xMap, yMap, canvasRect);
-}
diff -uNrp a/gr-qtgui/lib/qtgui_util.cc b/gr-qtgui/lib/qtgui_util.cc
--- a/gr-qtgui/lib/qtgui_util.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/qtgui_util.cc	2019-10-20 04:31:39.000000000 +0700
@@ -104,7 +104,7 @@ QwtPickerMachine* QwtDblClickPlotPicker:
 void check_set_qss(QApplication* app)
 {
     std::string qssfile = gr::prefs::singleton()->get_string("qtgui", "qss", "");
-    if (qssfile.size() > 0) {
+    if (!qssfile.empty()) {
         QString sstext = get_qt_style_sheet(QString(qssfile.c_str()));
         app->setStyleSheet(sstext);
     }
diff -uNrp a/gr-qtgui/lib/sink_c_impl.cc b/gr-qtgui/lib/sink_c_impl.cc
--- a/gr-qtgui/lib/sink_c_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/sink_c_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -238,7 +238,7 @@ void sink_c_impl::set_update_time(double
 
 void sink_c_impl::fft(float* data_out, const gr_complex* data_in, int size)
 {
-    if (d_window.size()) {
+    if (!d_window.empty()) {
         volk_32fc_32f_multiply_32fc(d_fft->get_inbuf(), data_in, &d_window.front(), size);
     } else {
         memcpy(d_fft->get_inbuf(), data_in, sizeof(gr_complex) * size);
diff -uNrp a/gr-qtgui/lib/sink_f_impl.cc b/gr-qtgui/lib/sink_f_impl.cc
--- a/gr-qtgui/lib/sink_f_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/sink_f_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -228,7 +228,7 @@ void sink_f_impl::set_update_time(double
 
 void sink_f_impl::fft(float* data_out, const float* data_in, int size)
 {
-    if (d_window.size()) {
+    if (!d_window.empty()) {
         gr_complex* dst = d_fft->get_inbuf();
         for (int i = 0; i < size; i++) // apply window
             dst[i] = data_in[i] * d_window[i];
diff -uNrp a/gr-qtgui/lib/spectrumdisplayform.cc b/gr-qtgui/lib/spectrumdisplayform.cc
--- a/gr-qtgui/lib/spectrumdisplayform.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/spectrumdisplayform.cc	2019-10-20 04:31:39.000000000 +0700
@@ -484,7 +484,7 @@ void SpectrumDisplayForm::setAverageCoun
 void SpectrumDisplayForm::_averageHistory(const double* newBuffer)
 {
     if (_numRealDataPoints > 0) {
-        if (_historyVector->size() > 0) {
+        if (!_historyVector->empty()) {
             memcpy(_historyVector->operator[](_historyEntry),
                    newBuffer,
                    _numRealDataPoints * sizeof(double));
diff -uNrp a/gr-qtgui/lib/time_raster_sink_b_impl.cc b/gr-qtgui/lib/time_raster_sink_b_impl.cc
--- a/gr-qtgui/lib/time_raster_sink_b_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/time_raster_sink_b_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -146,7 +146,7 @@ void time_raster_sink_b_impl::initialize
     d_main_gui =
         new TimeRasterDisplayForm(numplots, d_samp_rate, d_rows, d_cols, 1, d_parent);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     // initialize update time to 10 times a second
@@ -297,7 +297,7 @@ double time_raster_sink_b_impl::num_cols
 
 void time_raster_sink_b_impl::set_multiplier(const std::vector<float>& mult)
 {
-    if (mult.size() == 0) {
+    if (mult.empty()) {
         for (int i = 0; i < d_nconnections + 1; i++) {
             d_mult[i] = 1.0f;
         }
@@ -317,7 +317,7 @@ void time_raster_sink_b_impl::set_multip
 
 void time_raster_sink_b_impl::set_offset(const std::vector<float>& offset)
 {
-    if (offset.size() == 0) {
+    if (offset.empty()) {
         for (int i = 0; i < d_nconnections + 1; i++) {
             d_offset[i] = 0.0f;
         }
diff -uNrp a/gr-qtgui/lib/time_raster_sink_f_impl.cc b/gr-qtgui/lib/time_raster_sink_f_impl.cc
--- a/gr-qtgui/lib/time_raster_sink_f_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/time_raster_sink_f_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -144,7 +144,7 @@ void time_raster_sink_f_impl::initialize
     d_main_gui =
         new TimeRasterDisplayForm(numplots, d_samp_rate, d_rows, d_cols, 1, d_parent);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     // initialize update time to 10 times a second
@@ -300,7 +300,7 @@ double time_raster_sink_f_impl::num_cols
 
 void time_raster_sink_f_impl::set_multiplier(const std::vector<float>& mult)
 {
-    if (mult.size() == 0) {
+    if (mult.empty()) {
         for (int i = 0; i < d_nconnections; i++) {
             d_mult[i] = 1.0f;
         }
@@ -316,7 +316,7 @@ void time_raster_sink_f_impl::set_multip
 
 void time_raster_sink_f_impl::set_offset(const std::vector<float>& offset)
 {
-    if (offset.size() == 0) {
+    if (offset.empty()) {
         for (int i = 0; i < d_nconnections; i++) {
             d_offset[i] = 0.0f;
         }
diff -uNrp a/gr-qtgui/lib/time_sink_c_impl.cc b/gr-qtgui/lib/time_sink_c_impl.cc
--- a/gr-qtgui/lib/time_sink_c_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/time_sink_c_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2011-2013,2015 Free Software Foundation, Inc.
+ * Copyright 2011-2013,2015,2019 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -34,6 +34,7 @@
 #include <volk/volk.h>
 
 #include <string.h>
+#include <algorithm>
 
 namespace gr {
 namespace qtgui {
@@ -92,7 +93,7 @@ time_sink_c_impl::time_sink_c_impl(int s
     for (unsigned int n = 0; n < d_nconnections / 2; n++) {
         d_cbuffers.push_back((gr_complex*)volk_malloc(d_buffer_size * sizeof(gr_complex),
                                                       volk_get_alignment()));
-        memset(d_cbuffers[n], 0, d_buffer_size * sizeof(gr_complex));
+        std::fill_n(d_cbuffers[n], d_buffer_size, 0);
     }
 
     // Set alignment properties for VOLK
@@ -151,7 +152,7 @@ void time_sink_c_impl::initialize()
     d_main_gui->setNPoints(d_size);
     d_main_gui->setSampleRate(d_samp_rate);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     // initialize update time to 10 times a second
@@ -323,7 +324,7 @@ void time_sink_c_impl::set_nsamps(const 
             volk_free(d_cbuffers[n]);
             d_cbuffers[n] = (gr_complex*)volk_malloc(d_buffer_size * sizeof(gr_complex),
                                                      volk_get_alignment());
-            memset(d_cbuffers[n], 0, d_buffer_size * sizeof(gr_complex));
+            std::fill_n(d_cbuffers[n], d_buffer_size, 0);
         }
 
         // If delay was set beyond the new boundary, pull it back.
@@ -496,7 +497,7 @@ void time_sink_c_impl::_test_trigger_tag
     std::vector<gr::tag_t> tags;
     get_tags_in_range(
         tags, d_trigger_channel / 2, nr, nr + nitems + 1, d_trigger_tag_key);
-    if (tags.size() > 0) {
+    if (!tags.empty()) {
         trigger_index = tags[0].offset - nr;
         int start = d_index + trigger_index - d_trigger_delay - 1;
         if (start >= 0) {
diff -uNrp a/gr-qtgui/lib/time_sink_c_impl.h b/gr-qtgui/lib/time_sink_c_impl.h
--- a/gr-qtgui/lib/time_sink_c_impl.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/time_sink_c_impl.h	2019-10-20 04:31:39.000000000 +0700
@@ -65,7 +65,6 @@ private:
     pmt::pmt_t d_trigger_tag_key;
     bool d_triggered;
     int d_trigger_count;
-    int d_initial_delay; // used for limiting d_trigger_delay
 
     void _reset();
     void _npoints_resize();
diff -uNrp a/gr-qtgui/lib/time_sink_f_impl.cc b/gr-qtgui/lib/time_sink_f_impl.cc
--- a/gr-qtgui/lib/time_sink_f_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/time_sink_f_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -147,7 +147,7 @@ void time_sink_f_impl::initialize()
     d_main_gui->setNPoints(d_size);
     d_main_gui->setSampleRate(d_samp_rate);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     // initialize update time to 10 times a second
@@ -489,7 +489,7 @@ void time_sink_f_impl::_test_trigger_tag
     uint64_t nr = nitems_read(d_trigger_channel);
     std::vector<gr::tag_t> tags;
     get_tags_in_range(tags, d_trigger_channel, nr, nr + nitems + 1, d_trigger_tag_key);
-    if (tags.size() > 0) {
+    if (!tags.empty()) {
         trigger_index = tags[0].offset - nr;
         int start = d_index + trigger_index - d_trigger_delay - 1;
         if (start >= 0) {
diff -uNrp a/gr-qtgui/lib/time_sink_f_impl.h b/gr-qtgui/lib/time_sink_f_impl.h
--- a/gr-qtgui/lib/time_sink_f_impl.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/time_sink_f_impl.h	2019-10-20 04:31:39.000000000 +0700
@@ -63,7 +63,6 @@ private:
     pmt::pmt_t d_trigger_tag_key;
     bool d_triggered;
     int d_trigger_count;
-    int d_initial_delay; // used for limiting d_trigger_delay
 
     void _reset();
     void _npoints_resize();
diff -uNrp a/gr-qtgui/lib/timedisplayform.cc b/gr-qtgui/lib/timedisplayform.cc
--- a/gr-qtgui/lib/timedisplayform.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/timedisplayform.cc	2019-10-20 04:31:39.000000000 +0700
@@ -376,7 +376,7 @@ void TimeDisplayForm::updateTrigger(gr::
     }
 
     // if tag mode, popup tag key box to set
-    if ((d_trig_tag_key == "") && (d_trig_mode == gr::qtgui::TRIG_MODE_TAG))
+    if ((d_trig_tag_key.empty()) && (d_trig_mode == gr::qtgui::TRIG_MODE_TAG))
         d_tr_tag_key_act->activate(QAction::Trigger);
 
     emit signalReplot();
diff -uNrp a/gr-qtgui/lib/waterfall_sink_c_impl.cc b/gr-qtgui/lib/waterfall_sink_c_impl.cc
--- a/gr-qtgui/lib/waterfall_sink_c_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/waterfall_sink_c_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -1,6 +1,6 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2012,2014-2015 Free Software Foundation, Inc.
+ * Copyright 2012,2014-2015,2019 Free Software Foundation, Inc.
  *
  * This file is part of GNU Radio
  *
@@ -34,6 +34,7 @@
 
 #include <string.h>
 #include <iostream>
+#include <algorithm>
 
 namespace gr {
 namespace qtgui {
@@ -98,7 +99,7 @@ waterfall_sink_c_impl::waterfall_sink_c_
                                                        volk_get_alignment()));
         d_magbufs.push_back(
             (double*)volk_malloc(d_fftsize * sizeof(double), volk_get_alignment()));
-        memset(d_residbufs[i], 0, d_fftsize * sizeof(gr_complex));
+        std::fill_n(d_residbufs[i], d_fftsize, 0);
         memset(d_magbufs[i], 0, d_fftsize * sizeof(double));
     }
 
@@ -108,7 +109,7 @@ waterfall_sink_c_impl::waterfall_sink_c_
         (double*)volk_malloc(d_fftsize * sizeof(double) * d_nrows, volk_get_alignment());
     d_magbufs.push_back(d_pdu_magbuf);
     memset(d_pdu_magbuf, 0, d_fftsize * sizeof(double) * d_nrows);
-    memset(d_residbufs[d_nconnections], 0, d_fftsize * sizeof(gr_complex));
+    std::fill_n(d_residbufs[d_nconnections], d_fftsize, 0);
 
     buildwindow();
 
@@ -182,7 +183,7 @@ void waterfall_sink_c_impl::initialize()
     set_fft_size(d_fftsize);
     set_frequency_range(d_center_freq, d_bandwidth);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     // initialize update time to 10 times a second
@@ -318,7 +319,7 @@ void waterfall_sink_c_impl::disable_lege
 
 void waterfall_sink_c_impl::fft(float* data_out, const gr_complex* data_in, int size)
 {
-    if (d_window.size()) {
+    if (!d_window.empty()) {
         volk_32fc_32f_multiply_32fc(d_fft->get_inbuf(), data_in, &d_window.front(), size);
     } else {
         memcpy(d_fft->get_inbuf(), data_in, sizeof(gr_complex) * size);
@@ -371,7 +372,7 @@ void waterfall_sink_c_impl::fftresize()
             d_magbufs[i] =
                 (double*)volk_malloc(newfftsize * sizeof(double), volk_get_alignment());
 
-            memset(d_residbufs[i], 0, newfftsize * sizeof(gr_complex));
+            std::fill_n(d_residbufs[i], newfftsize, 0);
             memset(d_magbufs[i], 0, newfftsize * sizeof(double));
         }
 
@@ -385,7 +386,7 @@ void waterfall_sink_c_impl::fftresize()
         d_pdu_magbuf = (double*)volk_malloc(newfftsize * sizeof(double) * d_nrows,
                                             volk_get_alignment());
         d_magbufs[d_nconnections] = d_pdu_magbuf;
-        memset(d_residbufs[d_nconnections], 0, newfftsize * sizeof(gr_complex));
+        std::fill_n(d_residbufs[d_nconnections], newfftsize, 0);
         memset(d_pdu_magbuf, 0, newfftsize * sizeof(double) * d_nrows);
 
         // Set new fft size and reset buffer index
@@ -558,7 +559,7 @@ void waterfall_sink_c_impl::handle_pdus(
         size_t max = std::min(d_fftsize, static_cast<int>(len));
         for (size_t i = 0; j < d_nrows; i += stride) {
             // Clear residbufs if len < d_fftsize
-            memset(d_residbufs[d_nconnections], 0x00, sizeof(gr_complex) * d_fftsize);
+            std::fill_n(d_residbufs[d_nconnections], d_fftsize, 0x00);
 
             // Copy in as much of the input samples as we can
             memcpy(
diff -uNrp a/gr-qtgui/lib/waterfall_sink_f_impl.cc b/gr-qtgui/lib/waterfall_sink_f_impl.cc
--- a/gr-qtgui/lib/waterfall_sink_f_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-qtgui/lib/waterfall_sink_f_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -181,7 +181,7 @@ void waterfall_sink_f_impl::initialize()
     set_fft_size(d_fftsize);
     set_frequency_range(d_center_freq, d_bandwidth);
 
-    if (d_name.size() > 0)
+    if (!d_name.empty())
         set_title(d_name);
 
     // initialize update time to 10 times a second
@@ -327,7 +327,7 @@ void waterfall_sink_f_impl::fft(float* d
     for (int i = 0; i < size; i++)
         dst[i] = data_in[i];
 
-    if (d_window.size()) {
+    if (!d_window.empty()) {
         volk_32fc_32f_multiply_32fc(d_fft->get_inbuf(), dst, &d_window.front(), size);
     }
 
diff -uNrp a/gr-trellis/docs/gr-trellis.xml b/gr-trellis/docs/gr-trellis.xml
--- a/gr-trellis/docs/gr-trellis.xml	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-trellis/docs/gr-trellis.xml	2019-10-20 04:31:39.000000000 +0700
@@ -52,7 +52,7 @@ convolutional
 code (CC), a trellis code (TC), an inter-symbol interference (ISI)
 channel, or any
 other communication system that can be modeled with an FSM.
-To achieve this goal, we need to separate the pure FSM descrition from the
+To achieve this goal, we need to separate the pure FSM description from the
 rest of the model details. For instance, in the case of a rate 2/3 TC,
 the FSM should not involve details about the modulation used (it can
 be an 8-ary PAM, or 8-PSK, etc). Similarly, when attempting maximum likelihood
@@ -272,7 +272,7 @@ y<subscript>j</subscript> (e.g., in the 
 
 <listitem>
 <para>
-The fourth way is specific to FSMs resulting from shift registers, and the output symbol being the entire transition (ie, current_state and current_input). These FSMs are usefull when describibg ISI channels. In particular the state is comprised of the input symbols x(k-1), x(k-2),...,x(k-L), where L = ch_length-1 and each x(i) belongs to an alphabet of size mod_size. The output is taken to be x(k), x(k-1), x(k-2),...,x(k-L) (in decimal format)
+The fourth way is specific to FSMs resulting from shift registers, and the output symbol being the entire transition (ie, current_state and current_input). These FSMs are useful when describing ISI channels. In particular the state is comprised of the input symbols x(k-1), x(k-2),...,x(k-L), where L = ch_length-1 and each x(i) belongs to an alphabet of size mod_size. The output is taken to be x(k), x(k-1), x(k-2),...,x(k-L) (in decimal format)
 </para>
 <programlisting>
   fsm(const int mod_size, const int ch_length);
@@ -365,7 +365,7 @@ The output of this block is a sequence o
 The input is a sequence of K x FSM.O( ) floats, where the k x K + i
 float represents the cost associated with the k-th
 step in the trellis and the i-th FSM output.
-Observe that these inputs are generated externally and thus the Viterbi block is not informed of their meaning (they can be genarated as soft or hard inputs, etc); the only requirement is that they represent additive costs.
+Observe that these inputs are generated externally and thus the Viterbi block is not informed of their meaning (they can be generated as soft or hard inputs, etc); the only requirement is that they represent additive costs.
 </para>
 </sect2>
 
@@ -393,7 +393,7 @@ evaluates
 ||r<subscript>k</subscript>-c<subscript>i</subscript>||<superscript>2</superscript> = sum<subscript>j=1</subscript><superscript>D</superscript> |r<subscript>k,j</subscript>-c<subscript>i,j</subscript>|<superscript>2</superscript>
 </para>
 <para>
-for each of the O hypothesized ouput
+for each of the O hypothesized output
 symbols c<subscript>i</subscript> = (c<subscript>i,1</subscript>,c<subscript>i,2</subscript>,...,c<subscript>i,D</subscript>) defined in the vector TABLE,
 where TABLE[i * D + j] = c<subscript>i,j</subscript>.
 </para></listitem>
@@ -446,7 +446,7 @@ d<subscript>i</subscript> is the bitwise
 Although the separation of metric calculation and Viterbi algorithm blocks
 is consistent with our goal of providing general blocks that can be easily
 reused, this separation might result in large input/output buffer sizes
-betwen blocks. Indeed for an FSM with a large output alphabet, the
+between blocks. Indeed for an FSM with a large output alphabet, the
 output of the metric block/input of the Viterbi block is FSM.O( ) floats for
 each trellis step. Sometimes this results in buffer overflow even for
 moderate sequence lengths.
@@ -522,7 +522,7 @@ symbols that will drive the FSM encoder.
 
 
 <para>
-The FSM will produce K output symbols (remeber the FSM produces always one output symbol for each input symbol). Each of these symbols needs to be modulated. Since we are simulating the communication system, we need not simulate the actual waveforms. An M-ary, D-dimensional
+The FSM will produce K output symbols (remember the FSM produces always one output symbol for each input symbol). Each of these symbols needs to be modulated. Since we are simulating the communication system, we need not simulate the actual waveforms. An M-ary, D-dimensional
 modulation is completely specified by a set of M, D-dimensional real vectors. In "fsm_utils.py" file we give a number of useful modulations with the following format: modulation = (D,constellation), where
 constellation=[c11,c12,...,c1D,c21,c22,...,c2D,...,cM1,cM2,...cMD].
 The meaning of the above is that every constellation point c_i
@@ -882,7 +882,7 @@ Although these can be generated by exist
 the SISO blocks, as done in some of the python examples) there is an advantage
 in having this functionality as a single block. To see why, think of a turbo decoder with 10 iterations. Previously we needed to concatenate 10 x 2 SISO blocks
 (for a sccc decoder) to emulate the passing of soft information between SISOs over 10 iterartions. With the new block however, only a single such block is needed that internally loops through 10 iterations; this results in space savings
-and possibly time saving as well (since queueing at the input/ouput of the gr-blocks is avoided).
+and possibly time saving as well (since queueing at the input/output of the gr-blocks is avoided).
 
 
 Still need to document them...
diff -uNrp a/gr-uhd/apps/uhd_fft b/gr-uhd/apps/uhd_fft
--- a/gr-uhd/apps/uhd_fft	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-uhd/apps/uhd_fft	2019-10-20 04:31:39.000000000 +0700
@@ -1,4 +1,4 @@
-#!/usr/bin/env python2
+#!/usr/bin/env python
 #
 # Copyright 2015-2016,2018 Free Software Foundation, Inc.
 #
@@ -34,6 +34,8 @@ UHD FFT: Simple Spectrum Analyzer for UH
 # Note this is a heavily modified version of a
 # the uhd_fft.grc example.
 
+from __future__ import print_function
+from __future__ import division
 import ctypes
 import sys
 import sip
@@ -244,9 +246,9 @@ class uhd_fft(UHDApp, gr.top_block, Qt.Q
         self.qtgui_time_sink_x_0.disable_legend()
         for i in range(2*len(self.channels)):
             if(i % 2 == 0):
-                self.qtgui_time_sink_x_0.set_line_label(i, "Re{{Channel {0}}}".format(i/2))
+                self.qtgui_time_sink_x_0.set_line_label(i, "Re{{Channel {0}}}".format(i//2))
             else:
-                self.qtgui_time_sink_x_0.set_line_label(i, "Im{{Channel {0}}}".format(i/2))
+                self.qtgui_time_sink_x_0.set_line_label(i, "Im{{Channel {0}}}".format(i//2))
             self.qtgui_time_sink_x_0.set_line_width(i, widths[i])
             self.qtgui_time_sink_x_0.set_line_color(i, colors[i])
             self.qtgui_time_sink_x_0.set_line_style(i, styles[i])
@@ -510,4 +512,3 @@ if __name__ == '__main__':
         except:
             print("Warning: failed to XInitThreads()")
     main()
-
diff -uNrp a/gr-uhd/apps/uhd_rx_cfile b/gr-uhd/apps/uhd_rx_cfile
--- a/gr-uhd/apps/uhd_rx_cfile	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-uhd/apps/uhd_rx_cfile	2019-10-20 04:31:39.000000000 +0700
@@ -26,6 +26,7 @@ outputs single precision complex float v
 (interleaved 16 bit signed short integers).
 """
 
+from __future__ import print_function
 import sys
 import os
 import pmt
@@ -179,13 +180,13 @@ class rx_cfile_block(gr.top_block):
                     rx_serial = info["rx_serial"]
                 rx_antenna = info["rx_antenna"]
                 rx_subdev_spec = info["rx_subdev_spec"]
-                print "[UHD_RX] Motherboard: %s (%s)" % (mboard_id, mboard_serial)
+                print("[UHD_RX] Motherboard: %s (%s)" % (mboard_id, mboard_serial))
                 if "B200" in mboard_id or "B210" in mboard_id or "E310" in mboard_id:
-                    print "[UHD_RX] Daughterboard: %s (%s, %s)" % (mboard_id, rx_antenna, rx_subdev_spec)
+                    print("[UHD_RX] Daughterboard: %s (%s, %s)" % (mboard_id, rx_antenna, rx_subdev_spec))
                 else:
-                    print "[UHD_RX] Daughterboard: %s (%s, %s, %s)" % (rx_id, rx_serial, rx_antenna, rx_subdev_spec)
+                    print("[UHD_RX] Daughterboard: %s (%s, %s, %s)" % (rx_id, rx_serial, rx_antenna, rx_subdev_spec))
             except KeyError:
-                print "[UHD_RX] Args: ", options.args
+                print("[UHD_RX] Args: ", options.args)
             print("[UHD_RX] Receiving on {} channels.".format(len(self.channels)))
             print("[UHD_RX] Rx gain:               {gain}".format(gain=gain))
             print("[UHD_RX] Rx frequency:          {freq}".format(freq=freq))
diff -uNrp a/gr-uhd/apps/uhd_rx_nogui b/gr-uhd/apps/uhd_rx_nogui
--- a/gr-uhd/apps/uhd_rx_nogui	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-uhd/apps/uhd_rx_nogui	2019-10-20 04:31:39.000000000 +0700
@@ -32,7 +32,7 @@ RFSQL - RF squelch zeroing output when i
 AGC   - Automatic gain control leveling signal at [-1.0, +1.0]
 DEMOD - Demodulation block appropriate to selected signal type.
         This converts the complex baseband to real audio frequencies,
-	and applies an appropriate low pass decimating filter.
+        and applies an appropriate low pass decimating filter.
 CTCSS - Optional tone squelch zeroing output when tone is not present.
 RSAMP - Resampler block to convert audio sample rate to user specified
         sound card output rate.
@@ -40,8 +40,8 @@ AUDIO - Audio sink for playing final out
 
 The following are required command line parameters:
 
--f FREQ		USRP receive frequency
--m MOD		Modulation type, select from AM, FM, or WFM
+-f FREQ         USRP receive frequency
+-m MOD          Modulation type, select from AM, FM, or WFM
 
 The following are optional command line parameters:
 
@@ -51,8 +51,8 @@ The following are optional command line 
 -g GAIN         Daughterboard gain setting. Defaults to mid-range.
 -o RATE         Sound card output rate. Defaults to 32000. Useful if
                 your sound card only accepts particular sample rates.
--r RFSQL	RF squelch in db. Defaults to -50.0.
--p FREQ		CTCSS frequency.  Opens squelch when tone is present.
+-r RFSQL        RF squelch in db. Defaults to -50.0.
+-p FREQ         CTCSS frequency.  Opens squelch when tone is present.
 
 Once the program is running, ctrl-break (Ctrl-C) stops operation.
 
@@ -61,6 +61,7 @@ blocks.
 """
 
 from __future__ import print_function
+from __future__ import division
 import sys
 from argparse import ArgumentParser
 from gnuradio import gr, gru, uhd, audio
@@ -72,10 +73,10 @@ from gnuradio.eng_option import eng_opti
 
 # (device_rate, channel_rate, audio_rate, channel_pass, channel_stop, demod)
 DEMOD_PARAMS = {
-		'AM'  : (256e3,  16e3, 16e3,  5000,   8000, analog.demod_10k0a3e_cf),
-		'FM'  : (256e3,  32e3,  8e3,  8000,   9000, analog.demod_20k0f3e_cf),
-		'WFM' : (320e3, 320e3, 32e3, 80000, 115000, analog.demod_200kf3e_cf)
-	       }
+                'AM'  : (256e3,  16e3, 16e3,  5000,   8000, analog.demod_10k0a3e_cf),
+                'FM'  : (256e3,  32e3,  8e3,  8000,   9000, analog.demod_20k0f3e_cf),
+                'WFM' : (320e3, 320e3, 32e3, 80000, 115000, analog.demod_200kf3e_cf)
+               }
 
 class uhd_src(gr.hier_block2):
     """
@@ -140,37 +141,37 @@ class app_top_block(gr.top_block):
         dev = uhd_src(options.args,             # UHD device address
                       options.spec,             # device subdev spec
                       options.antenna,          # device antenna
-                      dev_rate,         	# device sample rate
-                      options.gain, 	    	# Receiver gain
+                      dev_rate,                 # device sample rate
+                      options.gain,             # Receiver gain
                       options.calibration)      # Frequency offset
         dev.tune(options.frequency)
 
         if_rate = dev.rate()
-        channel_decim = int(if_rate // channel_rate)
-        audio_decim = int(channel_rate // audio_rate)
+        channel_decim = if_rate // channel_rate
+        audio_decim = channel_rate // audio_rate
 
         chan_taps = filter.optfir.low_pass(1.0,          # Filter gain
-                                           if_rate, 	 # Sample rate
+                                           if_rate,      # Sample rate
                                            channel_pass, # One sided modulation bandwidth
                                            channel_stop, # One sided channel bandwidth
-                                           0.1, 	 # Passband ripple
-                                           60) 	         # Stopband attenuation
+                                           0.1,          # Passband ripple
+                                           60)           # Stopband attenuation
 
         chan = filter.freq_xlating_fir_filter_ccf(
             channel_decim, # Decimation rate
             chan_taps,     # Filter taps
-            0.0, 	   # Offset frequency
+            0.0,           # Offset frequency
             if_rate)       # Sample rate
 
         rfsql = analog.pwr_squelch_cc(
             options.rf_squelch,    # Power threshold
             125.0/channel_rate,    # Time constant
             int(channel_rate/20),  # 50ms rise/fall
-            False)		   # Zero, not gate output
+            False)                 # Zero, not gate output
 
         agc = analog.agc_cc(1.0/channel_rate,  # Time constant
-                            1.0,     	       # Reference power
-                            1.0)	       # Gain
+                            1.0,               # Reference power
+                            1.0)               # Gain
 
         demod = demod(channel_rate, audio_decim)
 
@@ -188,8 +189,8 @@ class app_top_block(gr.top_block):
 
         if options.output_rate != audio_rate:
             out_lcm = gru.lcm(audio_rate, options.output_rate)
-            out_interp = int(out_lcm // audio_rate)
-            out_decim = int(out_lcm // options.output_rate)
+            out_interp = out_lcm // audio_rate
+            out_decim = out_lcm // options.output_rate
             rsamp = filter.rational_resampler_fff(out_interp, out_decim)
             self.connect(tail, rsamp)
             tail = rsamp
diff -uNrp a/gr-uhd/examples/c++/tag_source_demo.h b/gr-uhd/examples/c++/tag_source_demo.h
--- a/gr-uhd/examples/c++/tag_source_demo.h	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-uhd/examples/c++/tag_source_demo.h	2019-10-20 04:31:39.000000000 +0700
@@ -109,10 +109,11 @@ public:
             _do_new_burst = false;
             _samps_left_in_burst = _samps_per_burst;
 
-            if (pmt::is_null(_length_tag_key))
+            if (pmt::is_null(_length_tag_key)) {
                 this->make_sob_tag(this->nitems_written(0));
-            else
+            } else {
 #if 1
+                (void)_samp_rate; // avoid unused variable warning
                 this->make_length_tag(this->nitems_written(0), _samps_left_in_burst);
 #else
                 // Test usrp_sink's ability to cancel remainder of burst if new length_tag
@@ -123,6 +124,7 @@ public:
                 this->make_length_tag(this->nitems_written(0),
                                       uint64_t(1.1 * _samp_rate * _cycle_duration));
 #endif
+            }
             this->make_time_tag(this->nitems_written(0));
 
             _time_fracs += _cycle_duration;
diff -uNrp a/gr-uhd/lib/usrp_block_impl.cc b/gr-uhd/lib/usrp_block_impl.cc
--- a/gr-uhd/lib/usrp_block_impl.cc	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-uhd/lib/usrp_block_impl.cc	2019-10-20 04:31:39.000000000 +0700
@@ -238,7 +238,7 @@ bool usrp_block_impl::_unpack_chan_comma
         } else {
             return false;
         }
-    } catch (pmt::wrong_type w) {
+    } catch (pmt::wrong_type& w) {
         return false;
     }
     return true;
diff -uNrp a/gr-utils/octave/write_complex_binary.m b/gr-utils/octave/write_complex_binary.m
--- a/gr-utils/octave/write_complex_binary.m	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-utils/octave/write_complex_binary.m	2019-10-20 04:31:39.000000000 +0700
@@ -26,7 +26,7 @@ function v = write_complex_binary (data,
   %%  open filename and write data to it
   %%  Format is interleaved float IQ e.g. each
   %%  I,Q 32-bit float IQIQIQ....
-  %%  This is compatabile with read_complex_binary()
+  %%  This is compatible with read_complex_binary()
   %%
 
   m = nargchk (2,2,nargin);
diff -uNrp a/gr-utils/python/modtool/cli/base.py b/gr-utils/python/modtool/cli/base.py
--- a/gr-utils/python/modtool/cli/base.py	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-utils/python/modtool/cli/base.py	2019-10-20 04:31:39.000000000 +0700
@@ -122,7 +122,11 @@ def setup_cli_logger(logger):
 
 def cli_input(msg):
     """ Returns enhanced input """
-    return input(click.style(msg, fg='cyan'))
+    if sys.version_info[0] < 3:
+        in_func = raw_input
+    else:
+        in_func = input
+    return in_func(click.style(msg, fg='cyan'))
 
 
 def common_params(func):
diff -uNrp a/gr-utils/python/modtool/core/rename.py b/gr-utils/python/modtool/core/rename.py
--- a/gr-utils/python/modtool/core/rename.py	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-utils/python/modtool/core/rename.py	2019-10-20 04:31:39.000000000 +0700
@@ -175,7 +175,7 @@ class ModToolRename(ModTool):
         if not os.path.isfile(filename):
             return False
         else:
-            logger.info("In '{}' renaming occurences of '{}' to '{}'".format(filename, old, new))
+            logger.info("In '{}' renaming occurrences of '{}' to '{}'".format(filename, old, new))
 
         with open(filename) as f:
             cfile = f.read()
diff -uNrp a/gr-utils/python/modtool/templates/templates.py b/gr-utils/python/modtool/templates/templates.py
--- a/gr-utils/python/modtool/templates/templates.py	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-utils/python/modtool/templates/templates.py	2019-10-20 04:31:39.000000000 +0700
@@ -550,11 +550,11 @@ templates:
   imports: import ${modname}
   make: ${modname}.${blockname}(${strip_arg_types_grc(arglist)})
 
-#  Make one 'parameters' list entry for every Parameter you want settable from the GUI.
-#     Sub-entries of dictionary:
+#  Make one 'parameters' list entry for every parameter you want settable from the GUI.
+#     Keys include:
 #     * id (makes the value accessible as \$keyname, e.g. in the make entry)
-#     * label
-#     * dtype 
+#     * label (label shown in the GUI)
+#     * dtype (e.g. int, float, complex, byte, short, xxx_vector, ...)
 parameters:
 - id: ...
   label: ...
@@ -563,27 +563,29 @@ parameters:
   label: ...
   dtype: ...
 
-#  Make one 'inputs' list entry per input. Sub-entries of dictionary:
+#  Make one 'inputs' list entry per input and one 'outputs' list entry per output.
+#  Keys include:
 #      * label (an identifier for the GUI)
-#      * domain
-#      * dtype
-#      * vlen
-#      * optional (set to 1 for optional inputs) 
+#      * domain (optional - stream or message. Default is stream)
+#      * dtype (e.g. int, float, complex, byte, short, xxx_vector, ...)
+#      * vlen (optional - data stream vector length. Default is 1)
+#      * optional (optional - set to 1 for optional inputs. Default is 0)
 inputs:
 - label: ...
   domain: ...
   dtype: ...
   vlen: ...
+  optional: ...
 
-#  Make one 'outputs' list entry per output. Sub-entries of dictionary:
-#      * label (an identifier for the GUI)
-#      * dtype
-#      * vlen
-#      * optional (set to 1 for optional inputs) 
+outputs:
 - label: ...
   domain: ...
-  dtype: ... #!-- e.g. int, float, complex, byte, short, xxx_vector, ...--
+  dtype: ...
+  vlen: ...
+  optional: ...
 
+#  'file_format' specifies the version of the GRC yml format used in the file
+#  and should usually not be changed.
 file_format: 1
 '''
 
diff -uNrp a/gr-utils/python/modtool/tools/util_functions.py b/gr-utils/python/modtool/tools/util_functions.py
--- a/gr-utils/python/modtool/tools/util_functions.py	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-utils/python/modtool/tools/util_functions.py	2019-10-20 04:31:39.000000000 +0700
@@ -143,8 +143,12 @@ def is_number(s):
 def ask_yes_no(question, default):
     """ Asks a binary question. Returns True for yes, False for no.
     default is given as a boolean. """
+    if sys.version_info[0] < 3:
+        in_func = raw_input
+    else:
+        in_func = input
     question += {True: ' [Y/n] ', False: ' [y/N] '}[default]
-    if input(question).lower() != {True: 'n', False: 'y'}[default]:
+    if in_func(question).lower() != {True: 'n', False: 'y'}[default]:
         return default
     else:
         return not default
diff -uNrp a/gr-vocoder/examples/cvsd_audio_loopback.py b/gr-vocoder/examples/cvsd_audio_loopback.py
--- a/gr-vocoder/examples/cvsd_audio_loopback.py	2019-08-10 04:15:36.000000000 +0700
+++ b/gr-vocoder/examples/cvsd_audio_loopback.py	2019-10-20 04:31:39.000000000 +0700
@@ -52,15 +52,15 @@ def build_graph():
     tb.connect(enc, dec, s2f, decim, sink_scale, sink)
 
     if 0: # debug
-        tb.conect(src, blocks.file_sink(gr.sizeof_float, "source.dat"))
-        tb.conect(src_scale, blocks.file_sink(gr.sizeof_float, "src_scale.dat"))
-        tb.conect(interp, blocks.file_sink(gr.sizeof_float, "interp.dat"))
-        tb.conect(f2s, blocks.file_sink(gr.sizeof_short, "f2s.dat"))
-        tb.conect(enc, blocks.file_sink(gr.sizeof_char,  "enc.dat"))
-        tb.conect(dec, blocks.file_sink(gr.sizeof_short, "dec.dat"))
-        tb.conect(s2f, blocks.file_sink(gr.sizeof_float, "s2f.dat"))
-        tb.conect(decim, blocks.file_sink(gr.sizeof_float, "decim.dat"))
-        tb.conect(sink_scale, blocks.file_sink(gr.sizeof_float, "sink_scale.dat"))
+        tb.connect(src, blocks.file_sink(gr.sizeof_float, "source.dat"))
+        tb.connect(src_scale, blocks.file_sink(gr.sizeof_float, "src_scale.dat"))
+        tb.connect(interp, blocks.file_sink(gr.sizeof_float, "interp.dat"))
+        tb.connect(f2s, blocks.file_sink(gr.sizeof_short, "f2s.dat"))
+        tb.connect(enc, blocks.file_sink(gr.sizeof_char,  "enc.dat"))
+        tb.connect(dec, blocks.file_sink(gr.sizeof_short, "dec.dat"))
+        tb.connect(s2f, blocks.file_sink(gr.sizeof_float, "s2f.dat"))
+        tb.connect(decim, blocks.file_sink(gr.sizeof_float, "decim.dat"))
+        tb.connect(sink_scale, blocks.file_sink(gr.sizeof_float, "sink_scale.dat"))
 
     return tb
 
diff -uNrp a/grc/core/blocks/block.py b/grc/core/blocks/block.py
--- a/grc/core/blocks/block.py	2019-08-10 04:15:36.000000000 +0700
+++ b/grc/core/blocks/block.py	2019-10-20 04:31:39.000000000 +0700
@@ -207,6 +207,7 @@ class Block(Element):
     def _rewrite_nports(self, ports):
         for port in ports:
             if hasattr(port, 'master_port'):  # Not a master port and no left-over clones
+                port.dtype = port.master_port.dtype
                 continue
             nports = port.multiplicity
             for clone in port.clones[nports-1:]:
diff -uNrp a/grc/core/generator/cpp_templates/flow_graph.hpp.mako b/grc/core/generator/cpp_templates/flow_graph.hpp.mako
--- a/grc/core/generator/cpp_templates/flow_graph.hpp.mako	2019-08-10 04:15:36.000000000 +0700
+++ b/grc/core/generator/cpp_templates/flow_graph.hpp.mako	2019-10-20 04:31:39.000000000 +0700
@@ -92,8 +92,8 @@ public:
 % if not generate_options.startswith('hb'):
     top_block_sptr tb;
 % endif
-	${class_name}(${param_str});
-	~${class_name}();
+    ${class_name}(${param_str});
+    ~${class_name}();
 
 % for var in parameters + variables:
     ${var.vtype} get_${var.name} () const;
diff -uNrp a/grc/core/generator/flow_graph.py.mako b/grc/core/generator/flow_graph.py.mako
--- a/grc/core/generator/flow_graph.py.mako	2019-08-10 04:15:36.000000000 +0700
+++ b/grc/core/generator/flow_graph.py.mako	2019-10-20 04:31:39.000000000 +0700
@@ -190,18 +190,18 @@ gr.io_signaturev(${len(io_sigs)}, ${len(
         % if blk_make:
         ${ indent(blk_make.strip('\n')) }
         % endif
-##         % if 'alias' in blk.params and blk.params['alias'].get_evaluated():
-##         (self.${blk.name}).set_block_alias("${blk.params['alias'].get_evaluated()}")
-##         % endif
-##         % if 'affinity' in blk.params and blk.params['affinity'].get_evaluated():
-##         (self.${blk.name}).set_processor_affinity(${blk.params['affinity'].get_evaluated()})
-##         % endif
-##         % if len(blk.sources) > 0 and 'minoutbuf' in blk.params and int(blk.params['minoutbuf'].get_evaluated()) > 0:
-##         (self.${blk.name}).set_min_output_buffer(${blk.params['minoutbuf'].get_evaluated()})
-##         % endif
-##         % if len(blk.sources) > 0 and 'maxoutbuf' in blk.params and int(blk.params['maxoutbuf'].get_evaluated()) > 0:
-##         (self.${blk.name}).set_max_output_buffer(${blk.params['maxoutbuf'].get_evaluated()})
-##         % endif
+        % if 'alias' in blk.params and blk.params['alias'].get_evaluated():
+        self.${blk.name}.set_block_alias("${blk.params['alias'].get_evaluated()}")
+        % endif
+        % if 'affinity' in blk.params and blk.params['affinity'].get_evaluated():
+        self.${blk.name}.set_processor_affinity(${blk.params['affinity'].get_evaluated()})
+        % endif
+        % if len(blk.sources) > 0 and 'minoutbuf' in blk.params and int(blk.params['minoutbuf'].get_evaluated()) > 0:
+        self.${blk.name}.set_min_output_buffer(${blk.params['minoutbuf'].get_evaluated()})
+        % endif
+        % if len(blk.sources) > 0 and 'maxoutbuf' in blk.params and int(blk.params['maxoutbuf'].get_evaluated()) > 0:
+        self.${blk.name}.set_max_output_buffer(${blk.params['maxoutbuf'].get_evaluated()})
+        % endif
         % endfor
 
 ##########################################################
diff -uNrp a/grc/gui/Application.py b/grc/gui/Application.py
--- a/grc/gui/Application.py	2019-08-10 04:15:36.000000000 +0700
+++ b/grc/gui/Application.py	2019-10-20 04:31:39.000000000 +0700
@@ -686,6 +686,7 @@ class Application(Gtk.Application):
             # Import the old data and mark the current as not saved
             new_flow_graph.import_data(previous.export_data())
             flow_graph_update(new_flow_graph)
+            page.state_cache.save_new_state(new_flow_graph.export_data())
             page.saved = False
         elif action == Actions.FLOW_GRAPH_SCREEN_CAPTURE:
             file_path, background_transparent = FileDialogs.SaveScreenShot(main, page.file_path).run()
